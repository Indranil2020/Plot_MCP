{
  "animation": [
    {
      "filename": "animate_decay.py",
      "title": "Animate Decay",
      "code": "\"\"\"\n=====\nDecay\n=====\n\nThis example showcases:\n\n- using a generator to drive an animation,\n- changing axes limits during an animation.\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport itertools\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n\ndef data_gen():\n    for cnt in itertools.count():\n        t = cnt / 10\n        yield t, np.sin(2*np.pi*t) * np.exp(-t/10.)\n\n\ndef init():\n    ax.set_ylim(-1.1, 1.1)\n    ax.set_xlim(0, 1)\n    del xdata[:]\n    del ydata[:]\n    line.set_data(xdata, ydata)\n    return line,\n\nfig, ax = plt.subplots()\nline, = ax.plot([], [], lw=2)\nax.grid()\nxdata, ydata = [], []\n\n\ndef run(data):\n    # update the data\n    t, y = data\n    xdata.append(t)\n    ydata.append(y)\n    xmin, xmax = ax.get_xlim()\n\n    if t >= xmax:\n        ax.set_xlim(xmin, 2*xmax)\n        ax.figure.canvas.draw()\n    line.set_data(xdata, ydata)\n\n    return line,\n\n# Only save last 100 frames, but run forever\nani = animation.FuncAnimation(fig, run, data_gen, interval=100, init_func=init,\n                              save_count=100)\nplt.show()\n"
    },
    {
      "filename": "animated_histogram.py",
      "title": "Animated Histogram",
      "code": "\"\"\"\n==================\nAnimated histogram\n==================\n\nUse histogram's `.BarContainer` to draw a bunch of rectangles for an animated\nhistogram.\n\"\"\"\n\nimport functools\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n# Setting up a random number generator with a fixed state for reproducibility.\nrng = np.random.default_rng(seed=19680801)\n# Fixing bin edges.\nHIST_BINS = np.linspace(-4, 4, 100)\n\n# Histogram our data with numpy.\ndata = rng.standard_normal(1000)\nn, _ = np.histogram(data, HIST_BINS)\n\n# %%\n# To animate the histogram, we need an ``animate`` function, which generates\n# a random set of numbers and updates the heights of rectangles. The ``animate``\n# function updates the `.Rectangle` patches on an instance of `.BarContainer`.\n\n\ndef animate(frame_number, bar_container):\n    # Simulate new data coming in.\n    data = rng.standard_normal(1000)\n    n, _ = np.histogram(data, HIST_BINS)\n    for count, rect in zip(n, bar_container.patches):\n        rect.set_height(count)\n\n    return bar_container.patches\n\n# %%\n# Using :func:`~matplotlib.pyplot.hist` allows us to get an instance of\n# `.BarContainer`, which is a collection of `.Rectangle` instances.  Since\n# `.FuncAnimation` will only pass the frame number parameter to the animation\n# function, we use `functools.partial` to fix the ``bar_container`` parameter.\n\n# Output generated via `matplotlib.animation.Animation.to_jshtml`.\n\nfig, ax = plt.subplots()\n_, _, bar_container = ax.hist(data, HIST_BINS, lw=1,\n                              ec=\"yellow\", fc=\"green\", alpha=0.5)\nax.set_ylim(top=55)  # set safe limit to ensure that all data is visible.\n\nanim = functools.partial(animate, bar_container=bar_container)\nani = animation.FuncAnimation(fig, anim, 50, repeat=False, blit=True)\nplt.show()\n\n# %%\n# .. tags:: plot-type: histogram, animation\n"
    },
    {
      "filename": "animation_demo.py",
      "title": "Animation Demo",
      "code": "\"\"\"\n================\npyplot animation\n================\n\nGenerating an animation by calling `~.pyplot.pause` between plotting commands.\n\nThe method shown here is only suitable for simple, low-performance use.  For\nmore demanding applications, look at the :mod:`.animation` module and the\nexamples that use it.\n\nNote that calling `time.sleep` instead of `~.pyplot.pause` would *not* work.\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\ndata = np.random.random((50, 50, 50))\n\nfig, ax = plt.subplots()\n\nfor i, img in enumerate(data):\n    ax.clear()\n    ax.imshow(img)\n    ax.set_title(f\"frame {i}\")\n    # Note that using time.sleep does *not* work here!\n    plt.pause(0.1)\n"
    },
    {
      "filename": "bayes_update.py",
      "title": "Bayes Update",
      "code": "\"\"\"\n================\nThe Bayes update\n================\n\nThis animation displays the posterior estimate updates as it is refitted when\nnew data arrives.\nThe vertical line represents the theoretical value to which the plotted\ndistribution should converge.\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.animation import FuncAnimation\n\n\ndef beta_pdf(x, a, b):\n    return (x**(a-1) * (1-x)**(b-1) * math.gamma(a + b)\n            / (math.gamma(a) * math.gamma(b)))\n\n\nclass UpdateDist:\n    def __init__(self, ax, prob=0.5):\n        self.success = 0\n        self.prob = prob\n        self.line, = ax.plot([], [], 'k-')\n        self.x = np.linspace(0, 1, 200)\n        self.ax = ax\n\n        # Set up plot parameters\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 10)\n        self.ax.grid(True)\n\n        # This vertical line represents the theoretical value, to\n        # which the plotted distribution should converge.\n        self.ax.axvline(prob, linestyle='--', color='black')\n\n    def start(self):\n        # Used for the *init_func* parameter of FuncAnimation; this is called when\n        # initializing the animation, and also after resizing the figure.\n        return self.line,\n\n    def __call__(self, i):\n        # This way the plot can continuously run and we just keep\n        # watching new realizations of the process\n        if i == 0:\n            self.success = 0\n            self.line.set_data([], [])\n            return self.line,\n\n        # Choose success based on exceed a threshold with a uniform pick\n        if np.random.rand() < self.prob:\n            self.success += 1\n        y = beta_pdf(self.x, self.success + 1, (i - self.success) + 1)\n        self.line.set_data(self.x, y)\n        return self.line,\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nud = UpdateDist(ax, prob=0.7)\nanim = FuncAnimation(fig, ud, init_func=ud.start, frames=100, interval=100, blit=True)\nplt.show()\n\n# %%\n# .. tags:: animation, plot-type: line\n"
    },
    {
      "filename": "double_pendulum.py",
      "title": "Double Pendulum",
      "code": "\"\"\"\n===========================\nThe double pendulum problem\n===========================\n\nThis animation illustrates the double pendulum problem.\n\nDouble pendulum formula translated from the C code at\nhttp://www.physics.usyd.edu.au/~wheat/dpend_html/solve_dpend.c\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy import cos, sin\n\nimport matplotlib.animation as animation\n\nG = 9.8  # acceleration due to gravity, in m/s^2\nL1 = 1.0  # length of pendulum 1 in m\nL2 = 1.0  # length of pendulum 2 in m\nL = L1 + L2  # maximal length of the combined pendulum\nM1 = 1.0  # mass of pendulum 1 in kg\nM2 = 1.0  # mass of pendulum 2 in kg\nt_stop = 2.5  # how many seconds to simulate\nhistory_len = 500  # how many trajectory points to display\n\n\ndef derivs(t, state):\n    dydx = np.zeros_like(state)\n\n    dydx[0] = state[1]\n\n    delta = state[2] - state[0]\n    den1 = (M1+M2) * L1 - M2 * L1 * cos(delta) * cos(delta)\n    dydx[1] = ((M2 * L1 * state[1] * state[1] * sin(delta) * cos(delta)\n                + M2 * G * sin(state[2]) * cos(delta)\n                + M2 * L2 * state[3] * state[3] * sin(delta)\n                - (M1+M2) * G * sin(state[0]))\n               / den1)\n\n    dydx[2] = state[3]\n\n    den2 = (L2/L1) * den1\n    dydx[3] = ((- M2 * L2 * state[3] * state[3] * sin(delta) * cos(delta)\n                + (M1+M2) * G * sin(state[0]) * cos(delta)\n                - (M1+M2) * L1 * state[1] * state[1] * sin(delta)\n                - (M1+M2) * G * sin(state[2]))\n               / den2)\n\n    return dydx\n\n# create a time array from 0..t_stop sampled at 0.02 second steps\ndt = 0.01\nt = np.arange(0, t_stop, dt)\n\n# th1 and th2 are the initial angles (degrees)\n# w10 and w20 are the initial angular velocities (degrees per second)\nth1 = 120.0\nw1 = 0.0\nth2 = -10.0\nw2 = 0.0\n\n# initial state\nstate = np.radians([th1, w1, th2, w2])\n\n# integrate the ODE using Euler's method\ny = np.empty((len(t), 4))\ny[0] = state\nfor i in range(1, len(t)):\n    y[i] = y[i - 1] + derivs(t[i - 1], y[i - 1]) * dt\n\n# A more accurate estimate could be obtained e.g. using scipy:\n#\n#   y = scipy.integrate.solve_ivp(derivs, t[[0, -1]], state, t_eval=t).y.T\n\nx1 = L1*sin(y[:, 0])\ny1 = -L1*cos(y[:, 0])\n\nx2 = L2*sin(y[:, 2]) + x1\ny2 = -L2*cos(y[:, 2]) + y1\n\nfig = plt.figure(figsize=(5, 4))\nax = fig.add_subplot(autoscale_on=False, xlim=(-L, L), ylim=(-L, 1.))\nax.set_aspect('equal')\nax.grid()\n\nline, = ax.plot([], [], 'o-', lw=2)\ntrace, = ax.plot([], [], '.-', lw=1, ms=2)\ntime_template = 'time = %.1fs'\ntime_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)\n\n\ndef animate(i):\n    thisx = [0, x1[i], x2[i]]\n    thisy = [0, y1[i], y2[i]]\n\n    history_x = x2[:i]\n    history_y = y2[:i]\n\n    line.set_data(thisx, thisy)\n    trace.set_data(history_x, history_y)\n    time_text.set_text(time_template % (i*dt))\n    return line, trace, time_text\n\n\nani = animation.FuncAnimation(\n    fig, animate, len(y), interval=dt*1000, blit=True)\nplt.show()\n"
    },
    {
      "filename": "dynamic_image.py",
      "title": "Dynamic Image",
      "code": "\"\"\"\n=================================================\nAnimated image using a precomputed list of images\n=================================================\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\n\ndef f(x, y):\n    return np.sin(x) + np.cos(y)\n\nx = np.linspace(0, 2 * np.pi, 120)\ny = np.linspace(0, 2 * np.pi, 100).reshape(-1, 1)\n\n# ims is a list of lists, each row is a list of artists to draw in the\n# current frame; here we are just animating one artist, the image, in\n# each frame\nims = []\nfor i in range(60):\n    x += np.pi / 15\n    y += np.pi / 30\n    im = ax.imshow(f(x, y), animated=True)\n    if i == 0:\n        ax.imshow(f(x, y))  # show an initial one first\n    ims.append([im])\n\nani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,\n                                repeat_delay=1000)\n\n# To save the animation, use e.g.\n#\n# ani.save(\"movie.mp4\")\n#\n# or\n#\n# writer = animation.FFMpegWriter(\n#     fps=15, metadata=dict(artist='Me'), bitrate=1800)\n# ani.save(\"movie.mp4\", writer=writer)\n\nplt.show()\n\n# %%\n# .. tags:: animation\n"
    },
    {
      "filename": "frame_grabbing_sgskip.py",
      "title": "Frame Grabbing Sgskip",
      "code": "\"\"\"\n==============\nFrame grabbing\n==============\n\nUse a MovieWriter directly to grab individual frames and write them to a\nfile.  This avoids any event loop integration, and thus works even with the Agg\nbackend.  This is not recommended for use in an interactive setting.\n\"\"\"\n\nimport numpy as np\n\nimport matplotlib\n\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.animation import FFMpegWriter\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nmetadata = dict(title='Movie Test', artist='Matplotlib',\n                comment='Movie support!')\nwriter = FFMpegWriter(fps=15, metadata=metadata)\n\nfig = plt.figure()\nl, = plt.plot([], [], 'k-o')\n\nplt.xlim(-5, 5)\nplt.ylim(-5, 5)\n\nx0, y0 = 0, 0\n\nwith writer.saving(fig, \"writer_test.mp4\", 100):\n    for i in range(100):\n        x0 += 0.1 * np.random.randn()\n        y0 += 0.1 * np.random.randn()\n        l.set_data([x0], [y0])\n        writer.grab_frame()\n"
    },
    {
      "filename": "multiple_axes.py",
      "title": "Multiple Axes",
      "code": "\"\"\"\n=======================\nMultiple Axes animation\n=======================\n\nThis example showcases:\n\n- how animation across multiple subplots works,\n- using a figure artist in the animation.\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\nfrom matplotlib.patches import ConnectionPatch\n\nfig, (axl, axr) = plt.subplots(\n    ncols=2,\n    sharey=True,\n    figsize=(6, 2),\n    gridspec_kw=dict(width_ratios=[1, 3], wspace=0),\n)\naxl.set_aspect(1)\naxr.set_box_aspect(1 / 3)\naxr.yaxis.set_visible(False)\naxr.xaxis.set_ticks([0, np.pi, 2 * np.pi], [\"0\", r\"$\\pi$\", r\"$2\\pi$\"])\n\n# draw circle with initial point in left Axes\nx = np.linspace(0, 2 * np.pi, 50)\naxl.plot(np.cos(x), np.sin(x), \"k\", lw=0.3)\npoint, = axl.plot(0, 0, \"o\")\n\n# draw full curve to set view limits in right Axes\nsine, = axr.plot(x, np.sin(x))\n\n# draw connecting line between both graphs\ncon = ConnectionPatch(\n    (1, 0),\n    (0, 0),\n    \"data\",\n    \"data\",\n    axesA=axl,\n    axesB=axr,\n    color=\"C0\",\n    ls=\"dotted\",\n)\nfig.add_artist(con)\n\n\ndef animate(i):\n    x = np.linspace(0, i, int(i * 25 / np.pi))\n    sine.set_data(x, np.sin(x))\n    x, y = np.cos(i), np.sin(i)\n    point.set_data([x], [y])\n    con.xy1 = x, y\n    con.xy2 = i, y\n    return point, sine, con\n\n\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    interval=50,\n    blit=False,  # blitting can't be used with Figure artists\n    frames=x,\n    repeat_delay=100,\n)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches.ConnectionPatch`\n#    - `matplotlib.animation.FuncAnimation`\n#\n# .. tags:: component: axes, animation\n"
    },
    {
      "filename": "pause_resume.py",
      "title": "Pause Resume",
      "code": "\"\"\"\n=============================\nPause and resume an animation\n=============================\n\nThis example showcases:\n\n- using the Animation.pause() method to pause an animation.\n- using the Animation.resume() method to resume an animation.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n\nclass PauseAnimation:\n    def __init__(self):\n        fig, ax = plt.subplots()\n        ax.set_title('Click to pause/resume the animation')\n        x = np.linspace(-0.1, 0.1, 1000)\n\n        # Start with a normal distribution\n        self.n0 = (1.0 / ((4 * np.pi * 2e-4 * 0.1) ** 0.5)\n                   * np.exp(-x ** 2 / (4 * 2e-4 * 0.1)))\n        self.p, = ax.plot(x, self.n0)\n\n        self.animation = animation.FuncAnimation(\n            fig, self.update, frames=200, interval=50, blit=True)\n        self.paused = False\n\n        fig.canvas.mpl_connect('button_press_event', self.toggle_pause)\n\n    def toggle_pause(self, *args, **kwargs):\n        if self.paused:\n            self.animation.resume()\n        else:\n            self.animation.pause()\n        self.paused = not self.paused\n\n    def update(self, i):\n        self.n0 += i / 100 % 5\n        self.p.set_ydata(self.n0 % 20)\n        return (self.p,)\n\n\npa = PauseAnimation()\nplt.show()\n"
    },
    {
      "filename": "rain.py",
      "title": "Rain",
      "code": "\"\"\"\n===============\nRain simulation\n===============\n\nSimulates rain drops on a surface by animating the scale and opacity\nof 50 scatter points.\n\nAuthor: Nicolas P. Rougier\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.animation import FuncAnimation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# Create new Figure and an Axes which fills it.\nfig = plt.figure(figsize=(7, 7))\nax = fig.add_axes([0, 0, 1, 1], frameon=False)\nax.set_xlim(0, 1), ax.set_xticks([])\nax.set_ylim(0, 1), ax.set_yticks([])\n\n# Create rain data\nn_drops = 50\nrain_drops = np.zeros(n_drops, dtype=[('position', float, (2,)),\n                                      ('size',     float),\n                                      ('growth',   float),\n                                      ('color',    float, (4,))])\n\n# Initialize the raindrops in random positions and with\n# random growth rates.\nrain_drops['position'] = np.random.uniform(0, 1, (n_drops, 2))\nrain_drops['growth'] = np.random.uniform(50, 200, n_drops)\n\n# Construct the scatter which we will update during animation\n# as the raindrops develop.\nscat = ax.scatter(rain_drops['position'][:, 0], rain_drops['position'][:, 1],\n                  s=rain_drops['size'], lw=0.5, edgecolors=rain_drops['color'],\n                  facecolors='none')\n\n\ndef update(frame_number):\n    # Get an index which we can use to re-spawn the oldest raindrop.\n    current_index = frame_number % n_drops\n\n    # Make all colors more transparent as time progresses.\n    rain_drops['color'][:, 3] -= 1.0/len(rain_drops)\n    rain_drops['color'][:, 3] = np.clip(rain_drops['color'][:, 3], 0, 1)\n\n    # Make all circles bigger.\n    rain_drops['size'] += rain_drops['growth']\n\n    # Pick a new position for oldest rain drop, resetting its size,\n    # color and growth factor.\n    rain_drops['position'][current_index] = np.random.uniform(0, 1, 2)\n    rain_drops['size'][current_index] = 5\n    rain_drops['color'][current_index] = (0, 0, 0, 1)\n    rain_drops['growth'][current_index] = np.random.uniform(50, 200)\n\n    # Update the scatter collection, with the new colors, sizes and positions.\n    scat.set_edgecolors(rain_drops['color'])\n    scat.set_sizes(rain_drops['size'])\n    scat.set_offsets(rain_drops['position'])\n    return [scat]\n\n\n# Construct the animation, using the update function as the animation director.\nanimation = FuncAnimation(fig, update, interval=10, save_count=100, blit=True)\nplt.show()\n"
    },
    {
      "filename": "random_walk.py",
      "title": "Random Walk",
      "code": "\"\"\"\n=======================\nAnimated 3D random walk\n=======================\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef random_walk(num_steps, max_step=0.05):\n    \"\"\"Return a 3D random walk as (num_steps, 3) array.\"\"\"\n    start_pos = np.random.random(3)\n    steps = np.random.uniform(-max_step, max_step, size=(num_steps, 3))\n    walk = start_pos + np.cumsum(steps, axis=0)\n    return walk\n\n\ndef update_lines(num, walks, lines):\n    for line, walk in zip(lines, walks):\n        line.set_data_3d(walk[:num, :].T)\n    return lines\n\n\n# Data: 40 random walks as (num_steps, 3) arrays\nnum_steps = 30\nwalks = [random_walk(num_steps) for index in range(40)]\n\n# Attaching 3D axis to the figure\nfig = plt.figure()\nax = fig.add_subplot(projection=\"3d\")\n\n# Create lines initially without data\nlines = [ax.plot([], [], [])[0] for _ in walks]\n\n# Setting the Axes properties\nax.set(xlim3d=(0, 1), xlabel='X')\nax.set(ylim3d=(0, 1), ylabel='Y')\nax.set(zlim3d=(0, 1), zlabel='Z')\n\n# Creating the Animation object\nani = animation.FuncAnimation(\n    fig, update_lines, num_steps, fargs=(walks, lines), interval=100)\n\nplt.show()\n\n# %%\n# .. tags:: animation, plot-type: 3D\n"
    },
    {
      "filename": "simple_anim.py",
      "title": "Simple Anim",
      "code": "\"\"\"\n==================\nAnimated line plot\n==================\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\nx = np.arange(0, 2*np.pi, 0.01)\nline, = ax.plot(x, np.sin(x))\n\n\ndef animate(i):\n    line.set_ydata(np.sin(x + i / 50))  # update the data.\n    return line,\n\n\nani = animation.FuncAnimation(\n    fig, animate, interval=20, blit=True, save_count=50)\n\n# To save the animation, use e.g.\n#\n# ani.save(\"movie.mp4\")\n#\n# or\n#\n# writer = animation.FFMpegWriter(\n#     fps=15, metadata=dict(artist='Me'), bitrate=1800)\n# ani.save(\"movie.mp4\", writer=writer)\n\nplt.show()\n"
    },
    {
      "filename": "simple_scatter.py",
      "title": "Simple Scatter",
      "code": "\"\"\"\n=============================\nAnimated scatter saved as GIF\n=============================\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\nax.set_xlim([0, 10])\n\nscat = ax.scatter(1, 0)\nx = np.linspace(0, 10)\n\n\ndef animate(i):\n    scat.set_offsets((x[i], 0))\n    return (scat,)\n\n\nani = animation.FuncAnimation(fig, animate, repeat=True, frames=len(x) - 1, interval=50)\n\n# To save the animation using Pillow as a gif\n# writer = animation.PillowWriter(fps=15,\n#                                 metadata=dict(artist='Me'),\n#                                 bitrate=1800)\n# ani.save('scatter.gif', writer=writer)\n\nplt.show()\n\n# %%\n#\n# .. tags::\n#    component: animation,\n#    plot-type: scatter,\n#    purpose: reference,\n#    level: intermediate\n"
    },
    {
      "filename": "strip_chart.py",
      "title": "Strip Chart",
      "code": "\"\"\"\n============\nOscilloscope\n============\n\nEmulates an oscilloscope.\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\nfrom matplotlib.lines import Line2D\n\n\nclass Scope:\n    def __init__(self, ax, maxt=2, dt=0.02):\n        self.ax = ax\n        self.dt = dt\n        self.maxt = maxt\n        self.tdata = [0]\n        self.ydata = [0]\n        self.line = Line2D(self.tdata, self.ydata)\n        self.ax.add_line(self.line)\n        self.ax.set_ylim(-.1, 1.1)\n        self.ax.set_xlim(0, self.maxt)\n\n    def update(self, y):\n        lastt = self.tdata[-1]\n        if lastt >= self.tdata[0] + self.maxt:  # reset the arrays\n            self.tdata = [self.tdata[-1]]\n            self.ydata = [self.ydata[-1]]\n            self.ax.set_xlim(self.tdata[0], self.tdata[0] + self.maxt)\n            self.ax.figure.canvas.draw()\n\n        # This slightly more complex calculation avoids floating-point issues\n        # from just repeatedly adding `self.dt` to the previous value.\n        t = self.tdata[0] + len(self.tdata) * self.dt\n\n        self.tdata.append(t)\n        self.ydata.append(y)\n        self.line.set_data(self.tdata, self.ydata)\n        return self.line,\n\n\ndef emitter(p=0.1):\n    \"\"\"Return a random value in [0, 1) with probability p, else 0.\"\"\"\n    while True:\n        v = np.random.rand()\n        if v > p:\n            yield 0.\n        else:\n            yield np.random.rand()\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801 // 10)\n\n\nfig, ax = plt.subplots()\nscope = Scope(ax)\n\n# pass a generator in \"emitter\" to produce data for the update func\nani = animation.FuncAnimation(fig, scope.update, emitter, interval=50,\n                              blit=True, save_count=100)\n\nplt.show()\n\n# ..tags:: animation, plot-type: line\n"
    },
    {
      "filename": "unchained.py",
      "title": "Unchained",
      "code": "\"\"\"\n====================\nMatplotlib unchained\n====================\n\nComparative path demonstration of frequency from a fake signal of a pulsar\n(mostly known because of the cover for Joy Division's Unknown Pleasures).\n\nAuthor: Nicolas P. Rougier\n\nOutput generated via `matplotlib.animation.Animation.to_jshtml`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# Create new Figure with black background\nfig = plt.figure(figsize=(8, 8), facecolor='black')\n\n# Add a subplot with no frame\nax = plt.subplot(frameon=False)\n\n# Generate random data\ndata = np.random.uniform(0, 1, (64, 75))\nX = np.linspace(-1, 1, data.shape[-1])\nG = 1.5 * np.exp(-4 * X ** 2)\n\n# Generate line plots\nlines = []\nfor i in range(len(data)):\n    # Small reduction of the X extents to get a cheap perspective effect\n    xscale = 1 - i / 200.\n    # Same for linewidth (thicker strokes on bottom)\n    lw = 1.5 - i / 100.0\n    line, = ax.plot(xscale * X, i + G * data[i], color=\"w\", lw=lw)\n    lines.append(line)\n\n# Set y limit (or first line is cropped because of thickness)\nax.set_ylim(-1, 70)\n\n# No ticks\nax.set_xticks([])\nax.set_yticks([])\n\n# 2 part titles to get different font weights\nax.text(0.5, 1.0, \"MATPLOTLIB \", transform=ax.transAxes,\n        ha=\"right\", va=\"bottom\", color=\"w\",\n        family=\"sans-serif\", fontweight=\"light\", fontsize=16)\nax.text(0.5, 1.0, \"UNCHAINED\", transform=ax.transAxes,\n        ha=\"left\", va=\"bottom\", color=\"w\",\n        family=\"sans-serif\", fontweight=\"bold\", fontsize=16)\n\n\ndef update(*args):\n    # Shift all data to the right\n    data[:, 1:] = data[:, :-1]\n\n    # Fill-in new values\n    data[:, 0] = np.random.uniform(0, 1, len(data))\n\n    # Update data\n    for i in range(len(data)):\n        lines[i].set_ydata(i + G * data[i])\n\n    # Return modified artists\n    return lines\n\n# Construct the animation, using the update function as the animation director.\nanim = animation.FuncAnimation(fig, update, interval=10, save_count=100)\nplt.show()\n"
    }
  ],
  "axes_grid1": [
    {
      "filename": "demo_anchored_direction_arrows.py",
      "title": "Demo Anchored Direction Arrows",
      "code": "\"\"\"\n========================\nAnchored Direction Arrow\n========================\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.font_manager as fm\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredDirectionArrows\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nax.imshow(np.random.random((10, 10)))\n\n# Simple example\nsimple_arrow = AnchoredDirectionArrows(ax.transAxes, 'X', 'Y')\nax.add_artist(simple_arrow)\n\n# High contrast arrow\nhigh_contrast_part_1 = AnchoredDirectionArrows(\n                            ax.transAxes,\n                            '111', r'11$\\overline{2}$',\n                            loc='upper right',\n                            arrow_props={'ec': 'w', 'fc': 'none', 'alpha': 1,\n                                         'lw': 2}\n                            )\nax.add_artist(high_contrast_part_1)\n\nhigh_contrast_part_2 = AnchoredDirectionArrows(\n                            ax.transAxes,\n                            '111', r'11$\\overline{2}$',\n                            loc='upper right',\n                            arrow_props={'ec': 'none', 'fc': 'k'},\n                            text_props={'ec': 'w', 'fc': 'k', 'lw': 0.4}\n                            )\nax.add_artist(high_contrast_part_2)\n\n# Rotated arrow\nfontprops = fm.FontProperties(family='serif')\n\nrotated_arrow = AnchoredDirectionArrows(\n                    ax.transAxes,\n                    '30', '120',\n                    loc='center',\n                    color='w',\n                    angle=30,\n                    fontproperties=fontprops\n                    )\nax.add_artist(rotated_arrow)\n\n# Altering arrow directions\na1 = AnchoredDirectionArrows(\n        ax.transAxes, 'A', 'B', loc='lower center',\n        length=-0.15,\n        sep_x=0.03, sep_y=0.03,\n        color='r'\n    )\nax.add_artist(a1)\n\na2 = AnchoredDirectionArrows(\n        ax.transAxes, 'A', ' B', loc='lower left',\n        aspect_ratio=-1,\n        sep_x=0.01, sep_y=-0.02,\n        color='orange'\n        )\nax.add_artist(a2)\n\n\na3 = AnchoredDirectionArrows(\n        ax.transAxes, ' A', 'B', loc='lower right',\n        length=-0.15,\n        aspect_ratio=-1,\n        sep_y=-0.1, sep_x=0.04,\n        color='cyan'\n        )\nax.add_artist(a3)\n\nplt.show()\n"
    },
    {
      "filename": "demo_axes_divider.py",
      "title": "Demo Axes Divider",
      "code": "\"\"\"\n============\nAxes divider\n============\n\nAxes divider to calculate location of Axes and\ncreate a divider for them using existing Axes instances.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\n\n\ndef get_demo_image():\n    z = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\n    return z, (-3, 4, -4, 3)\n\n\ndef demo_simple_image(ax):\n    Z, extent = get_demo_image()\n\n    im = ax.imshow(Z, extent=extent)\n    cb = plt.colorbar(im)\n    cb.ax.yaxis.set_tick_params(labelright=False)\n\n\ndef demo_locatable_axes_hard(fig):\n    from mpl_toolkits.axes_grid1 import Size, SubplotDivider\n\n    divider = SubplotDivider(fig, 2, 2, 2, aspect=True)\n\n    # Axes for image\n    ax = fig.add_subplot(axes_locator=divider.new_locator(nx=0, ny=0))\n    # Axes for colorbar\n    ax_cb = fig.add_subplot(axes_locator=divider.new_locator(nx=2, ny=0))\n\n    divider.set_horizontal([\n        Size.AxesX(ax),  # main Axes\n        Size.Fixed(0.05),  # padding, 0.1 inch\n        Size.Fixed(0.2),  # colorbar, 0.3 inch\n    ])\n    divider.set_vertical([Size.AxesY(ax)])\n\n    Z, extent = get_demo_image()\n\n    im = ax.imshow(Z, extent=extent)\n    plt.colorbar(im, cax=ax_cb)\n    ax_cb.yaxis.set_tick_params(labelright=False)\n\n\ndef demo_locatable_axes_easy(ax):\n    from mpl_toolkits.axes_grid1 import make_axes_locatable\n\n    divider = make_axes_locatable(ax)\n\n    ax_cb = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n    fig = ax.get_figure()\n    fig.add_axes(ax_cb)\n\n    Z, extent = get_demo_image()\n    im = ax.imshow(Z, extent=extent)\n\n    plt.colorbar(im, cax=ax_cb)\n    ax_cb.yaxis.tick_right()\n    ax_cb.yaxis.set_tick_params(labelright=False)\n\n\ndef demo_images_side_by_side(ax):\n    from mpl_toolkits.axes_grid1 import make_axes_locatable\n\n    divider = make_axes_locatable(ax)\n\n    Z, extent = get_demo_image()\n    ax2 = divider.append_axes(\"right\", size=\"100%\", pad=0.05)\n    fig1 = ax.get_figure()\n    fig1.add_axes(ax2)\n\n    ax.imshow(Z, extent=extent)\n    ax2.imshow(Z, extent=extent)\n    ax2.yaxis.set_tick_params(labelleft=False)\n\n\ndef demo():\n    fig = plt.figure(figsize=(6, 6))\n\n    # PLOT 1\n    # simple image & colorbar\n    ax = fig.add_subplot(2, 2, 1)\n    demo_simple_image(ax)\n\n    # PLOT 2\n    # image and colorbar with draw-time positioning -- a hard way\n    demo_locatable_axes_hard(fig)\n\n    # PLOT 3\n    # image and colorbar with draw-time positioning -- an easy way\n    ax = fig.add_subplot(2, 2, 3)\n    demo_locatable_axes_easy(ax)\n\n    # PLOT 4\n    # two images side by side with fixed padding.\n    ax = fig.add_subplot(2, 2, 4)\n    demo_images_side_by_side(ax)\n\n    plt.show()\n\n\ndemo()\n"
    },
    {
      "filename": "demo_axes_grid.py",
      "title": "Demo Axes Grid",
      "code": "\"\"\"\n==============\nDemo Axes Grid\n==============\n\nGrid of 2x2 images with a single colorbar or with one colorbar per Axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure(figsize=(10.5, 2.5))\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\nextent = (-3, 4, -4, 3)\n\n\n# A grid of 2x2 images with 0.05 inch pad between images and only the\n# lower-left Axes is labeled.\ngrid = ImageGrid(\n    fig, 141,  # similar to fig.add_subplot(141).\n     nrows_ncols=(2, 2), axes_pad=0.05, label_mode=\"1\")\nfor ax in grid:\n    ax.imshow(Z, extent=extent)\n# This only affects Axes in first column and second row as share_all=False.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\n# A grid of 2x2 images with a single colorbar.\ngrid = ImageGrid(\n    fig, 142,  # similar to fig.add_subplot(142).\n    nrows_ncols=(2, 2), axes_pad=0.0, label_mode=\"L\", share_all=True,\n    cbar_location=\"top\", cbar_mode=\"single\")\nfor ax in grid:\n    im = ax.imshow(Z, extent=extent)\ngrid.cbar_axes[0].colorbar(im)\nfor cax in grid.cbar_axes:\n    cax.tick_params(labeltop=False)\n# This affects all Axes as share_all = True.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\n# A grid of 2x2 images. Each image has its own colorbar.\ngrid = ImageGrid(\n    fig, 143,  # similar to fig.add_subplot(143).\n    nrows_ncols=(2, 2), axes_pad=0.1, label_mode=\"1\", share_all=True,\n    cbar_location=\"top\", cbar_mode=\"each\", cbar_size=\"7%\", cbar_pad=\"2%\")\nfor ax, cax in zip(grid, grid.cbar_axes):\n    im = ax.imshow(Z, extent=extent)\n    cax.colorbar(im)\n    cax.tick_params(labeltop=False)\n# This affects all Axes as share_all = True.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\n# A grid of 2x2 images. Each image has its own colorbar.\ngrid = ImageGrid(\n    fig, 144,  # similar to fig.add_subplot(144).\n    nrows_ncols=(2, 2), axes_pad=(0.45, 0.15), label_mode=\"1\", share_all=True,\n    cbar_location=\"right\", cbar_mode=\"each\", cbar_size=\"7%\", cbar_pad=\"2%\")\n# Use a different colorbar range every time\nlimits = ((0, 1), (-2, 2), (-1.7, 1.4), (-1.5, 1))\nfor ax, cax, vlim in zip(grid, grid.cbar_axes, limits):\n    im = ax.imshow(Z, extent=extent, vmin=vlim[0], vmax=vlim[1])\n    cb = cax.colorbar(im)\n    cb.set_ticks((vlim[0], vlim[1]))\n# This affects all Axes as share_all = True.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\nplt.show()\n"
    },
    {
      "filename": "demo_axes_grid2.py",
      "title": "Demo Axes Grid2",
      "code": "\"\"\"\n==========\nAxes Grid2\n==========\n\nGrid of images with shared xaxis and yaxis.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\n\ndef add_inner_title(ax, title, loc, **kwargs):\n    from matplotlib.offsetbox import AnchoredText\n    from matplotlib.patheffects import withStroke\n    prop = dict(path_effects=[withStroke(foreground='w', linewidth=3)],\n                size=plt.rcParams['legend.fontsize'])\n    at = AnchoredText(title, loc=loc, prop=prop,\n                      pad=0., borderpad=0.5,\n                      frameon=False, **kwargs)\n    ax.add_artist(at)\n    return at\n\n\nfig = plt.figure(figsize=(6, 6))\n\n# Prepare images\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")\nextent = (-3, 4, -4, 3)\nZS = [Z[i::3, :] for i in range(3)]\nextent = extent[0], extent[1]/3., extent[2], extent[3]\n\n# *** Demo 1: colorbar at each Axes ***\ngrid = ImageGrid(\n    # 211 = at the position of fig.add_subplot(211)\n    fig, 211, nrows_ncols=(1, 3), axes_pad=0.05, label_mode=\"1\", share_all=True,\n    cbar_location=\"top\", cbar_mode=\"each\", cbar_size=\"7%\", cbar_pad=\"1%\")\ngrid[0].set(xticks=[-2, 0], yticks=[-2, 0, 2])\n\nfor i, (ax, z) in enumerate(zip(grid, ZS)):\n    im = ax.imshow(z, origin=\"lower\", extent=extent)\n    cb = ax.cax.colorbar(im)\n    # Changing the colorbar ticks\n    if i in [1, 2]:\n        cb.set_ticks([-1, 0, 1])\n\nfor ax, im_title in zip(grid, [\"Image 1\", \"Image 2\", \"Image 3\"]):\n    add_inner_title(ax, im_title, loc='lower left')\n\n# *** Demo 2: shared colorbar ***\ngrid2 = ImageGrid(\n    fig, 212, nrows_ncols=(1, 3), axes_pad=0.05, label_mode=\"1\", share_all=True,\n    cbar_location=\"right\", cbar_mode=\"single\", cbar_size=\"10%\", cbar_pad=0.05)\ngrid2[0].set(xlabel=\"X\", ylabel=\"Y\", xticks=[-2, 0], yticks=[-2, 0, 2])\n\nclim = (np.min(ZS), np.max(ZS))\nfor ax, z in zip(grid2, ZS):\n    im = ax.imshow(z, clim=clim, origin=\"lower\", extent=extent)\n\n# With cbar_mode=\"single\", cax attribute of all Axes are identical.\nax.cax.colorbar(im)\n\nfor ax, im_title in zip(grid2, [\"(a)\", \"(b)\", \"(c)\"]):\n    add_inner_title(ax, im_title, loc='upper left')\n\nplt.show()\n"
    },
    {
      "filename": "demo_axes_hbox_divider.py",
      "title": "Demo Axes Hbox Divider",
      "code": "\"\"\"\n================================\nHBoxDivider and VBoxDivider demo\n================================\n\nUsing an `.HBoxDivider` to arrange subplots.\n\nNote that both Axes' location are adjusted so that they have\nequal heights while maintaining their aspect ratios.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1.axes_divider import HBoxDivider, VBoxDivider\nimport mpl_toolkits.axes_grid1.axes_size as Size\n\narr1 = np.arange(20).reshape((4, 5))\narr2 = np.arange(20).reshape((5, 4))\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nax1.imshow(arr1)\nax2.imshow(arr2)\n\npad = 0.5  # pad in inches\ndivider = HBoxDivider(\n    fig, 111,\n    horizontal=[Size.AxesX(ax1), Size.Fixed(pad), Size.AxesX(ax2)],\n    vertical=[Size.AxesY(ax1), Size.Scaled(1), Size.AxesY(ax2)])\nax1.set_axes_locator(divider.new_locator(0))\nax2.set_axes_locator(divider.new_locator(2))\n\nplt.show()\n\n# %%\n# Using a `.VBoxDivider` to arrange subplots.\n#\n# Note that both Axes' location are adjusted so that they have\n# equal widths while maintaining their aspect ratios.\n\nfig, (ax1, ax2) = plt.subplots(2, 1)\nax1.imshow(arr1)\nax2.imshow(arr2)\n\ndivider = VBoxDivider(\n    fig, 111,\n    horizontal=[Size.AxesX(ax1), Size.Scaled(1), Size.AxesX(ax2)],\n    vertical=[Size.AxesY(ax1), Size.Fixed(pad), Size.AxesY(ax2)])\n\nax1.set_axes_locator(divider.new_locator(0))\nax2.set_axes_locator(divider.new_locator(2))\n\nplt.show()\n"
    },
    {
      "filename": "demo_axes_rgb.py",
      "title": "Demo Axes Rgb",
      "code": "\"\"\"\n===============================\nShow RGB channels using RGBAxes\n===============================\n\n`~.axes_grid1.axes_rgb.RGBAxes` creates a layout of 4 Axes for displaying RGB\nchannels: one large Axes for the RGB image and 3 smaller Axes for the R, G, B\nchannels.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1.axes_rgb import RGBAxes, make_rgb_axes\n\n\ndef get_rgb():\n    Z = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")\n    Z[Z < 0] = 0.\n    Z = Z / Z.max()\n\n    R = Z[:13, :13]\n    G = Z[2:, 2:]\n    B = Z[:13, 2:]\n\n    return R, G, B\n\n\ndef make_cube(r, g, b):\n    ny, nx = r.shape\n    R = np.zeros((ny, nx, 3))\n    R[:, :, 0] = r\n    G = np.zeros_like(R)\n    G[:, :, 1] = g\n    B = np.zeros_like(R)\n    B[:, :, 2] = b\n\n    RGB = R + G + B\n\n    return R, G, B, RGB\n\n\ndef demo_rgb1():\n    fig = plt.figure()\n    ax = RGBAxes(fig, [0.1, 0.1, 0.8, 0.8], pad=0.0)\n    r, g, b = get_rgb()\n    ax.imshow_rgb(r, g, b)\n\n\ndef demo_rgb2():\n    fig, ax = plt.subplots()\n    ax_r, ax_g, ax_b = make_rgb_axes(ax, pad=0.02)\n\n    r, g, b = get_rgb()\n    im_r, im_g, im_b, im_rgb = make_cube(r, g, b)\n    ax.imshow(im_rgb)\n    ax_r.imshow(im_r)\n    ax_g.imshow(im_g)\n    ax_b.imshow(im_b)\n\n    for ax in fig.axes:\n        ax.tick_params(direction='in', color='w')\n        ax.spines[:].set_color(\"w\")\n\n\ndemo_rgb1()\ndemo_rgb2()\n\nplt.show()\n"
    },
    {
      "filename": "demo_colorbar_with_axes_divider.py",
      "title": "Demo Colorbar With Axes Divider",
      "code": "\"\"\"\n.. _demo-colorbar-with-axes-divider:\n\n=========================\nColorbar with AxesDivider\n=========================\n\nThe `.axes_divider.make_axes_locatable` function takes an existing Axes, adds\nit to a new `.AxesDivider` and returns the `.AxesDivider`.  The `.append_axes`\nmethod of the `.AxesDivider` can then be used to create a new Axes on a given\nside (\"top\", \"right\", \"bottom\", or \"left\") of the original Axes. This example\nuses `.append_axes` to add colorbars next to Axes.\n\nUsers should consider simply passing the main Axes to the *ax* keyword argument of\n`~.Figure.colorbar` instead of creating a locatable Axes manually like this.\nSee :ref:`colorbar_placement`.\n\n.. redirect-from:: /gallery/axes_grid1/simple_colorbar\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.subplots_adjust(wspace=0.5)\n\nim1 = ax1.imshow([[1, 2], [3, 4]])\nax1_divider = make_axes_locatable(ax1)\n# Add an Axes to the right of the main Axes.\ncax1 = ax1_divider.append_axes(\"right\", size=\"7%\", pad=\"2%\")\ncb1 = fig.colorbar(im1, cax=cax1)\n\nim2 = ax2.imshow([[1, 2], [3, 4]])\nax2_divider = make_axes_locatable(ax2)\n# Add an Axes above the main Axes.\ncax2 = ax2_divider.append_axes(\"top\", size=\"7%\", pad=\"2%\")\ncb2 = fig.colorbar(im2, cax=cax2, orientation=\"horizontal\")\n# Change tick position to top (with the default tick position \"bottom\", ticks\n# overlap the image).\ncax2.xaxis.set_ticks_position(\"top\")\n\nplt.show()\n"
    },
    {
      "filename": "demo_colorbar_with_inset_locator.py",
      "title": "Demo Colorbar With Inset Locator",
      "code": "\"\"\"\n.. _demo-colorbar-with-inset-locator:\n\n===========================================================\nControl the position and size of a colorbar with Inset Axes\n===========================================================\n\nThis example shows how to control the position, height, and width of colorbars\nusing `~mpl_toolkits.axes_grid1.inset_locator.inset_axes`.\n\nInset Axes placement is controlled as for legends: either by providing a *loc*\noption (\"upper right\", \"best\", ...), or by providing a locator with respect to\nthe parent bbox.  Parameters such as *bbox_to_anchor* and *borderpad* likewise\nwork in the same way, and are also demonstrated here.\n\nUsers should consider using `.Axes.inset_axes` instead (see\n:ref:`colorbar_placement`).\n\n.. redirect-from:: /gallery/axes_grid1/demo_colorbar_of_inset_axes\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=[6, 3])\n\nim1 = ax1.imshow([[1, 2], [2, 3]])\naxins1 = inset_axes(\n    ax1,\n    width=\"50%\",  # width: 50% of parent_bbox width\n    height=\"5%\",  # height: 5%\n    loc=\"upper right\",\n)\naxins1.xaxis.set_ticks_position(\"bottom\")\nfig.colorbar(im1, cax=axins1, orientation=\"horizontal\", ticks=[1, 2, 3])\n\nim = ax2.imshow([[1, 2], [2, 3]])\naxins = inset_axes(\n    ax2,\n    width=\"5%\",  # width: 5% of parent_bbox width\n    height=\"50%\",  # height: 50%\n    loc=\"lower left\",\n    bbox_to_anchor=(1.05, 0., 1, 1),\n    bbox_transform=ax2.transAxes,\n    borderpad=0,\n)\nfig.colorbar(im, cax=axins, ticks=[1, 2, 3])\n\nplt.show()\n"
    },
    {
      "filename": "demo_edge_colorbar.py",
      "title": "Demo Edge Colorbar",
      "code": "\"\"\"\n===============================\nPer-row or per-column colorbars\n===============================\n\nThis example shows how to use one common colorbar for each row or column\nof an image grid.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import AxesGrid\n\n\ndef get_demo_image():\n    z = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\n    return z, (-3, 4, -4, 3)\n\n\ndef demo_bottom_cbar(fig):\n    \"\"\"\n    A grid of 2x2 images with a colorbar for each column.\n    \"\"\"\n    grid = AxesGrid(fig, 121,  # similar to subplot(121)\n                    nrows_ncols=(2, 2),\n                    axes_pad=0.10,\n                    share_all=True,\n                    label_mode=\"1\",\n                    cbar_location=\"bottom\",\n                    cbar_mode=\"edge\",\n                    cbar_pad=0.25,\n                    cbar_size=\"15%\",\n                    direction=\"column\"\n                    )\n\n    Z, extent = get_demo_image()\n    cmaps = [\"autumn\", \"summer\"]\n    for i in range(4):\n        im = grid[i].imshow(Z, extent=extent, cmap=cmaps[i//2])\n        if i % 2:\n            grid.cbar_axes[i//2].colorbar(im)\n\n    for cax in grid.cbar_axes:\n        cax.axis[cax.orientation].set_label(\"Bar\")\n\n    # This affects all Axes as share_all = True.\n    grid.axes_llc.set_xticks([-2, 0, 2])\n    grid.axes_llc.set_yticks([-2, 0, 2])\n\n\ndef demo_right_cbar(fig):\n    \"\"\"\n    A grid of 2x2 images. Each row has its own colorbar.\n    \"\"\"\n    grid = AxesGrid(fig, 122,  # similar to subplot(122)\n                    nrows_ncols=(2, 2),\n                    axes_pad=0.10,\n                    label_mode=\"1\",\n                    share_all=True,\n                    cbar_location=\"right\",\n                    cbar_mode=\"edge\",\n                    cbar_size=\"7%\",\n                    cbar_pad=\"2%\",\n                    )\n    Z, extent = get_demo_image()\n    cmaps = [\"spring\", \"winter\"]\n    for i in range(4):\n        im = grid[i].imshow(Z, extent=extent, cmap=cmaps[i//2])\n        if i % 2:\n            grid.cbar_axes[i//2].colorbar(im)\n\n    for cax in grid.cbar_axes:\n        cax.axis[cax.orientation].set_label('Foo')\n\n    # This affects all Axes because we set share_all = True.\n    grid.axes_llc.set_xticks([-2, 0, 2])\n    grid.axes_llc.set_yticks([-2, 0, 2])\n\n\nfig = plt.figure()\n\ndemo_bottom_cbar(fig)\ndemo_right_cbar(fig)\n\nplt.show()\n"
    },
    {
      "filename": "demo_fixed_size_axes.py",
      "title": "Demo Fixed Size Axes",
      "code": "\"\"\"\n===============================\nAxes with a fixed physical size\n===============================\n\nNote that this can be accomplished with the main library for\nAxes on Figures that do not change size: :ref:`fixed_size_axes`\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider, Size\n\n# %%\n\n\nfig = plt.figure(figsize=(6, 6))\n\n# The first items are for padding and the second items are for the Axes.\n# sizes are in inch.\nh = [Size.Fixed(1.0), Size.Fixed(4.5)]\nv = [Size.Fixed(0.7), Size.Fixed(5.)]\n\ndivider = Divider(fig, (0, 0, 1, 1), h, v, aspect=False)\n# The width and height of the rectangle are ignored.\n\nax = fig.add_axes(divider.get_position(),\n                  axes_locator=divider.new_locator(nx=1, ny=1))\n\nax.plot([1, 2, 3])\n\n# %%\n\n\nfig = plt.figure(figsize=(6, 6))\n\n# The first & third items are for padding and the second items are for the\n# Axes. Sizes are in inches.\nh = [Size.Fixed(1.0), Size.Scaled(1.), Size.Fixed(.2)]\nv = [Size.Fixed(0.7), Size.Scaled(1.), Size.Fixed(.5)]\n\ndivider = Divider(fig, (0, 0, 1, 1), h, v, aspect=False)\n# The width and height of the rectangle are ignored.\n\nax = fig.add_axes(divider.get_position(),\n                  axes_locator=divider.new_locator(nx=1, ny=1))\n\nax.plot([1, 2, 3])\n\nplt.show()\n"
    },
    {
      "filename": "demo_imagegrid_aspect.py",
      "title": "Demo Imagegrid Aspect",
      "code": "\"\"\"\n=========================================\nImageGrid cells with a fixed aspect ratio\n=========================================\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure()\n\ngrid1 = ImageGrid(fig, 121, (2, 2), axes_pad=0.1,\n                  aspect=True, share_all=True)\nfor i in [0, 1]:\n    grid1[i].set_aspect(2)\n\ngrid2 = ImageGrid(fig, 122, (2, 2), axes_pad=0.1,\n                  aspect=True, share_all=True)\nfor i in [1, 3]:\n    grid2[i].set_aspect(2)\n\nplt.show()\n"
    },
    {
      "filename": "inset_locator_demo.py",
      "title": "Inset Locator Demo",
      "code": "\"\"\"\n==================\nInset locator demo\n==================\n\n\"\"\"\n\n# %%\n# The `.inset_locator`'s `~.inset_locator.inset_axes` allows\n# easily placing insets in the corners of the Axes by specifying a width and\n# height and optionally a location (loc) that accepts locations as codes,\n# similar to `~matplotlib.axes.Axes.legend`.\n# By default, the inset is offset by some points from the axes,\n# controlled via the *borderpad* parameter.\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\nfig, (ax, ax2) = plt.subplots(1, 2, figsize=[5.5, 2.8])\n\n# Create inset of width 1.3 inches and height 0.9 inches\n# at the default upper right location.\naxins = inset_axes(ax, width=1.3, height=0.9)\n\n# Create inset of width 30% and height 40% of the parent Axes' bounding box\n# at the lower left corner.\naxins2 = inset_axes(ax, width=\"30%\", height=\"40%\", loc=\"lower left\")\n\n# Create inset of mixed specifications in the second subplot;\n# width is 30% of parent Axes' bounding box and\n# height is 1 inch at the upper left corner.\naxins3 = inset_axes(ax2, width=\"30%\", height=1., loc=\"upper left\")\n\n# Create an inset in the lower right corner with borderpad=1, i.e.\n# 10 points padding (as 10pt is the default fontsize) to the parent Axes.\naxins4 = inset_axes(ax2, width=\"20%\", height=\"20%\", loc=\"lower right\", borderpad=1)\n\n# Turn ticklabels of insets off\nfor axi in [axins, axins2, axins3, axins4]:\n    axi.tick_params(labelleft=False, labelbottom=False)\n\nplt.show()\n\n\n# %%\n# The parameters *bbox_to_anchor* and *bbox_transform* can be used for a more\n# fine-grained control over the inset position and size or even to position\n# the inset at completely arbitrary positions.\n# The *bbox_to_anchor* sets the bounding box in coordinates according to the\n# *bbox_transform*.\n#\n\nfig = plt.figure(figsize=[5.5, 2.8])\nax = fig.add_subplot(121)\n\n# We use the Axes transform as bbox_transform. Therefore, the bounding box\n# needs to be specified in axes coordinates ((0, 0) is the lower left corner\n# of the Axes, (1, 1) is the upper right corner).\n# The bounding box (.2, .4, .6, .5) starts at (.2, .4) and ranges to (.8, .9)\n# in those coordinates.\n# Inside this bounding box an inset of half the bounding box' width and\n# three quarters of the bounding box' height is created. The lower left corner\n# of the inset is aligned to the lower left corner of the bounding box.\n# The inset is then offset by the default 0.5 in units of the font size.\n\naxins = inset_axes(ax, width=\"50%\", height=\"75%\",\n                   bbox_to_anchor=(.2, .4, .6, .5),\n                   bbox_transform=ax.transAxes, loc=\"lower left\")\n\n# For visualization purposes we mark the bounding box by a rectangle\nax.add_patch(plt.Rectangle((.2, .4), .6, .5, ls=\"--\", ec=\"c\", fc=\"none\",\n                           transform=ax.transAxes))\n\n# We set the axis limits to something other than the default, in order to not\n# distract from the fact that axes coordinates are used here.\nax.set(xlim=(0, 10), ylim=(0, 10))\n\n\n# Note how the two following insets are created at the same positions, one by\n# use of the default parent Axes' bbox and the other via a bbox in Axes\n# coordinates and the respective transform.\nax2 = fig.add_subplot(222)\naxins2 = inset_axes(ax2, width=\"30%\", height=\"50%\")\n\nax3 = fig.add_subplot(224)\naxins3 = inset_axes(ax3, width=\"100%\", height=\"100%\",\n                    bbox_to_anchor=(.7, .5, .3, .5),\n                    bbox_transform=ax3.transAxes)\n\n# For visualization purposes we mark the bounding box by a rectangle\nax2.add_patch(plt.Rectangle((0, 0), 1, 1, ls=\"--\", lw=2, ec=\"c\", fc=\"none\"))\nax3.add_patch(plt.Rectangle((.7, .5), .3, .5, ls=\"--\", lw=2,\n                            ec=\"c\", fc=\"none\"))\n\n# Turn ticklabels off\nfor axi in [axins2, axins3, ax2, ax3]:\n    axi.tick_params(labelleft=False, labelbottom=False)\n\nplt.show()\n\n\n# %%\n# In the above the Axes transform together with 4-tuple bounding boxes has been\n# used as it mostly is useful to specify an inset relative to the Axes it is\n# an inset to. However, other use cases are equally possible. The following\n# example examines some of those.\n#\n\nfig = plt.figure(figsize=[5.5, 2.8])\nax = fig.add_subplot(131)\n\n# Create an inset outside the Axes\naxins = inset_axes(ax, width=\"100%\", height=\"100%\",\n                   bbox_to_anchor=(1.05, .6, .5, .4),\n                   bbox_transform=ax.transAxes, loc=\"upper left\", borderpad=0)\naxins.tick_params(left=False, right=True, labelleft=False, labelright=True)\n\n# Create an inset with a 2-tuple bounding box. Note that this creates a\n# bbox without extent. This hence only makes sense when specifying\n# width and height in absolute units (inches).\naxins2 = inset_axes(ax, width=0.5, height=0.4,\n                    bbox_to_anchor=(0.33, 0.25),\n                    bbox_transform=ax.transAxes, loc=\"lower left\", borderpad=0)\n\n\nax2 = fig.add_subplot(133)\nax2.set_xscale(\"log\")\nax2.set(xlim=(1e-6, 1e6), ylim=(-2, 6))\n\n# Create inset in data coordinates using ax.transData as transform\naxins3 = inset_axes(ax2, width=\"100%\", height=\"100%\",\n                    bbox_to_anchor=(1e-2, 2, 1e3, 3),\n                    bbox_transform=ax2.transData, loc=\"upper left\", borderpad=0)\n\n# Create an inset horizontally centered in figure coordinates and vertically\n# bound to line up with the Axes.\nfrom matplotlib.transforms import blended_transform_factory  # noqa\n\ntransform = blended_transform_factory(fig.transFigure, ax2.transAxes)\naxins4 = inset_axes(ax2, width=\"16%\", height=\"34%\",\n                    bbox_to_anchor=(0, 0, 1, 1),\n                    bbox_transform=transform, loc=\"lower center\", borderpad=0)\n\nplt.show()\n"
    },
    {
      "filename": "inset_locator_demo2.py",
      "title": "Inset Locator Demo2",
      "code": "\"\"\"\n====================\nInset locator demo 2\n====================\n\nThis demo shows how to create a zoomed inset via `.zoomed_inset_axes`.\nIn the first subplot an `.AnchoredSizeBar` shows the zoom effect.\nIn the second subplot a connection to the region of interest is\ncreated via `.mark_inset`.\n\nA version of the second subplot, not using the toolkit, is available in\n:doc:`/gallery/subplots_axes_and_figures/zoom_inset_axes`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\nfrom mpl_toolkits.axes_grid1.inset_locator import mark_inset, zoomed_inset_axes\n\nfig, (ax, ax2) = plt.subplots(ncols=2, figsize=[6, 3])\n\n\n# First subplot, showing an inset with a size bar.\nax.set_aspect(1)\n\naxins = zoomed_inset_axes(ax, zoom=0.5, loc='upper right')\n# fix the number of ticks on the inset Axes\naxins.yaxis.get_major_locator().set_params(nbins=7)\naxins.xaxis.get_major_locator().set_params(nbins=7)\naxins.tick_params(labelleft=False, labelbottom=False)\n\n\ndef add_sizebar(ax, size):\n    asb = AnchoredSizeBar(ax.transData,\n                          size,\n                          str(size),\n                          loc=\"lower center\",\n                          pad=0.1, borderpad=0.5, sep=5,\n                          frameon=False)\n    ax.add_artist(asb)\n\nadd_sizebar(ax, 0.5)\nadd_sizebar(axins, 0.5)\n\n\n# Second subplot, showing an image with an inset zoom and a marked inset\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\nextent = (-3, 4, -4, 3)\nZ2 = np.zeros((150, 150))\nny, nx = Z.shape\nZ2[30:30+ny, 30:30+nx] = Z\n\nax2.imshow(Z2, extent=extent, origin=\"lower\")\n\naxins2 = zoomed_inset_axes(ax2, zoom=6, loc=\"upper right\")\naxins2.imshow(Z2, extent=extent, origin=\"lower\")\n\n# subregion of the original image\nx1, x2, y1, y2 = -1.5, -0.9, -2.5, -1.9\naxins2.set_xlim(x1, x2)\naxins2.set_ylim(y1, y2)\n# fix the number of ticks on the inset Axes\naxins2.yaxis.get_major_locator().set_params(nbins=7)\naxins2.xaxis.get_major_locator().set_params(nbins=7)\naxins2.tick_params(labelleft=False, labelbottom=False)\n\n# draw a bbox of the region of the inset Axes in the parent Axes and\n# connecting lines between the bbox and the inset Axes area\nmark_inset(ax2, axins2, loc1=2, loc2=4, fc=\"none\", ec=\"0.5\")\n\nplt.show()\n"
    },
    {
      "filename": "make_room_for_ylabel_using_axesgrid.py",
      "title": "Make Room For Ylabel Using Axesgrid",
      "code": "\"\"\"\n====================================\nMake room for ylabel using axes_grid\n====================================\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom mpl_toolkits.axes_grid1.axes_divider import make_axes_area_auto_adjustable\n\nfig = plt.figure()\nax = fig.add_axes([0, 0, 1, 1])\n\nax.set_yticks([0.5], labels=[\"very long label\"])\n\nmake_axes_area_auto_adjustable(ax)\n\n# %%\n\nfig = plt.figure()\nax1 = fig.add_axes([0, 0, 1, 0.5])\nax2 = fig.add_axes([0, 0.5, 1, 0.5])\n\nax1.set_yticks([0.5], labels=[\"very long label\"])\nax1.set_ylabel(\"Y label\")\n\nax2.set_title(\"Title\")\n\nmake_axes_area_auto_adjustable(ax1, pad=0.1, use_axes=[ax1, ax2])\nmake_axes_area_auto_adjustable(ax2, pad=0.1, use_axes=[ax1, ax2])\n\n# %%\n\nfig = plt.figure()\nax1 = fig.add_axes([0, 0, 1, 1])\ndivider = make_axes_locatable(ax1)\n\nax2 = divider.append_axes(\"right\", \"100%\", pad=0.3, sharey=ax1)\nax2.tick_params(labelleft=False)\nfig.add_axes(ax2)\n\ndivider.add_auto_adjustable_area(use_axes=[ax1], pad=0.1,\n                                 adjust_dirs=[\"left\"])\ndivider.add_auto_adjustable_area(use_axes=[ax2], pad=0.1,\n                                 adjust_dirs=[\"right\"])\ndivider.add_auto_adjustable_area(use_axes=[ax1, ax2], pad=0.1,\n                                 adjust_dirs=[\"top\", \"bottom\"])\n\nax1.set_yticks([0.5], labels=[\"very long label\"])\n\nax2.set_title(\"Title\")\nax2.set_xlabel(\"X - Label\")\n\nplt.show()\n"
    },
    {
      "filename": "parasite_simple.py",
      "title": "Parasite Simple",
      "code": "\"\"\"\n===============\nParasite Simple\n===============\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nhost = host_subplot(111)\npar = host.twinx()\n\nhost.set_xlabel(\"Distance\")\nhost.set_ylabel(\"Density\")\npar.set_ylabel(\"Temperature\")\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label=\"Density\")\np2, = par.plot([0, 1, 2], [0, 3, 2], label=\"Temperature\")\n\nhost.legend(labelcolor=\"linecolor\")\n\nhost.yaxis.label.set_color(p1.get_color())\npar.yaxis.label.set_color(p2.get_color())\n\nplt.show()\n"
    },
    {
      "filename": "parasite_simple2.py",
      "title": "Parasite Simple2",
      "code": "\"\"\"\n================\nParasite Simple2\n================\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\nfrom mpl_toolkits.axes_grid1.parasite_axes import HostAxes\n\nobs = [[\"01_S1\", 3.88, 0.14, 1970, 63],\n       [\"01_S4\", 5.6, 0.82, 1622, 150],\n       [\"02_S1\", 2.4, 0.54, 1570, 40],\n       [\"03_S1\", 4.1, 0.62, 2380, 170]]\n\n\nfig = plt.figure()\n\nax_kms = fig.add_subplot(axes_class=HostAxes, aspect=1)\n\n# angular proper motion(\"/yr) to linear velocity(km/s) at distance=2.3kpc\npm_to_kms = 1./206265.*2300*3.085e18/3.15e7/1.e5\n\naux_trans = mtransforms.Affine2D().scale(pm_to_kms, 1.)\nax_pm = ax_kms.twin(aux_trans)\n\nfor n, ds, dse, w, we in obs:\n    time = ((2007 + (10. + 4/30.)/12) - 1988.5)\n    v = ds / time * pm_to_kms\n    ve = dse / time * pm_to_kms\n    ax_kms.errorbar([v], [w], xerr=[ve], yerr=[we], color=\"k\")\n\n\nax_kms.axis[\"bottom\"].set_label(\"Linear velocity at 2.3 kpc [km/s]\")\nax_kms.axis[\"left\"].set_label(\"FWHM [km/s]\")\nax_pm.axis[\"top\"].set_label(r\"Proper Motion [$''$/yr]\")\nax_pm.axis[\"top\"].label.set_visible(True)\nax_pm.axis[\"right\"].major_ticklabels.set_visible(False)\n\nax_kms.set_xlim(950, 3700)\nax_kms.set_ylim(950, 3100)\n# xlim and ylim of ax_pms will be automatically adjusted.\n\nplt.show()\n"
    },
    {
      "filename": "scatter_hist_locatable_axes.py",
      "title": "Scatter Hist Locatable Axes",
      "code": "\"\"\"\n====================================================\nAlign histogram to scatter plot using locatable Axes\n====================================================\n\nShow the marginal distributions of a scatter plot as histograms at the sides of\nthe plot.\n\nFor a nice alignment of the main Axes with the marginals, the Axes positions\nare defined by a ``Divider``, produced via `.make_axes_locatable`.  Note that\nthe ``Divider`` API allows setting Axes sizes and pads in inches, which is its\nmain feature.\n\nIf one wants to set Axes sizes and pads relative to the main Figure, see the\n:doc:`/gallery/lines_bars_and_markers/scatter_hist` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# the random data\nx = np.random.randn(1000)\ny = np.random.randn(1000)\n\n\nfig, ax = plt.subplots(figsize=(5.5, 5.5))\n\n# the scatter plot:\nax.scatter(x, y)\n\n# Set aspect of the main Axes.\nax.set_aspect(1.)\n\n# create new Axes on the right and on the top of the current Axes\ndivider = make_axes_locatable(ax)\n# below height and pad are in inches\nax_histx = divider.append_axes(\"top\", 1.2, pad=0.1, sharex=ax)\nax_histy = divider.append_axes(\"right\", 1.2, pad=0.1, sharey=ax)\n\n# make some labels invisible\nax_histx.xaxis.set_tick_params(labelbottom=False)\nax_histy.yaxis.set_tick_params(labelleft=False)\n\n# now determine nice limits by hand:\nbinwidth = 0.25\nxymax = max(np.max(np.abs(x)), np.max(np.abs(y)))\nlim = (int(xymax/binwidth) + 1)*binwidth\n\nbins = np.arange(-lim, lim + binwidth, binwidth)\nax_histx.hist(x, bins=bins)\nax_histy.hist(y, bins=bins, orientation='horizontal')\n\n# the xaxis of ax_histx and yaxis of ax_histy are shared with ax,\n# thus there is no need to manually adjust the xlim and ylim of these\n# axis.\n\nax_histx.set_yticks([0, 50, 100])\nax_histy.set_xticks([0, 50, 100])\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `mpl_toolkits.axes_grid1.axes_divider.make_axes_locatable`\n#    - `matplotlib.axes.Axes.set_aspect`\n#    - `matplotlib.axes.Axes.scatter`\n#    - `matplotlib.axes.Axes.hist`\n"
    },
    {
      "filename": "simple_anchored_artists.py",
      "title": "Simple Anchored Artists",
      "code": "\"\"\"\n=======================\nSimple Anchored Artists\n=======================\n\nThis example illustrates the use of the anchored helper classes found in\n:mod:`matplotlib.offsetbox` and in :mod:`mpl_toolkits.axes_grid1`.\nAn implementation of a similar figure, but without use of the toolkit,\ncan be found in :doc:`/gallery/misc/anchored_artists`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef draw_text(ax):\n    \"\"\"\n    Draw two text-boxes, anchored by different corners to the upper-left\n    corner of the figure.\n    \"\"\"\n    from matplotlib.offsetbox import AnchoredText\n    at = AnchoredText(\"Figure 1a\",\n                      loc='upper left', prop=dict(size=8), frameon=True,\n                      )\n    at.patch.set_boxstyle(\"round,pad=0.,rounding_size=0.2\")\n    ax.add_artist(at)\n\n    at2 = AnchoredText(\"Figure 1(b)\",\n                       loc='lower left', prop=dict(size=8), frameon=True,\n                       bbox_to_anchor=(0., 1.),\n                       bbox_transform=ax.transAxes\n                       )\n    at2.patch.set_boxstyle(\"round,pad=0.,rounding_size=0.2\")\n    ax.add_artist(at2)\n\n\ndef draw_circle(ax):\n    \"\"\"\n    Draw a circle in axis coordinates\n    \"\"\"\n    from matplotlib.patches import Circle\n    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredDrawingArea\n    ada = AnchoredDrawingArea(20, 20, 0, 0,\n                              loc='upper right', pad=0., frameon=False)\n    p = Circle((10, 10), 10)\n    ada.da.add_artist(p)\n    ax.add_artist(ada)\n\n\ndef draw_sizebar(ax):\n    \"\"\"\n    Draw a horizontal bar with length of 0.1 in data coordinates,\n    with a fixed label underneath.\n    \"\"\"\n    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\n    asb = AnchoredSizeBar(ax.transData,\n                          0.1,\n                          r\"1$^{\\prime}$\",\n                          loc='lower center',\n                          pad=0.1, borderpad=0.5, sep=5,\n                          frameon=False)\n    ax.add_artist(asb)\n\n\nfig, ax = plt.subplots()\nax.set_aspect(1.)\n\ndraw_text(ax)\ndraw_circle(ax)\ndraw_sizebar(ax)\n\nplt.show()\n"
    },
    {
      "filename": "simple_axes_divider1.py",
      "title": "Simple Axes Divider1",
      "code": "\"\"\"\n=====================\nSimple Axes Divider 1\n=====================\n\nSee also :ref:`axes_grid`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider, Size\n\n\ndef label_axes(ax, text):\n    \"\"\"Place a label at the center of an Axes, and remove the axis ticks.\"\"\"\n    ax.text(.5, .5, text, transform=ax.transAxes,\n            horizontalalignment=\"center\", verticalalignment=\"center\")\n    ax.tick_params(bottom=False, labelbottom=False,\n                   left=False, labelleft=False)\n\n\n# %%\n# Fixed Axes sizes; fixed paddings.\n\nfig = plt.figure(figsize=(6, 6))\nfig.suptitle(\"Fixed axes sizes, fixed paddings\")\n\n# Sizes are in inches.\nhoriz = [Size.Fixed(1.), Size.Fixed(.5), Size.Fixed(1.5), Size.Fixed(.5)]\nvert = [Size.Fixed(1.5), Size.Fixed(.5), Size.Fixed(1.)]\n\nrect = (0.1, 0.1, 0.8, 0.8)\n# Divide the Axes rectangle into a grid with sizes specified by horiz * vert.\ndiv = Divider(fig, rect, horiz, vert, aspect=False)\n\n# The rect parameter will actually be ignored and overridden by axes_locator.\nax1 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=0))\nlabel_axes(ax1, \"nx=0, ny=0\")\nax2 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=2))\nlabel_axes(ax2, \"nx=0, ny=2\")\nax3 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, ny=2))\nlabel_axes(ax3, \"nx=2, ny=2\")\nax4 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, nx1=4, ny=0))\nlabel_axes(ax4, \"nx=2, nx1=4, ny=0\")\n\n# %%\n# Axes sizes that scale with the figure size; fixed paddings.\n\nfig = plt.figure(figsize=(6, 6))\nfig.suptitle(\"Scalable axes sizes, fixed paddings\")\n\nhoriz = [Size.Scaled(1.5), Size.Fixed(.5), Size.Scaled(1.), Size.Scaled(.5)]\nvert = [Size.Scaled(1.), Size.Fixed(.5), Size.Scaled(1.5)]\n\nrect = (0.1, 0.1, 0.8, 0.8)\n# Divide the Axes rectangle into a grid with sizes specified by horiz * vert.\ndiv = Divider(fig, rect, horiz, vert, aspect=False)\n\n# The rect parameter will actually be ignored and overridden by axes_locator.\nax1 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=0))\nlabel_axes(ax1, \"nx=0, ny=0\")\nax2 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=2))\nlabel_axes(ax2, \"nx=0, ny=2\")\nax3 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, ny=2))\nlabel_axes(ax3, \"nx=2, ny=2\")\nax4 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, nx1=4, ny=0))\nlabel_axes(ax4, \"nx=2, nx1=4, ny=0\")\n\nplt.show()\n"
    },
    {
      "filename": "simple_axes_divider3.py",
      "title": "Simple Axes Divider3",
      "code": "\"\"\"\n=====================\nSimple axes divider 3\n=====================\n\nSee also :ref:`axes_grid`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider\nimport mpl_toolkits.axes_grid1.axes_size as Size\n\nfig = plt.figure(figsize=(5.5, 4))\n\n# the rect parameter will be ignored as we will set axes_locator\nrect = (0.1, 0.1, 0.8, 0.8)\nax = [fig.add_axes(rect, label=\"%d\" % i) for i in range(4)]\n\n\nhoriz = [Size.AxesX(ax[0]), Size.Fixed(.5), Size.AxesX(ax[1])]\nvert = [Size.AxesY(ax[0]), Size.Fixed(.5), Size.AxesY(ax[2])]\n\n# divide the Axes rectangle into grid whose size is specified by horiz * vert\ndivider = Divider(fig, rect, horiz, vert, aspect=False)\n\n\nax[0].set_axes_locator(divider.new_locator(nx=0, ny=0))\nax[1].set_axes_locator(divider.new_locator(nx=2, ny=0))\nax[2].set_axes_locator(divider.new_locator(nx=0, ny=2))\nax[3].set_axes_locator(divider.new_locator(nx=2, ny=2))\n\nax[0].set_xlim(0, 2)\nax[1].set_xlim(0, 1)\n\nax[0].set_ylim(0, 1)\nax[2].set_ylim(0, 2)\n\ndivider.set_aspect(1.)\n\nfor ax1 in ax:\n    ax1.tick_params(labelbottom=False, labelleft=False)\n\nplt.show()\n"
    },
    {
      "filename": "simple_axesgrid.py",
      "title": "Simple Axesgrid",
      "code": "\"\"\"\n================\nSimple ImageGrid\n================\n\nAlign multiple images using `~mpl_toolkits.axes_grid1.axes_grid.ImageGrid`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nim1 = np.arange(100).reshape((10, 10))\nim2 = im1.T\nim3 = np.flipud(im1)\nim4 = np.fliplr(im2)\n\nfig = plt.figure(figsize=(4., 4.))\ngrid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(2, 2),  # creates 2x2 grid of Axes\n                 axes_pad=0.1,  # pad between Axes in inch.\n                 )\n\nfor ax, im in zip(grid, [im1, im2, im3, im4]):\n    # Iterating over the grid returns the Axes.\n    ax.imshow(im)\n\nplt.show()\n"
    },
    {
      "filename": "simple_axesgrid2.py",
      "title": "Simple Axesgrid2",
      "code": "\"\"\"\n==================\nSimple ImageGrid 2\n==================\n\nAlign multiple images of different sizes using\n`~mpl_toolkits.axes_grid1.axes_grid.ImageGrid`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure(figsize=(5.5, 3.5))\ngrid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(1, 3),\n                 axes_pad=0.1,\n                 label_mode=\"L\",\n                 )\n\n# demo image\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")\nim1 = Z\nim2 = Z[:, :10]\nim3 = Z[:, 10:]\nvmin, vmax = Z.min(), Z.max()\nfor ax, im in zip(grid, [im1, im2, im3]):\n    ax.imshow(im, origin=\"lower\", vmin=vmin, vmax=vmax)\n\nplt.show()\n"
    },
    {
      "filename": "simple_axisline4.py",
      "title": "Simple Axisline4",
      "code": "\"\"\"\n================\nSimple Axisline4\n================\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nax = host_subplot(111)\nxx = np.arange(0, 2*np.pi, 0.01)\nax.plot(xx, np.sin(xx))\n\nax2 = ax.twin()  # ax2 is responsible for \"top\" axis and \"right\" axis\nax2.set_xticks([0., .5*np.pi, np.pi, 1.5*np.pi, 2*np.pi],\n               labels=[\"$0$\", r\"$\\frac{1}{2}\\pi$\",\n                       r\"$\\pi$\", r\"$\\frac{3}{2}\\pi$\", r\"$2\\pi$\"])\n\nax2.axis[\"right\"].major_ticklabels.set_visible(False)\nax2.axis[\"top\"].major_ticklabels.set_visible(True)\n\nplt.show()\n"
    }
  ],
  "axisartist": [
    {
      "filename": "axis_direction.py",
      "title": "Axis Direction",
      "code": "\"\"\"\n==============\nAxis Direction\n==============\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n\n    ax.set_ylim(-0.1, 1.5)\n    ax.set_yticks([0, 1])\n\n    ax.axis[:].set_visible(False)\n\n    ax.axis[\"x\"] = ax.new_floating_axis(1, 0.5)\n    ax.axis[\"x\"].set_axisline_style(\"->\", size=1.5)\n\n    return ax\n\n\nplt.rcParams.update({\n    \"axes.titlesize\": \"medium\",\n    \"axes.titley\": 1.1,\n})\n\nfig = plt.figure(figsize=(10, 4))\nfig.subplots_adjust(bottom=0.1, top=0.9, left=0.05, right=0.95)\n\nax1 = setup_axes(fig, 251)\nax1.axis[\"x\"].set_axis_direction(\"left\")\n\nax2 = setup_axes(fig, 252)\nax2.axis[\"x\"].label.set_text(\"Label\")\nax2.axis[\"x\"].toggle(ticklabels=False)\nax2.axis[\"x\"].set_axislabel_direction(\"+\")\nax2.set_title(\"label direction=$+$\")\n\nax3 = setup_axes(fig, 253)\nax3.axis[\"x\"].label.set_text(\"Label\")\nax3.axis[\"x\"].toggle(ticklabels=False)\nax3.axis[\"x\"].set_axislabel_direction(\"-\")\nax3.set_title(\"label direction=$-$\")\n\nax4 = setup_axes(fig, 254)\nax4.axis[\"x\"].set_ticklabel_direction(\"+\")\nax4.set_title(\"ticklabel direction=$+$\")\n\nax5 = setup_axes(fig, 255)\nax5.axis[\"x\"].set_ticklabel_direction(\"-\")\nax5.set_title(\"ticklabel direction=$-$\")\n\nax7 = setup_axes(fig, 257)\nax7.axis[\"x\"].label.set_text(\"rotation=10\")\nax7.axis[\"x\"].label.set_rotation(10)\nax7.axis[\"x\"].toggle(ticklabels=False)\n\nax8 = setup_axes(fig, 258)\nax8.axis[\"x\"].set_axislabel_direction(\"-\")\nax8.axis[\"x\"].label.set_text(\"rotation=10\")\nax8.axis[\"x\"].label.set_rotation(10)\nax8.axis[\"x\"].toggle(ticklabels=False)\n\nplt.show()\n"
    },
    {
      "filename": "demo_axis_direction.py",
      "title": "Demo Axis Direction",
      "code": "\"\"\"\n===================\naxis_direction demo\n===================\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist as axisartist\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.grid_finder as grid_finder\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\n    GridHelperCurveLinear\n\n\ndef setup_axes(fig, rect):\n    \"\"\"Polar projection, but in a rectangular box.\"\"\"\n    # see demo_curvelinear_grid.py for details\n    grid_helper = GridHelperCurveLinear(\n        (\n            Affine2D().scale(np.pi/180., 1.) +\n            PolarAxes.PolarTransform(apply_theta_transforms=False)\n        ),\n        extreme_finder=angle_helper.ExtremeFinderCycle(\n            20, 20,\n            lon_cycle=360, lat_cycle=None,\n            lon_minmax=None, lat_minmax=(0, np.inf),\n        ),\n        grid_locator1=angle_helper.LocatorDMS(12),\n        grid_locator2=grid_finder.MaxNLocator(5),\n        tick_formatter1=angle_helper.FormatterDMS(),\n    )\n    ax = fig.add_subplot(\n        rect, axes_class=axisartist.Axes, grid_helper=grid_helper,\n        aspect=1, xlim=(-5, 12), ylim=(-5, 10))\n    ax.axis[:].toggle(ticklabels=False)\n    ax.grid(color=\".9\")\n    return ax\n\n\ndef add_floating_axis1(ax):\n    ax.axis[\"lat\"] = axis = ax.new_floating_axis(0, 30)\n    axis.label.set_text(r\"$\\theta = 30^{\\circ}$\")\n    axis.label.set_visible(True)\n    return axis\n\n\ndef add_floating_axis2(ax):\n    ax.axis[\"lon\"] = axis = ax.new_floating_axis(1, 6)\n    axis.label.set_text(r\"$r = 6$\")\n    axis.label.set_visible(True)\n    return axis\n\n\nfig = plt.figure(figsize=(8, 4), layout=\"constrained\")\n\nfor i, d in enumerate([\"bottom\", \"left\", \"top\", \"right\"]):\n    ax = setup_axes(fig, rect=241+i)\n    axis = add_floating_axis1(ax)\n    axis.set_axis_direction(d)\n    ax.set(title=d)\n\nfor i, d in enumerate([\"bottom\", \"left\", \"top\", \"right\"]):\n    ax = setup_axes(fig, rect=245+i)\n    axis = add_floating_axis2(ax)\n    axis.set_axis_direction(d)\n    ax.set(title=d)\n\nplt.show()\n"
    },
    {
      "filename": "demo_axisline_style.py",
      "title": "Demo Axisline Style",
      "code": "\"\"\"\n================\nAxis line styles\n================\n\nThis example shows some configurations for axis style.\n\nNote: The `mpl_toolkits.axisartist` Axes classes may be confusing for new\nusers. If the only aim is to obtain arrow heads at the ends of the axes,\nrather check out the :doc:`/gallery/spines/centered_spines_with_arrows`\nexample.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axisartist.axislines import AxesZero\n\nfig = plt.figure()\nax = fig.add_subplot(axes_class=AxesZero)\n\nfor direction in [\"xzero\", \"yzero\"]:\n    # adds arrows at the ends of each axis\n    ax.axis[direction].set_axisline_style(\"-|>\")\n\n    # adds X and Y-axis from the origin\n    ax.axis[direction].set_visible(True)\n\nfor direction in [\"left\", \"right\", \"bottom\", \"top\"]:\n    # hides borders\n    ax.axis[direction].set_visible(False)\n\nx = np.linspace(-0.5, 1., 100)\nax.plot(x, np.sin(x*np.pi))\n\nplt.show()\n"
    },
    {
      "filename": "demo_curvelinear_grid.py",
      "title": "Demo Curvelinear Grid",
      "code": "\"\"\"\n=====================\nCurvilinear grid demo\n=====================\n\nCustom grid and ticklines.\n\nThis example demonstrates how to use\n`~.grid_helper_curvelinear.GridHelperCurveLinear` to define custom grids and\nticklines by applying a transformation on the grid.  This can be used, as\nshown on the second plot, to create polar projections in a rectangular box.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nfrom mpl_toolkits.axisartist import Axes, HostAxes, angle_helper\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\n    GridHelperCurveLinear\n\n\ndef curvelinear_test1(fig):\n    \"\"\"\n    Grid for custom transform.\n    \"\"\"\n\n    def tr(x, y): return x, y - x\n    def inv_tr(x, y): return x, y + x\n\n    grid_helper = GridHelperCurveLinear((tr, inv_tr))\n\n    ax1 = fig.add_subplot(1, 2, 1, axes_class=Axes, grid_helper=grid_helper)\n    # ax1 will have ticks and gridlines defined by the given transform (+\n    # transData of the Axes).  Note that the transform of the Axes itself\n    # (i.e., transData) is not affected by the given transform.\n    xx, yy = tr(np.array([3, 6]), np.array([5, 10]))\n    ax1.plot(xx, yy)\n\n    ax1.set_aspect(1)\n    ax1.set_xlim(0, 10)\n    ax1.set_ylim(0, 10)\n\n    ax1.axis[\"t\"] = ax1.new_floating_axis(0, 3)\n    ax1.axis[\"t2\"] = ax1.new_floating_axis(1, 7)\n    ax1.grid(True, zorder=0)\n\n\ndef curvelinear_test2(fig):\n    \"\"\"\n    Polar projection, but in a rectangular box.\n    \"\"\"\n\n    # PolarAxes.PolarTransform takes radian. However, we want our coordinate\n    # system in degree\n    tr = Affine2D().scale(np.pi/180, 1) + PolarAxes.PolarTransform(\n        apply_theta_transforms=False)\n    # Polar projection, which involves cycle, and also has limits in\n    # its coordinates, needs a special method to find the extremes\n    # (min, max of the coordinate within the view).\n    extreme_finder = angle_helper.ExtremeFinderCycle(\n        nx=20, ny=20,  # Number of sampling points in each direction.\n        lon_cycle=360, lat_cycle=None,\n        lon_minmax=None, lat_minmax=(0, np.inf),\n    )\n    # Find grid values appropriate for the coordinate (degree, minute, second).\n    grid_locator1 = angle_helper.LocatorDMS(12)\n    # Use an appropriate formatter.  Note that the acceptable Locator and\n    # Formatter classes are a bit different than that of Matplotlib, which\n    # cannot directly be used here (this may be possible in the future).\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(\n        tr, extreme_finder=extreme_finder,\n        grid_locator1=grid_locator1, tick_formatter1=tick_formatter1)\n    ax1 = fig.add_subplot(\n        1, 2, 2, axes_class=HostAxes, grid_helper=grid_helper)\n\n    # make ticklabels of right and top axis visible.\n    ax1.axis[\"right\"].major_ticklabels.set_visible(True)\n    ax1.axis[\"top\"].major_ticklabels.set_visible(True)\n    # let right axis shows ticklabels for 1st coordinate (angle)\n    ax1.axis[\"right\"].get_helper().nth_coord_ticks = 0\n    # let bottom axis shows ticklabels for 2nd coordinate (radius)\n    ax1.axis[\"bottom\"].get_helper().nth_coord_ticks = 1\n\n    ax1.set_aspect(1)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    ax1.grid(True, zorder=0)\n\n    # A parasite Axes with given transform\n    ax2 = ax1.get_aux_axes(tr)\n    # note that ax2.transData == tr + ax1.transData\n    # Anything you draw in ax2 will match the ticks and grids of ax1.\n    ax2.plot(np.linspace(0, 30, 51), np.linspace(10, 10, 51), linewidth=2)\n\n    ax2.pcolor(np.linspace(0, 90, 4), np.linspace(0, 10, 4),\n               np.arange(9).reshape((3, 3)))\n    ax2.contour(np.linspace(0, 90, 4), np.linspace(0, 10, 4),\n                np.arange(16).reshape((4, 4)), colors=\"k\")\n\n\nif __name__ == \"__main__\":\n    fig = plt.figure(figsize=(7, 4))\n\n    curvelinear_test1(fig)\n    curvelinear_test2(fig)\n\n    plt.show()\n"
    },
    {
      "filename": "demo_curvelinear_grid2.py",
      "title": "Demo Curvelinear Grid2",
      "code": "\"\"\"\n======================\nDemo CurveLinear Grid2\n======================\n\nCustom grid and ticklines.\n\nThis example demonstrates how to use GridHelperCurveLinear to define\ncustom grids and ticklines by applying a transformation on the grid.\nAs showcase on the plot, a 5x5 matrix is displayed on the Axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axisartist.axislines import Axes\nfrom mpl_toolkits.axisartist.grid_finder import (ExtremeFinderSimple,\n                                                 MaxNLocator)\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\n    GridHelperCurveLinear\n\n\ndef curvelinear_test1(fig):\n    \"\"\"Grid for custom transform.\"\"\"\n\n    def tr(x, y):\n        return np.sign(x)*abs(x)**.5, y\n\n    def inv_tr(x, y):\n        return np.sign(x)*x**2, y\n\n    grid_helper = GridHelperCurveLinear(\n        (tr, inv_tr),\n        extreme_finder=ExtremeFinderSimple(20, 20),\n        # better tick density\n        grid_locator1=MaxNLocator(nbins=6), grid_locator2=MaxNLocator(nbins=6))\n\n    ax1 = fig.add_subplot(axes_class=Axes, grid_helper=grid_helper)\n    # ax1 will have a ticks and gridlines defined by the given\n    # transform (+ transData of the Axes). Note that the transform of the Axes\n    # itself (i.e., transData) is not affected by the given transform.\n\n    ax1.imshow(np.arange(25).reshape(5, 5),\n               vmax=50, cmap=plt.cm.gray_r, origin=\"lower\")\n\n\nif __name__ == \"__main__\":\n    fig = plt.figure(figsize=(7, 4))\n    curvelinear_test1(fig)\n    plt.show()\n"
    },
    {
      "filename": "demo_floating_axes.py",
      "title": "Demo Floating Axes",
      "code": "\"\"\"\n==========================\n``floating_axes`` features\n==========================\n\nDemonstration of features of the :mod:`.floating_axes` module:\n\n* Using `~.axes.Axes.scatter` and `~.axes.Axes.bar` with changing the shape of\n  the plot.\n* Using `~.floating_axes.GridHelperCurveLinear` to rotate the plot and set the\n  plot boundary.\n* Using `~.Figure.add_subplot` to create a subplot using the return value from\n  `~.floating_axes.GridHelperCurveLinear`.\n* Making a sector plot by adding more features to\n  `~.floating_axes.GridHelperCurveLinear`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.floating_axes as floating_axes\nfrom mpl_toolkits.axisartist.grid_finder import (DictFormatter, FixedLocator,\n                                                 MaxNLocator)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef setup_axes1(fig, rect):\n    \"\"\"\n    A simple one.\n    \"\"\"\n    tr = Affine2D().scale(2, 1).rotate_deg(30)\n\n    grid_helper = floating_axes.GridHelperCurveLinear(\n        tr, extremes=(-0.5, 3.5, 0, 4),\n        grid_locator1=MaxNLocator(nbins=4),\n        grid_locator2=MaxNLocator(nbins=4))\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)\n    ax1.grid()\n\n    aux_ax = ax1.get_aux_axes(tr)\n\n    return ax1, aux_ax\n\n\ndef setup_axes2(fig, rect):\n    \"\"\"\n    With custom locator and formatter.\n    Note that the extreme values are swapped.\n    \"\"\"\n    tr = PolarAxes.PolarTransform(apply_theta_transforms=False)\n\n    pi = np.pi\n    angle_ticks = [(0, r\"$0$\"),\n                   (.25*pi, r\"$\\frac{1}{4}\\pi$\"),\n                   (.5*pi, r\"$\\frac{1}{2}\\pi$\")]\n    grid_locator1 = FixedLocator([v for v, s in angle_ticks])\n    tick_formatter1 = DictFormatter(dict(angle_ticks))\n\n    grid_locator2 = MaxNLocator(2)\n\n    grid_helper = floating_axes.GridHelperCurveLinear(\n        tr, extremes=(.5*pi, 0, 2, 1),\n        grid_locator1=grid_locator1,\n        grid_locator2=grid_locator2,\n        tick_formatter1=tick_formatter1,\n        tick_formatter2=None)\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)\n    ax1.grid()\n\n    # create a parasite Axes whose transData in RA, cz\n    aux_ax = ax1.get_aux_axes(tr)\n\n    aux_ax.patch = ax1.patch  # for aux_ax to have a clip path as in ax\n    ax1.patch.zorder = 0.9  # but this has a side effect that the patch is\n    # drawn twice, and possibly over some other\n    # artists. So, we decrease the zorder a bit to\n    # prevent this.\n\n    return ax1, aux_ax\n\n\ndef setup_axes3(fig, rect):\n    \"\"\"\n    Sometimes, things like axis_direction need to be adjusted.\n    \"\"\"\n\n    # rotate a bit for better orientation\n    tr_rotate = Affine2D().translate(-95, 0)\n\n    # scale degree to radians\n    tr_scale = Affine2D().scale(np.pi/180., 1.)\n\n    tr = tr_rotate + tr_scale + PolarAxes.PolarTransform(\n        apply_theta_transforms=False)\n\n    grid_locator1 = angle_helper.LocatorHMS(4)\n    tick_formatter1 = angle_helper.FormatterHMS()\n\n    grid_locator2 = MaxNLocator(3)\n\n    # Specify theta limits in degrees\n    ra0, ra1 = 8.*15, 14.*15\n    # Specify radial limits\n    cz0, cz1 = 0, 14000\n    grid_helper = floating_axes.GridHelperCurveLinear(\n        tr, extremes=(ra0, ra1, cz0, cz1),\n        grid_locator1=grid_locator1,\n        grid_locator2=grid_locator2,\n        tick_formatter1=tick_formatter1,\n        tick_formatter2=None)\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)\n\n    # adjust axis\n    ax1.axis[\"left\"].set_axis_direction(\"bottom\")\n    ax1.axis[\"right\"].set_axis_direction(\"top\")\n\n    ax1.axis[\"bottom\"].set_visible(False)\n    ax1.axis[\"top\"].set_axis_direction(\"bottom\")\n    ax1.axis[\"top\"].toggle(ticklabels=True, label=True)\n    ax1.axis[\"top\"].major_ticklabels.set_axis_direction(\"top\")\n    ax1.axis[\"top\"].label.set_axis_direction(\"top\")\n\n    ax1.axis[\"left\"].label.set_text(r\"cz [km$^{-1}$]\")\n    ax1.axis[\"top\"].label.set_text(r\"$\\alpha_{1950}$\")\n    ax1.grid()\n\n    # create a parasite Axes whose transData in RA, cz\n    aux_ax = ax1.get_aux_axes(tr)\n\n    aux_ax.patch = ax1.patch  # for aux_ax to have a clip path as in ax\n    ax1.patch.zorder = 0.9  # but this has a side effect that the patch is\n    # drawn twice, and possibly over some other\n    # artists. So, we decrease the zorder a bit to\n    # prevent this.\n\n    return ax1, aux_ax\n\n\n# %%\nfig = plt.figure(figsize=(8, 4))\nfig.subplots_adjust(wspace=0.3, left=0.05, right=0.95)\n\nax1, aux_ax1 = setup_axes1(fig, 131)\naux_ax1.bar([0, 1, 2, 3], [3, 2, 1, 3])\n\nax2, aux_ax2 = setup_axes2(fig, 132)\ntheta = np.random.rand(10)*.5*np.pi\nradius = np.random.rand(10) + 1.\naux_ax2.scatter(theta, radius)\n\nax3, aux_ax3 = setup_axes3(fig, 133)\n\ntheta = (8 + np.random.rand(10)*(14 - 8))*15.  # in degrees\nradius = np.random.rand(10)*14000.\naux_ax3.scatter(theta, radius)\n\nplt.show()\n"
    },
    {
      "filename": "demo_floating_axis.py",
      "title": "Demo Floating Axis",
      "code": "\"\"\"\n==================\nfloating_axis demo\n==================\n\nAxis within rectangular frame.\n\nThe following code demonstrates how to put a floating polar curve within a\nrectangular box. In order to get a better sense of polar curves, please look at\n:doc:`/gallery/axisartist/demo_curvelinear_grid`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nfrom mpl_toolkits.axisartist import GridHelperCurveLinear, HostAxes\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\n\n\ndef curvelinear_test2(fig):\n    \"\"\"Polar projection, but in a rectangular box.\"\"\"\n    # see demo_curvelinear_grid.py for details\n    tr = Affine2D().scale(np.pi / 180., 1.) + PolarAxes.PolarTransform(\n        apply_theta_transforms=False)\n\n    extreme_finder = angle_helper.ExtremeFinderCycle(20,\n                                                     20,\n                                                     lon_cycle=360,\n                                                     lat_cycle=None,\n                                                     lon_minmax=None,\n                                                     lat_minmax=(0, np.inf),\n                                                     )\n\n    grid_locator1 = angle_helper.LocatorDMS(12)\n\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(tr,\n                                        extreme_finder=extreme_finder,\n                                        grid_locator1=grid_locator1,\n                                        tick_formatter1=tick_formatter1\n                                        )\n\n    ax1 = fig.add_subplot(axes_class=HostAxes, grid_helper=grid_helper)\n\n    # Now creates floating axis\n\n    # floating axis whose first coordinate (theta) is fixed at 60\n    ax1.axis[\"lat\"] = axis = ax1.new_floating_axis(0, 60)\n    axis.label.set_text(r\"$\\theta = 60^{\\circ}$\")\n    axis.label.set_visible(True)\n\n    # floating axis whose second coordinate (r) is fixed at 6\n    ax1.axis[\"lon\"] = axis = ax1.new_floating_axis(1, 6)\n    axis.label.set_text(r\"$r = 6$\")\n\n    ax1.set_aspect(1.)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    ax1.grid(True)\n\n\nfig = plt.figure(figsize=(5, 5))\ncurvelinear_test2(fig)\nplt.show()\n"
    },
    {
      "filename": "demo_parasite_axes.py",
      "title": "Demo Parasite Axes",
      "code": "\"\"\"\n==================\nParasite Axes demo\n==================\n\nCreate a parasite Axes. Such Axes would share the x scale with a host Axes,\nbut show a different scale in y direction.\n\nThis approach uses `mpl_toolkits.axes_grid1.parasite_axes.HostAxes` and\n`mpl_toolkits.axes_grid1.parasite_axes.ParasiteAxes`.\n\nThe standard and recommended approach is to use instead standard Matplotlib\naxes, as shown in the :doc:`/gallery/spines/multiple_yaxis_with_spines`\nexample.\n\nAn alternative approach using `mpl_toolkits.axes_grid1` and\n`mpl_toolkits.axisartist` is shown in the\n:doc:`/gallery/axisartist/demo_parasite_axes2` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.parasite_axes import HostAxes\n\nfig = plt.figure()\n\nhost = fig.add_axes([0.15, 0.1, 0.65, 0.8], axes_class=HostAxes)\npar1 = host.get_aux_axes(viewlim_mode=None, sharex=host)\npar2 = host.get_aux_axes(viewlim_mode=None, sharex=host)\n\nhost.axis[\"right\"].set_visible(False)\n\npar1.axis[\"right\"].set_visible(True)\npar1.axis[\"right\"].major_ticklabels.set_visible(True)\npar1.axis[\"right\"].label.set_visible(True)\n\npar2.axis[\"right2\"] = par2.new_fixed_axis(loc=\"right\", offset=(60, 0))\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label=\"Density\")\np2, = par1.plot([0, 1, 2], [0, 3, 2], label=\"Temperature\")\np3, = par2.plot([0, 1, 2], [50, 30, 15], label=\"Velocity\")\n\nhost.set(xlim=(0, 2), ylim=(0, 2), xlabel=\"Distance\", ylabel=\"Density\")\npar1.set(ylim=(0, 4), ylabel=\"Temperature\")\npar2.set(ylim=(1, 65), ylabel=\"Velocity\")\n\nhost.legend()\n\nhost.axis[\"left\"].label.set_color(p1.get_color())\npar1.axis[\"right\"].label.set_color(p2.get_color())\npar2.axis[\"right2\"].label.set_color(p3.get_color())\n\nplt.show()\n"
    },
    {
      "filename": "demo_parasite_axes2.py",
      "title": "Demo Parasite Axes2",
      "code": "\"\"\"\n==================\nParasite axis demo\n==================\n\nThis example demonstrates the use of parasite axis to plot multiple datasets\nonto one single plot.\n\nNotice how in this example, *par1* and *par2* are both obtained by calling\n``twinx()``, which ties their x-limits with the host's x-axis. From there, each\nof those two axis behave separately from each other: different datasets can be\nplotted, and the y-limits are adjusted separately.\n\nThis approach uses `mpl_toolkits.axes_grid1.parasite_axes.host_subplot` and\n`mpl_toolkits.axisartist.axislines.Axes`.\n\nThe standard and recommended approach is to use instead standard Matplotlib\naxes, as shown in the :doc:`/gallery/spines/multiple_yaxis_with_spines`\nexample.\n\nAn alternative approach using `mpl_toolkits.axes_grid1.parasite_axes.HostAxes`\nand `mpl_toolkits.axes_grid1.parasite_axes.ParasiteAxes` is shown in the\n:doc:`/gallery/axisartist/demo_parasite_axes` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits import axisartist\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nhost = host_subplot(111, axes_class=axisartist.Axes)\nplt.subplots_adjust(right=0.75)\n\npar1 = host.twinx()\npar2 = host.twinx()\n\npar2.axis[\"right\"] = par2.new_fixed_axis(loc=\"right\", offset=(60, 0))\n\npar1.axis[\"right\"].toggle(all=True)\npar2.axis[\"right\"].toggle(all=True)\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label=\"Density\")\np2, = par1.plot([0, 1, 2], [0, 3, 2], label=\"Temperature\")\np3, = par2.plot([0, 1, 2], [50, 30, 15], label=\"Velocity\")\n\nhost.set(xlim=(0, 2), ylim=(0, 2), xlabel=\"Distance\", ylabel=\"Density\")\npar1.set(ylim=(0, 4), ylabel=\"Temperature\")\npar2.set(ylim=(1, 65), ylabel=\"Velocity\")\n\nhost.legend()\n\nhost.axis[\"left\"].label.set_color(p1.get_color())\npar1.axis[\"right\"].label.set_color(p2.get_color())\npar2.axis[\"right\"].label.set_color(p3.get_color())\n\nplt.show()\n"
    },
    {
      "filename": "demo_ticklabel_alignment.py",
      "title": "Demo Ticklabel Alignment",
      "code": "\"\"\"\n===================\nTicklabel alignment\n===================\n\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n    ax.set_yticks([0.2, 0.8], labels=[\"short\", \"loooong\"])\n    ax.set_xticks([0.2, 0.8], labels=[r\"$\\frac{1}{2}\\pi$\", r\"$\\pi$\"])\n    return ax\n\n\nfig = plt.figure(figsize=(3, 5))\nfig.subplots_adjust(left=0.5, hspace=0.7)\n\nax = setup_axes(fig, 311)\nax.set_ylabel(\"ha=right\")\nax.set_xlabel(\"va=baseline\")\n\nax = setup_axes(fig, 312)\nax.axis[\"left\"].major_ticklabels.set_ha(\"center\")\nax.axis[\"bottom\"].major_ticklabels.set_va(\"top\")\nax.set_ylabel(\"ha=center\")\nax.set_xlabel(\"va=top\")\n\nax = setup_axes(fig, 313)\nax.axis[\"left\"].major_ticklabels.set_ha(\"left\")\nax.axis[\"bottom\"].major_ticklabels.set_va(\"bottom\")\nax.set_ylabel(\"ha=left\")\nax.set_xlabel(\"va=bottom\")\n\nplt.show()\n"
    },
    {
      "filename": "demo_ticklabel_direction.py",
      "title": "Demo Ticklabel Direction",
      "code": "\"\"\"\n===================\nTicklabel direction\n===================\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist.axislines as axislines\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axislines.Axes)\n    ax.set_yticks([0.2, 0.8])\n    ax.set_xticks([0.2, 0.8])\n    return ax\n\n\nfig = plt.figure(figsize=(6, 3))\nfig.subplots_adjust(bottom=0.2)\n\nax = setup_axes(fig, 131)\nfor axis in ax.axis.values():\n    axis.major_ticks.set_tick_out(True)\n# or you can simply do \"ax.axis[:].major_ticks.set_tick_out(True)\"\n\nax = setup_axes(fig, 132)\nax.axis[\"left\"].set_axis_direction(\"right\")\nax.axis[\"bottom\"].set_axis_direction(\"top\")\nax.axis[\"right\"].set_axis_direction(\"left\")\nax.axis[\"top\"].set_axis_direction(\"bottom\")\n\nax = setup_axes(fig, 133)\nax.axis[\"left\"].set_axis_direction(\"right\")\nax.axis[:].major_ticks.set_tick_out(True)\n\nax.axis[\"left\"].label.set_text(\"Long Label Left\")\nax.axis[\"bottom\"].label.set_text(\"Label Bottom\")\nax.axis[\"right\"].label.set_text(\"Long Label Right\")\nax.axis[\"right\"].label.set_visible(True)\nax.axis[\"left\"].label.set_pad(0)\nax.axis[\"bottom\"].label.set_pad(10)\n\nplt.show()\n"
    },
    {
      "filename": "simple_axis_direction01.py",
      "title": "Simple Axis Direction01",
      "code": "\"\"\"\n=====================\nSimple axis direction\n=====================\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\nfig = plt.figure(figsize=(4, 2.5))\nax1 = fig.add_subplot(axes_class=axisartist.Axes)\nfig.subplots_adjust(right=0.8)\n\nax1.axis[\"left\"].major_ticklabels.set_axis_direction(\"top\")\nax1.axis[\"left\"].label.set_text(\"Left label\")\n\nax1.axis[\"right\"].label.set_visible(True)\nax1.axis[\"right\"].label.set_text(\"Right label\")\nax1.axis[\"right\"].label.set_axis_direction(\"left\")\n\nplt.show()\n"
    },
    {
      "filename": "simple_axis_direction03.py",
      "title": "Simple Axis Direction03",
      "code": "\"\"\"\n==========================================\nSimple axis tick label and tick directions\n==========================================\n\nFirst subplot moves the tick labels to inside the spines.\nSecond subplot moves the ticks to inside the spines.\nThese effects can be obtained for a standard Axes by `~.Axes.tick_params`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n    ax.set_yticks([0.2, 0.8])\n    ax.set_xticks([0.2, 0.8])\n    return ax\n\n\nfig = plt.figure(figsize=(5, 2))\nfig.subplots_adjust(wspace=0.4, bottom=0.3)\n\nax1 = setup_axes(fig, 121)\nax1.set_xlabel(\"ax1 X-label\")\nax1.set_ylabel(\"ax1 Y-label\")\n\nax1.axis[:].invert_ticklabel_direction()\n\nax2 = setup_axes(fig, 122)\nax2.set_xlabel(\"ax2 X-label\")\nax2.set_ylabel(\"ax2 Y-label\")\n\nax2.axis[:].major_ticks.set_tick_out(False)\n\nplt.show()\n"
    },
    {
      "filename": "simple_axis_pad.py",
      "title": "Simple Axis Pad",
      "code": "\"\"\"\n===============\nSimple axis pad\n===============\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist as axisartist\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.grid_finder as grid_finder\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\n    GridHelperCurveLinear\n\n\ndef setup_axes(fig, rect):\n    \"\"\"Polar projection, but in a rectangular box.\"\"\"\n\n    # see demo_curvelinear_grid.py for details\n    tr = Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform(\n        apply_theta_transforms=False)\n\n    extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,\n                                                     lon_cycle=360,\n                                                     lat_cycle=None,\n                                                     lon_minmax=None,\n                                                     lat_minmax=(0, np.inf),\n                                                     )\n\n    grid_locator1 = angle_helper.LocatorDMS(12)\n    grid_locator2 = grid_finder.MaxNLocator(5)\n\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(tr,\n                                        extreme_finder=extreme_finder,\n                                        grid_locator1=grid_locator1,\n                                        grid_locator2=grid_locator2,\n                                        tick_formatter1=tick_formatter1\n                                        )\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=axisartist.Axes, grid_helper=grid_helper)\n    ax1.axis[:].set_visible(False)\n    ax1.set_aspect(1.)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    return ax1\n\n\ndef add_floating_axis1(ax1):\n    ax1.axis[\"lat\"] = axis = ax1.new_floating_axis(0, 30)\n    axis.label.set_text(r\"$\\theta = 30^{\\circ}$\")\n    axis.label.set_visible(True)\n\n    return axis\n\n\ndef add_floating_axis2(ax1):\n    ax1.axis[\"lon\"] = axis = ax1.new_floating_axis(1, 6)\n    axis.label.set_text(r\"$r = 6$\")\n    axis.label.set_visible(True)\n\n    return axis\n\n\nfig = plt.figure(figsize=(9, 3.))\nfig.subplots_adjust(left=0.01, right=0.99, bottom=0.01, top=0.99,\n                    wspace=0.01, hspace=0.01)\n\n\ndef ann(ax1, d):\n    if plt.rcParams[\"text.usetex\"]:\n        d = d.replace(\"_\", r\"\\_\")\n\n    ax1.annotate(d, (0.5, 1), (5, -5),\n                 xycoords=\"axes fraction\", textcoords=\"offset points\",\n                 va=\"top\", ha=\"center\")\n\n\nax1 = setup_axes(fig, rect=141)\naxis = add_floating_axis1(ax1)\nann(ax1, r\"default\")\n\nax1 = setup_axes(fig, rect=142)\naxis = add_floating_axis1(ax1)\naxis.major_ticklabels.set_pad(10)\nann(ax1, r\"ticklabels.set_pad(10)\")\n\nax1 = setup_axes(fig, rect=143)\naxis = add_floating_axis1(ax1)\naxis.label.set_pad(20)\nann(ax1, r\"label.set_pad(20)\")\n\nax1 = setup_axes(fig, rect=144)\naxis = add_floating_axis1(ax1)\naxis.major_ticks.set_tick_out(True)\nann(ax1, \"ticks.set_tick_out(True)\")\n\nplt.show()\n"
    },
    {
      "filename": "simple_axisartist1.py",
      "title": "Simple Axisartist1",
      "code": "\"\"\"\n=============================\nCustom spines with axisartist\n=============================\n\nThis example showcases the use of :mod:`.axisartist` to draw spines at custom\npositions (here, at ``y = 0``).\n\nNote, however, that it is simpler to achieve this effect using standard\n`.Spine` methods, as demonstrated in\n:doc:`/gallery/spines/centered_spines_with_arrows`.\n\n.. redirect-from:: /gallery/axisartist/simple_axisline2\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits import axisartist\n\nfig = plt.figure(figsize=(6, 3), layout=\"constrained\")\n# To construct Axes of two different classes, we need to use gridspec (or\n# MATLAB-style add_subplot calls).\ngs = fig.add_gridspec(1, 2)\n\n\nax0 = fig.add_subplot(gs[0, 0], axes_class=axisartist.Axes)\n# Make a new axis along the first (x) axis which passes through y=0.\nax0.axis[\"y=0\"] = ax0.new_floating_axis(nth_coord=0, value=0,\n                                        axis_direction=\"bottom\")\nax0.axis[\"y=0\"].toggle(all=True)\nax0.axis[\"y=0\"].label.set_text(\"y = 0\")\n# Make other axis invisible.\nax0.axis[\"bottom\", \"top\", \"right\"].set_visible(False)\n\n\n# Alternatively, one can use AxesZero, which automatically sets up two\n# additional axis, named \"xzero\" (the y=0 axis) and \"yzero\" (the x=0 axis).\nax1 = fig.add_subplot(gs[0, 1], axes_class=axisartist.axislines.AxesZero)\n# \"xzero\" and \"yzero\" default to invisible; make xzero axis visible.\nax1.axis[\"xzero\"].set_visible(True)\nax1.axis[\"xzero\"].label.set_text(\"Axis Zero\")\n# Make other axis invisible.\nax1.axis[\"bottom\", \"top\", \"right\"].set_visible(False)\n\n\n# Draw some sample data.\nx = np.arange(0, 2*np.pi, 0.01)\nax0.plot(x, np.sin(x))\nax1.plot(x, np.sin(x))\n\nplt.show()\n"
    },
    {
      "filename": "simple_axisline.py",
      "title": "Simple Axisline",
      "code": "\"\"\"\n===============\nSimple Axisline\n===============\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.axislines import AxesZero\n\nfig = plt.figure()\nfig.subplots_adjust(right=0.85)\nax = fig.add_subplot(axes_class=AxesZero)\n\n# make right and top axis invisible\nax.axis[\"right\"].set_visible(False)\nax.axis[\"top\"].set_visible(False)\n\n# make xzero axis (horizontal axis line through y=0) visible.\nax.axis[\"xzero\"].set_visible(True)\nax.axis[\"xzero\"].label.set_text(\"Axis Zero\")\n\nax.set_ylim(-2, 4)\nax.set_xlabel(\"Label X\")\nax.set_ylabel(\"Label Y\")\n# Or:\n# ax.axis[\"bottom\"].label.set_text(\"Label X\")\n# ax.axis[\"left\"].label.set_text(\"Label Y\")\n\n# make new (right-side) yaxis, but with some offset\nax.axis[\"right2\"] = ax.new_fixed_axis(loc=\"right\", offset=(20, 0))\nax.axis[\"right2\"].label.set_text(\"Label Y2\")\n\nax.plot([-2, 3, 2])\nplt.show()\n"
    },
    {
      "filename": "simple_axisline3.py",
      "title": "Simple Axisline3",
      "code": "\"\"\"\n================\nSimple Axisline3\n================\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.axislines import Axes\n\nfig = plt.figure(figsize=(3, 3))\n\nax = fig.add_subplot(axes_class=Axes)\n\nax.axis[\"right\"].set_visible(False)\nax.axis[\"top\"].set_visible(False)\n\nplt.show()\n"
    }
  ],
  "color": [
    {
      "filename": "color_by_yvalue.py",
      "title": "Color By Yvalue",
      "code": "\"\"\"\n================\nColor by y-value\n================\n\nUse masked arrays to plot a line with different colors by y-value.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\n\nupper = 0.77\nlower = -0.77\n\nsupper = np.ma.masked_where(s < upper, s)\nslower = np.ma.masked_where(s > lower, s)\nsmiddle = np.ma.masked_where((s < lower) | (s > upper), s)\n\nfig, ax = plt.subplots()\nax.plot(t, smiddle, t, slower, t, supper)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#\n# .. tags::\n#\n#    styling: color\n#    styling: conditional\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "color_cycle_default.py",
      "title": "Color Cycle Default",
      "code": "\"\"\"\n====================================\nColors in the default property cycle\n====================================\n\nDisplay the colors from the default prop_cycle, which is obtained from the\n:ref:`rc parameters<customizing>`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import TABLEAU_COLORS, same_color\n\n\ndef f(x, a):\n    \"\"\"A nice sigmoid-like parametrized curve, ending approximately at *a*.\"\"\"\n    return 0.85 * a * (1 / (1 + np.exp(-x)) + 0.2)\n\n\nfig, ax = plt.subplots()\nax.axis('off')\nax.set_title(\"Colors in the default property cycle\")\n\nprop_cycle = plt.rcParams['axes.prop_cycle']\ncolors = prop_cycle.by_key()['color']\nx = np.linspace(-4, 4, 200)\n\nfor i, (color, color_name) in enumerate(zip(colors, TABLEAU_COLORS)):\n    assert same_color(color, color_name)\n    pos = 4.5 - i\n    ax.plot(x, f(x, pos))\n    ax.text(4.2, pos, f\"'C{i}': '{color_name}'\", color=color, va=\"center\")\n    ax.bar(9, 1, width=1.5, bottom=pos-0.5)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.axis`\n#    - `matplotlib.axes.Axes.text`\n#    - `matplotlib.colors.same_color`\n#    - `cycler.Cycler`\n#\n# .. tags::\n#\n#    styling: color\n#    purpose: reference\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "color_demo.py",
      "title": "Color Demo",
      "code": "\"\"\"\n==========\nColor Demo\n==========\n\nMatplotlib recognizes the following formats to specify a color:\n\n1) an RGB or RGBA tuple of float values in ``[0, 1]`` (e.g. ``(0.1, 0.2, 0.5)``\n   or ``(0.1, 0.2, 0.5, 0.3)``).  RGBA is short for Red, Green, Blue, Alpha;\n2) a hex RGB or RGBA string (e.g., ``'#0F0F0F'`` or ``'#0F0F0F0F'``);\n3) a shorthand hex RGB or RGBA string, equivalent to the hex RGB or RGBA\n   string obtained by duplicating each character, (e.g., ``'#abc'``, equivalent\n   to ``'#aabbcc'``, or ``'#abcd'``, equivalent to ``'#aabbccdd'``);\n4) a string representation of a float value in ``[0, 1]`` inclusive for gray\n   level (e.g., ``'0.5'``);\n5) a single letter string, i.e. one of\n   ``{'b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'}``, which are short-hand notations\n   for shades of blue, green, red, cyan, magenta, yellow, black, and white;\n6) a X11/CSS4 (\"html\") color name, e.g. ``\"blue\"``;\n7) a name from the `xkcd color survey <https://xkcd.com/color/rgb/>`__,\n   prefixed with ``'xkcd:'`` (e.g., ``'xkcd:sky blue'``);\n8) a \"Cn\" color spec, i.e. ``'C'`` followed by a number, which is an index into\n   the default property cycle (:rc:`axes.prop_cycle`); the indexing is intended\n   to occur at rendering time, and defaults to black if the cycle does not\n   include color.\n9) one of ``{'tab:blue', 'tab:orange', 'tab:green', 'tab:red', 'tab:purple',\n   'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan'}`` which are\n   the Tableau Colors from the 'tab10' categorical palette (which is the\n   default color cycle);\n\nFor more information on colors in matplotlib see\n\n* the :ref:`colors_def` tutorial;\n* the `matplotlib.colors` API;\n* the :doc:`/gallery/color/named_colors` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0.0, 2.0, 201)\ns = np.sin(2 * np.pi * t)\n\n# 1) RGB tuple:\nfig, ax = plt.subplots(facecolor=(.18, .31, .31))\n# 2) hex string:\nax.set_facecolor('#eafff5')\n# 3) gray level string:\nax.set_title('Voltage vs. time chart', color='0.7')\n# 4) single letter color string\nax.set_xlabel('Time [s]', color='c')\n# 5) a named color:\nax.set_ylabel('Voltage [mV]', color='peachpuff')\n# 6) a named xkcd color:\nax.plot(t, s, 'xkcd:crimson')\n# 7) Cn notation:\nax.plot(t, .7*s, color='C4', linestyle='--')\n# 8) tab notation:\nax.tick_params(labelcolor='tab:orange')\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors`\n#    - `matplotlib.axes.Axes.plot`\n#    - `matplotlib.axes.Axes.set_facecolor`\n#    - `matplotlib.axes.Axes.set_title`\n#    - `matplotlib.axes.Axes.set_xlabel`\n#    - `matplotlib.axes.Axes.set_ylabel`\n#    - `matplotlib.axes.Axes.tick_params`\n#\n# .. tags::\n#\n#    styling: color\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "color_sequences.py",
      "title": "Color Sequences",
      "code": "\"\"\"\n=====================\nNamed color sequences\n=====================\n\nMatplotlib's `~matplotlib.colors.ColorSequenceRegistry` allows access to\npredefined lists of colors by name e.g.\n``colors = matplotlib.color_sequences['Set1']``.  This example shows all of the\nbuilt in color sequences.\n\nUser-defined sequences can be added via `.ColorSequenceRegistry.register`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\n\ndef plot_color_sequences(names, ax):\n    # Display each named color sequence horizontally on the supplied axes.\n\n    for n, name in enumerate(names):\n        colors = mpl.color_sequences[name]\n        n_colors = len(colors)\n        x = np.arange(n_colors)\n        y = np.full_like(x, n)\n\n        ax.scatter(x, y, facecolor=colors, edgecolor='dimgray', s=200, zorder=2)\n\n    ax.set_yticks(range(len(names)), labels=names)\n    ax.grid(visible=True, axis='y')\n    ax.yaxis.set_inverted(True)\n    ax.xaxis.set_visible(False)\n    ax.spines[:].set_visible(False)\n    ax.tick_params(left=False)\n\n\nbuilt_in_color_sequences = [\n    'tab10', 'tab20', 'tab20b', 'tab20c', 'Pastel1', 'Pastel2', 'Paired',\n    'Accent', 'Dark2', 'Set1', 'Set2', 'Set3', 'petroff10']\n\n\nfig, ax = plt.subplots(figsize=(6.4, 9.6), layout='constrained')\n\nplot_color_sequences(built_in_color_sequences, ax)\nax.set_title('Built In Color Sequences')\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors.ColorSequenceRegistry`\n#    - `matplotlib.axes.Axes.scatter`\n#\n# .. tags::\n#\n#    styling: color\n#    purpose: reference\n"
    },
    {
      "filename": "colorbar_basics.py",
      "title": "Colorbar Basics",
      "code": "\"\"\"\n========\nColorbar\n========\n\nUse `~.Figure.colorbar` by specifying the mappable object (here\nthe `.AxesImage` returned by `~.axes.Axes.imshow`)\nand the Axes to attach the colorbar to.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# setup some generic data\nN = 37\nx, y = np.mgrid[:N, :N]\nZ = (np.cos(x*0.2) + np.sin(y*0.3))\n\n# mask out the negative and positive values, respectively\nZpos = np.ma.masked_less(Z, 0)\nZneg = np.ma.masked_greater(Z, 0)\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(13, 3), ncols=3)\n\n# plot just the positive data and save the\n# color \"mappable\" object returned by ax1.imshow\npos = ax1.imshow(Zpos, cmap='Blues', interpolation='none')\n\n# add the colorbar using the figure's method,\n# telling which mappable we're talking about and\n# which Axes object it should be near\nfig.colorbar(pos, ax=ax1)\n\n# repeat everything above for the negative data\n# you can specify location, anchor and shrink the colorbar\nneg = ax2.imshow(Zneg, cmap='Reds_r', interpolation='none')\nfig.colorbar(neg, ax=ax2, location='right', anchor=(0, 0.3), shrink=0.7)\n\n# Plot both positive and negative values between +/- 1.2\npos_neg_clipped = ax3.imshow(Z, cmap='RdBu', vmin=-1.2, vmax=1.2,\n                             interpolation='none')\n# Add minorticks on the colorbar to make it easy to read the\n# values off the colorbar.\ncbar = fig.colorbar(pos_neg_clipped, ax=ax3, extend='both')\ncbar.minorticks_on()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colorbar.Colorbar.minorticks_on`\n#    - `matplotlib.colorbar.Colorbar.minorticks_off`\n#\n# .. tags::\n#\n#    component: colorbar\n#    styling: color\n#    plot-type: imshow\n#    level: beginner\n"
    },
    {
      "filename": "colormap_reference.py",
      "title": "Colormap Reference",
      "code": "\"\"\"\n==================\nColormap reference\n==================\n\nReference for colormaps included with Matplotlib.\n\nA reversed version of each of these colormaps is available by appending\n``_r`` to the name, as shown in :ref:`reverse-cmap`.\n\nSee :ref:`colormaps` for an in-depth discussion about\ncolormaps, including colorblind-friendliness, and\n:ref:`colormap-manipulation` for a guide to creating\ncolormaps.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncmaps = [('Perceptually Uniform Sequential', [\n            'viridis', 'plasma', 'inferno', 'magma', 'cividis']),\n         ('Sequential', [\n            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',\n            'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',\n            'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']),\n         ('Sequential (2)', [\n            'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink',\n            'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia',\n            'hot', 'afmhot', 'gist_heat', 'copper']),\n         ('Diverging', [\n            'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',\n            'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic',\n            'berlin', 'managua', 'vanimo']),\n         ('Cyclic', ['twilight', 'twilight_shifted', 'hsv']),\n         ('Qualitative', [\n            'Pastel1', 'Pastel2', 'Paired', 'Accent',\n            'Dark2', 'Set1', 'Set2', 'Set3',\n            'tab10', 'tab20', 'tab20b', 'tab20c']),\n         ('Miscellaneous', [\n            'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern',\n            'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg',\n            'gist_rainbow', 'rainbow', 'jet', 'turbo', 'nipy_spectral',\n            'gist_ncar'])]\n\ngradient = np.linspace(0, 1, 256)\ngradient = np.vstack((gradient, gradient))\n\n\ndef plot_color_gradients(cmap_category, cmap_list):\n    # Create figure and adjust figure height to number of colormaps\n    nrows = len(cmap_list)\n    figh = 0.35 + 0.15 + (nrows + (nrows-1)*0.1)*0.22\n    fig, axs = plt.subplots(nrows=nrows, figsize=(6.4, figh))\n    fig.subplots_adjust(top=1-.35/figh, bottom=.15/figh, left=0.2, right=0.99)\n\n    axs[0].set_title(f\"{cmap_category} colormaps\", fontsize=14)\n\n    for ax, cmap_name in zip(axs, cmap_list):\n        ax.imshow(gradient, aspect='auto', cmap=cmap_name)\n        ax.text(-.01, .5, cmap_name, va='center', ha='right', fontsize=10,\n                transform=ax.transAxes)\n\n    # Turn off *all* ticks & spines, not just the ones with colormaps.\n    for ax in axs:\n        ax.set_axis_off()\n\n\nfor cmap_category, cmap_list in cmaps:\n    plot_color_gradients(cmap_category, cmap_list)\n\n\n# %%\n# .. _reverse-cmap:\n#\n# Reversed colormaps\n# ------------------\n#\n# Append ``_r`` to the name of any built-in colormap to get the reversed\n# version:\n\nplot_color_gradients(\"Original and reversed \", ['viridis', 'viridis_r'])\n\n# %%\n# The built-in reversed colormaps are generated using `.Colormap.reversed`.\n# For an example, see :ref:`reversing-colormap`\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors`\n#    - `matplotlib.axes.Axes.imshow`\n#    - `matplotlib.figure.Figure.text`\n#    - `matplotlib.axes.Axes.set_axis_off`\n#\n# .. tags::\n#\n#    styling: colormap\n#    purpose: reference\n"
    },
    {
      "filename": "custom_cmap.py",
      "title": "Custom Cmap",
      "code": "\"\"\"\n=======================================\nCreate a colormap from a list of colors\n=======================================\n\nFor more detail on creating and manipulating colormaps see\n:ref:`colormap-manipulation`.\n\nCreating a :ref:`colormap <colormaps>` from a list of colors\ncan be done with the `.LinearSegmentedColormap.from_list` method.  You must\npass a list of RGB tuples that define the mixture of colors from 0 to 1.\n\n\nCreating custom colormaps\n=========================\nIt is also possible to create a custom mapping for a colormap. This is\naccomplished by creating dictionary that specifies how the RGB channels\nchange from one end of the cmap to the other.\n\nExample: suppose you want red to increase from 0 to 1 over the bottom\nhalf, green to do the same over the middle half, and blue over the top\nhalf.  Then you would use::\n\n    cdict = {\n        'red': (\n            (0.0,  0.0, 0.0),\n            (0.5,  1.0, 1.0),\n            (1.0,  1.0, 1.0),\n        ),\n        'green': (\n            (0.0,  0.0, 0.0),\n            (0.25, 0.0, 0.0),\n            (0.75, 1.0, 1.0),\n            (1.0,  1.0, 1.0),\n        ),\n        'blue': (\n            (0.0,  0.0, 0.0),\n            (0.5,  0.0, 0.0),\n            (1.0,  1.0, 1.0),\n        )\n    }\n\nIf, as in this example, there are no discontinuities in the r, g, and b\ncomponents, then it is quite simple: the second and third element of\neach tuple, above, is the same -- call it \"``y``\".  The first element (\"``x``\")\ndefines interpolation intervals over the full range of 0 to 1, and it\nmust span that whole range.  In other words, the values of ``x`` divide the\n0-to-1 range into a set of segments, and ``y`` gives the end-point color\nvalues for each segment.\n\nNow consider the green, ``cdict['green']`` is saying that for:\n\n- 0 <= ``x`` <= 0.25, ``y`` is zero; no green.\n- 0.25 < ``x`` <= 0.75, ``y`` varies linearly from 0 to 1.\n- 0.75 < ``x`` <= 1, ``y`` remains at 1, full green.\n\nIf there are discontinuities, then it is a little more complicated. Label the 3\nelements in each row in the ``cdict`` entry for a given color as ``(x, y0,\ny1)``. Then for values of ``x`` between ``x[i]`` and ``x[i+1]`` the color value\nis interpolated between ``y1[i]`` and ``y0[i+1]``.\n\nGoing back to a cookbook example::\n\n    cdict = {\n        'red': (\n            (0.0,  0.0, 0.0),\n            (0.5,  1.0, 0.7),\n            (1.0,  1.0, 1.0),\n        ),\n        'green': (\n            (0.0,  0.0, 0.0),\n            (0.5,  1.0, 0.0),\n            (1.0,  1.0, 1.0),\n        ),\n        'blue': (\n            (0.0,  0.0, 0.0),\n            (0.5,  0.0, 0.0),\n            (1.0,  1.0, 1.0),\n        )\n    }\n\nand look at ``cdict['red'][1]``; because ``y0 != y1``, it is saying that for\n``x`` from 0 to 0.5, red increases from 0 to 1, but then it jumps down, so that\nfor ``x`` from 0.5 to 1, red increases from 0.7 to 1.  Green ramps from 0 to 1\nas ``x`` goes from 0 to 0.5, then jumps back to 0, and ramps back to 1 as ``x``\ngoes from 0.5 to 1. ::\n\n  row i:   x  y0  y1\n                 /\n                /\n  row i+1: x  y0  y1\n\nAbove is an attempt to show that for ``x`` in the range ``x[i]`` to ``x[i+1]``,\nthe interpolation is between ``y1[i]`` and ``y0[i+1]``.  So, ``y0[0]`` and\n``y1[-1]`` are never used.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib.colors import LinearSegmentedColormap\n\n# Make some illustrative fake data:\n\nx = np.arange(0, np.pi, 0.1)\ny = np.arange(0, 2 * np.pi, 0.1)\nX, Y = np.meshgrid(x, y)\nZ = np.cos(X) * np.sin(Y) * 10\n\n\n# %%\n# Colormaps from a list\n# ---------------------\n\ncolors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]  # R -> G -> B\nn_bins = [3, 6, 10, 100]  # Discretizes the interpolation into bins\ncmap_name = 'my_list'\nfig, axs = plt.subplots(2, 2, figsize=(6, 9))\nfig.subplots_adjust(left=0.02, bottom=0.06, right=0.95, top=0.94, wspace=0.05)\nfor n_bin, ax in zip(n_bins, axs.flat):\n    # Create the colormap\n    cmap = LinearSegmentedColormap.from_list(cmap_name, colors, N=n_bin)\n    # Fewer bins will result in \"coarser\" colomap interpolation\n    im = ax.imshow(Z, origin='lower', cmap=cmap)\n    ax.set_title(\"N bins: %s\" % n_bin)\n    fig.colorbar(im, ax=ax)\n\n\n# %%\n# Custom colormaps\n# ----------------\n\ncdict1 = {\n    'red': (\n        (0.0, 0.0, 0.0),\n        (0.5, 0.0, 0.1),\n        (1.0, 1.0, 1.0),\n    ),\n    'green': (\n        (0.0, 0.0, 0.0),\n        (1.0, 0.0, 0.0),\n    ),\n    'blue': (\n        (0.0, 0.0, 1.0),\n        (0.5, 0.1, 0.0),\n        (1.0, 0.0, 0.0),\n    )\n}\n\ncdict2 = {\n    'red': (\n        (0.0, 0.0, 0.0),\n        (0.5, 0.0, 1.0),\n        (1.0, 0.1, 1.0),\n    ),\n    'green': (\n        (0.0, 0.0, 0.0),\n        (1.0, 0.0, 0.0),\n    ),\n    'blue': (\n        (0.0, 0.0, 0.1),\n        (0.5, 1.0, 0.0),\n        (1.0, 0.0, 0.0),\n    )\n}\n\ncdict3 = {\n    'red': (\n        (0.0, 0.0, 0.0),\n        (0.25, 0.0, 0.0),\n        (0.5, 0.8, 1.0),\n        (0.75, 1.0, 1.0),\n        (1.0, 0.4, 1.0),\n    ),\n    'green': (\n        (0.0, 0.0, 0.0),\n        (0.25, 0.0, 0.0),\n        (0.5, 0.9, 0.9),\n        (0.75, 0.0, 0.0),\n        (1.0, 0.0, 0.0),\n    ),\n    'blue': (\n        (0.0, 0.0, 0.4),\n        (0.25, 1.0, 1.0),\n        (0.5, 1.0, 0.8),\n        (0.75, 0.0, 0.0),\n        (1.0, 0.0, 0.0),\n    )\n}\n\n# Make a modified version of cdict3 with some transparency\n# in the middle of the range.\ncdict4 = {\n    **cdict3,\n    'alpha': (\n        (0.0, 1.0, 1.0),\n        # (0.25, 1.0, 1.0),\n        (0.5, 0.3, 0.3),\n        # (0.75, 1.0, 1.0),\n        (1.0, 1.0, 1.0),\n    ),\n}\n\n\n# %%\n# Now we will use this example to illustrate 2 ways of\n# handling custom colormaps.\n# First, the most direct and explicit:\n\nblue_red1 = LinearSegmentedColormap('BlueRed1', cdict1)\n\n# %%\n# Second, create the map explicitly and register it.\n# Like the first method, this method works with any kind\n# of Colormap, not just\n# a LinearSegmentedColormap:\n\nmpl.colormaps.register(LinearSegmentedColormap('BlueRed2', cdict2))\nmpl.colormaps.register(LinearSegmentedColormap('BlueRed3', cdict3))\nmpl.colormaps.register(LinearSegmentedColormap('BlueRedAlpha', cdict4))\n\n# %%\n# Make the figure, with 4 subplots:\n\nfig, axs = plt.subplots(2, 2, figsize=(6, 9))\nfig.subplots_adjust(left=0.02, bottom=0.06, right=0.95, top=0.94, wspace=0.05)\n\nim1 = axs[0, 0].imshow(Z, cmap=blue_red1)\nfig.colorbar(im1, ax=axs[0, 0])\n\nim2 = axs[1, 0].imshow(Z, cmap='BlueRed2')\nfig.colorbar(im2, ax=axs[1, 0])\n\n# Now we will set the third cmap as the default.  One would\n# not normally do this in the middle of a script like this;\n# it is done here just to illustrate the method.\n\nplt.rcParams['image.cmap'] = 'BlueRed3'\n\nim3 = axs[0, 1].imshow(Z)\nfig.colorbar(im3, ax=axs[0, 1])\naxs[0, 1].set_title(\"Alpha = 1\")\n\n# Or as yet another variation, we can replace the rcParams\n# specification *before* the imshow with the following *after*\n# imshow.\n# This sets the new default *and* sets the colormap of the last\n# image-like item plotted via pyplot, if any.\n#\n\n# Draw a line with low zorder so it will be behind the image.\naxs[1, 1].plot([0, 10 * np.pi], [0, 20 * np.pi], color='c', lw=20, zorder=-1)\n\nim4 = axs[1, 1].imshow(Z)\nfig.colorbar(im4, ax=axs[1, 1])\n\n# Here it is: changing the colormap for the current image and its\n# colorbar after they have been plotted.\nim4.set_cmap('BlueRedAlpha')\naxs[1, 1].set_title(\"Varying alpha\")\n\nfig.suptitle('Custom Blue-Red colormaps', fontsize=16)\nfig.subplots_adjust(top=0.9)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors`\n#    - `matplotlib.colors.LinearSegmentedColormap`\n#    - `matplotlib.colors.LinearSegmentedColormap.from_list`\n#    - `matplotlib.cm`\n#    - `matplotlib.cm.ScalarMappable.set_cmap`\n#    - `matplotlib.cm.ColormapRegistry.register`\n#\n# .. tags::\n#\n#    styling: colormap\n#    plot-type: imshow\n#    level: intermediate\n"
    },
    {
      "filename": "individual_colors_from_cmap.py",
      "title": "Individual Colors From Cmap",
      "code": "\"\"\"\n===========================================\nSelecting individual colors from a colormap\n===========================================\n\nSometimes we want to use more colors or a different set of colors than the default color\ncycle provides. Selecting individual colors from one of the provided colormaps can be a\nconvenient way to do this.\n\nWe can retrieve colors from any `.Colormap` by calling it with a float or a list of\nfloats in the range [0, 1]; e.g. ``cmap(0.5)`` will give the middle color. See also\n`.Colormap.__call__`.\n\nExtracting colors from a continuous colormap\n--------------------------------------------\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\nn_lines = 21\ncmap = mpl.colormaps['plasma']\n\n# Take colors at regular intervals spanning the colormap.\ncolors = cmap(np.linspace(0, 1, n_lines))\n\nfig, ax = plt.subplots(layout='constrained')\n\nfor i, color in enumerate(colors):\n    ax.plot([0, i], color=color)\n\nplt.show()\n\n# %%\n#\n# Extracting colors from a discrete colormap\n# ------------------------------------------\n# The list of all colors in a `.ListedColormap` is available as the ``colors``\n# attribute.  Note that all the colors from Matplotlib's qualitative color maps\n# are also available as color sequences, so may be accessed more directly from\n# the color sequence registry.  See :doc:`/gallery/color/color_sequences`.\n\ncolors = mpl.colormaps['Dark2'].colors\n\nfig, ax = plt.subplots(layout='constrained')\n\nfor i, color in enumerate(colors):\n    ax.plot([0, i], color=color)\n\nplt.show()\n\n# %%\n# See Also\n# --------\n#\n# For more details about manipulating colormaps, see :ref:`colormap-manipulation`.  To\n# change the default color cycle, see :ref:`color_cycle`.\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors.Colormap`\n#    - `matplotlib.colors.Colormap.resampled`\n#\n# .. tags::\n#\n#    component: colormap\n#    styling: color\n#    plot-type: line\n#    level: intermediate\n"
    },
    {
      "filename": "named_colors.py",
      "title": "Named Colors",
      "code": "\"\"\"\n====================\nList of named colors\n====================\n\nThis plots a list of the named colors supported by Matplotlib.\nFor more information on colors in matplotlib see\n\n* the :ref:`colors_def` tutorial;\n* the `matplotlib.colors` API;\n* the :doc:`/gallery/color/color_demo`.\n\n----------------------------\nHelper Function for Plotting\n----------------------------\nFirst we define a helper function for making a table of colors, then we use it\non some common color categories.\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Rectangle\n\n\ndef plot_colortable(colors, *, ncols=4, sort_colors=True):\n\n    cell_width = 212\n    cell_height = 22\n    swatch_width = 48\n    margin = 12\n\n    # Sort colors by hue, saturation, value and name.\n    if sort_colors is True:\n        names = sorted(\n            colors, key=lambda c: tuple(mcolors.rgb_to_hsv(mcolors.to_rgb(c))))\n    else:\n        names = list(colors)\n\n    n = len(names)\n    nrows = math.ceil(n / ncols)\n\n    width = cell_width * ncols + 2 * margin\n    height = cell_height * nrows + 2 * margin\n    dpi = 72\n\n    fig, ax = plt.subplots(figsize=(width / dpi, height / dpi), dpi=dpi)\n    fig.subplots_adjust(margin/width, margin/height,\n                        (width-margin)/width, (height-margin)/height)\n    ax.set_xlim(0, cell_width * ncols)\n    ax.set_ylim(cell_height * (nrows-0.5), -cell_height/2.)\n    ax.yaxis.set_visible(False)\n    ax.xaxis.set_visible(False)\n    ax.set_axis_off()\n\n    for i, name in enumerate(names):\n        row = i % nrows\n        col = i // nrows\n        y = row * cell_height\n\n        swatch_start_x = cell_width * col\n        text_pos_x = cell_width * col + swatch_width + 7\n\n        ax.text(text_pos_x, y, name, fontsize=14,\n                horizontalalignment='left',\n                verticalalignment='center')\n\n        ax.add_patch(\n            Rectangle(xy=(swatch_start_x, y-9), width=swatch_width,\n                      height=18, facecolor=colors[name], edgecolor='0.7')\n        )\n\n    return fig\n\n# %%\n# -----------\n# Base colors\n# -----------\n\nplot_colortable(mcolors.BASE_COLORS, ncols=3, sort_colors=False)\n\n# %%\n# ---------------\n# Tableau Palette\n# ---------------\n\nplot_colortable(mcolors.TABLEAU_COLORS, ncols=2, sort_colors=False)\n\n# %%\n# ----------\n# CSS Colors\n# ----------\n\n# sphinx_gallery_thumbnail_number = 3\nplot_colortable(mcolors.CSS4_COLORS)\nplt.show()\n\n# %%\n# -----------\n# XKCD Colors\n# -----------\n# Matplotlib supports colors from the\n# `xkcd color survey <https://xkcd.com/color/rgb/>`_, e.g. ``\"xkcd:sky blue\"``. Since\n# this contains almost 1000 colors, a figure of this would be very large and is thus\n# omitted here. You can use the following code to generate the overview yourself ::\n#\n#     xkcd_fig = plot_colortable(mcolors.XKCD_COLORS)\n#     xkcd_fig.savefig(\"XKCD_Colors.png\")\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors`\n#    - `matplotlib.colors.rgb_to_hsv`\n#    - `matplotlib.colors.to_rgba`\n#    - `matplotlib.figure.Figure.get_size_inches`\n#    - `matplotlib.figure.Figure.subplots_adjust`\n#    - `matplotlib.axes.Axes.text`\n#    - `matplotlib.patches.Rectangle`\n#\n# .. tags::\n#\n#    styling: color\n#    purpose: reference\n"
    },
    {
      "filename": "set_alpha.py",
      "title": "Set Alpha",
      "code": "\"\"\"\n=================================\nWays to set a color's alpha value\n=================================\n\nCompare setting alpha by the *alpha* keyword argument and by one of the Matplotlib color\nformats. Often, the *alpha* keyword is the only tool needed to add transparency to a\ncolor. In some cases, the *(matplotlib_color, alpha)* color format provides an easy way\nto fine-tune the appearance of a Figure.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility.\nnp.random.seed(19680801)\n\nfig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 4))\n\nx_values = [n for n in range(20)]\ny_values = np.random.randn(20)\n\nfacecolors = ['green' if y > 0 else 'red' for y in y_values]\nedgecolors = facecolors\n\nax1.bar(x_values, y_values, color=facecolors, edgecolor=edgecolors, alpha=0.5)\nax1.set_title(\"Explicit 'alpha' keyword value\\nshared by all bars and edges\")\n\n\n# Normalize y values to get distinct face alpha values.\nabs_y = [abs(y) for y in y_values]\nface_alphas = [n / max(abs_y) for n in abs_y]\nedge_alphas = [1 - alpha for alpha in face_alphas]\n\ncolors_with_alphas = list(zip(facecolors, face_alphas))\nedgecolors_with_alphas = list(zip(edgecolors, edge_alphas))\n\nax2.bar(x_values, y_values, color=colors_with_alphas,\n        edgecolor=edgecolors_with_alphas)\nax2.set_title('Normalized alphas for\\neach bar and each edge')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar`\n#    - `matplotlib.pyplot.subplots`\n#\n# .. tags::\n#\n#    styling: color\n#    plot-type: bar\n#    level: beginner\n"
    }
  ],
  "event_handling": [
    {
      "filename": "close_event.py",
      "title": "Close Event",
      "code": "\"\"\"\n===========\nClose event\n===========\n\nExample to show connecting events that occur when the figure closes.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\nimport matplotlib.pyplot as plt\n\n\ndef on_close(event):\n    print('Closed Figure!')\n\nfig = plt.figure()\nfig.canvas.mpl_connect('close_event', on_close)\n\nplt.text(0.35, 0.5, 'Close Me!', dict(size=30))\nplt.show()\n"
    },
    {
      "filename": "coords_demo.py",
      "title": "Coords Demo",
      "code": "\"\"\"\n===========================\nMouse move and click events\n===========================\n\nAn example of how to interact with the plotting canvas by connecting to move\nand click events.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseButton\n\nt = np.arange(0.0, 1.0, 0.01)\ns = np.sin(2 * np.pi * t)\nfig, ax = plt.subplots()\nax.plot(t, s)\n\n\ndef on_move(event):\n    if event.inaxes:\n        print(f'data coords {event.xdata} {event.ydata},',\n              f'pixel coords {event.x} {event.y}')\n\n\ndef on_click(event):\n    if event.button is MouseButton.LEFT:\n        print('disconnecting callback')\n        plt.disconnect(binding_id)\n\n\nbinding_id = plt.connect('motion_notify_event', on_move)\nplt.connect('button_press_event', on_click)\n\nplt.show()\n"
    },
    {
      "filename": "cursor_demo.py",
      "title": "Cursor Demo",
      "code": "\"\"\"\n=================\nCross-hair cursor\n=================\n\nThis example adds a cross-hair as a data cursor.  The cross-hair is\nimplemented as regular line objects that are updated on mouse move.\n\nWe show three implementations:\n\n1) A simple cursor implementation that redraws the figure on every mouse move.\n   This is a bit slow, and you may notice some lag of the cross-hair movement.\n2) A cursor that uses blitting for speedup of the rendering.\n3) A cursor that snaps to data points.\n\nFaster cursoring is possible using native GUI drawing, as in\n:doc:`/gallery/user_interfaces/wxcursor_demo_sgskip`.\n\nThe mpldatacursor__ and mplcursors__ third-party packages can be used to\nachieve a similar effect.\n\n__ https://github.com/joferkington/mpldatacursor\n__ https://github.com/anntzer/mplcursors\n\n.. redirect-from:: /gallery/misc/cursor_demo\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseEvent\n\n\nclass Cursor:\n    \"\"\"\n    A cross hair cursor.\n    \"\"\"\n    def __init__(self, ax):\n        self.ax = ax\n        self.horizontal_line = ax.axhline(color='k', lw=0.8, ls='--')\n        self.vertical_line = ax.axvline(color='k', lw=0.8, ls='--')\n        # text location in axes coordinates\n        self.text = ax.text(0.72, 0.9, '', transform=ax.transAxes)\n\n    def set_cross_hair_visible(self, visible):\n        need_redraw = self.horizontal_line.get_visible() != visible\n        self.horizontal_line.set_visible(visible)\n        self.vertical_line.set_visible(visible)\n        self.text.set_visible(visible)\n        return need_redraw\n\n    def on_mouse_move(self, event):\n        if not event.inaxes:\n            need_redraw = self.set_cross_hair_visible(False)\n            if need_redraw:\n                self.ax.figure.canvas.draw()\n        else:\n            self.set_cross_hair_visible(True)\n            x, y = event.xdata, event.ydata\n            # update the line positions\n            self.horizontal_line.set_ydata([y])\n            self.vertical_line.set_xdata([x])\n            self.text.set_text(f'x={x:1.2f}, y={y:1.2f}')\n            self.ax.figure.canvas.draw()\n\n\nx = np.arange(0, 1, 0.01)\ny = np.sin(2 * 2 * np.pi * x)\n\nfig, ax = plt.subplots()\nax.set_title('Simple cursor')\nax.plot(x, y, 'o')\ncursor = Cursor(ax)\nfig.canvas.mpl_connect('motion_notify_event', cursor.on_mouse_move)\n\n# Simulate a mouse move to (0.5, 0.5), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((0.5, 0.5))\n)._process()\n\n# %%\n# Faster redrawing using blitting\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n# This technique stores the rendered plot as a background image. Only the\n# changed artists (cross-hair lines and text) are rendered anew. They are\n# combined with the background using blitting.\n#\n# This technique is significantly faster. It requires a bit more setup because\n# the background has to be stored without the cross-hair lines (see\n# ``create_new_background()``). Additionally, a new background has to be\n# created whenever the figure changes. This is achieved by connecting to the\n# ``'draw_event'``.\n\n\nclass BlittedCursor:\n    \"\"\"\n    A cross-hair cursor using blitting for faster redraw.\n    \"\"\"\n    def __init__(self, ax):\n        self.ax = ax\n        self.background = None\n        self.horizontal_line = ax.axhline(color='k', lw=0.8, ls='--')\n        self.vertical_line = ax.axvline(color='k', lw=0.8, ls='--')\n        # text location in axes coordinates\n        self.text = ax.text(0.72, 0.9, '', transform=ax.transAxes)\n        self._creating_background = False\n        ax.figure.canvas.mpl_connect('draw_event', self.on_draw)\n\n    def on_draw(self, event):\n        self.create_new_background()\n\n    def set_cross_hair_visible(self, visible):\n        need_redraw = self.horizontal_line.get_visible() != visible\n        self.horizontal_line.set_visible(visible)\n        self.vertical_line.set_visible(visible)\n        self.text.set_visible(visible)\n        return need_redraw\n\n    def create_new_background(self):\n        if self._creating_background:\n            # discard calls triggered from within this function\n            return\n        self._creating_background = True\n        self.set_cross_hair_visible(False)\n        self.ax.figure.canvas.draw()\n        self.background = self.ax.figure.canvas.copy_from_bbox(self.ax.bbox)\n        self.set_cross_hair_visible(True)\n        self._creating_background = False\n\n    def on_mouse_move(self, event):\n        if self.background is None:\n            self.create_new_background()\n        if not event.inaxes:\n            need_redraw = self.set_cross_hair_visible(False)\n            if need_redraw:\n                self.ax.figure.canvas.restore_region(self.background)\n                self.ax.figure.canvas.blit(self.ax.bbox)\n        else:\n            self.set_cross_hair_visible(True)\n            # update the line positions\n            x, y = event.xdata, event.ydata\n            self.horizontal_line.set_ydata([y])\n            self.vertical_line.set_xdata([x])\n            self.text.set_text(f'x={x:1.2f}, y={y:1.2f}')\n\n            self.ax.figure.canvas.restore_region(self.background)\n            self.ax.draw_artist(self.horizontal_line)\n            self.ax.draw_artist(self.vertical_line)\n            self.ax.draw_artist(self.text)\n            self.ax.figure.canvas.blit(self.ax.bbox)\n\n\nx = np.arange(0, 1, 0.01)\ny = np.sin(2 * 2 * np.pi * x)\n\nfig, ax = plt.subplots()\nax.set_title('Blitted cursor')\nax.plot(x, y, 'o')\nblitted_cursor = BlittedCursor(ax)\nfig.canvas.mpl_connect('motion_notify_event', blitted_cursor.on_mouse_move)\n\n# Simulate a mouse move to (0.5, 0.5), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((0.5, 0.5))\n)._process()\n\n# %%\n# Snapping to data points\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n# The following cursor snaps its position to the data points of a `.Line2D`\n# object.\n#\n# To save unnecessary redraws, the index of the last indicated data point is\n# saved in ``self._last_index``. A redraw is only triggered when the mouse\n# moves far enough so that another data point must be selected. This reduces\n# the lag due to many redraws. Of course, blitting could still be added on top\n# for additional speedup.\n\n\nclass SnappingCursor:\n    \"\"\"\n    A cross-hair cursor that snaps to the data point of a line, which is\n    closest to the *x* position of the cursor.\n\n    For simplicity, this assumes that *x* values of the data are sorted.\n    \"\"\"\n    def __init__(self, ax, line):\n        self.ax = ax\n        self.horizontal_line = ax.axhline(color='k', lw=0.8, ls='--')\n        self.vertical_line = ax.axvline(color='k', lw=0.8, ls='--')\n        self.x, self.y = line.get_data()\n        self._last_index = None\n        # text location in axes coords\n        self.text = ax.text(0.72, 0.9, '', transform=ax.transAxes)\n\n    def set_cross_hair_visible(self, visible):\n        need_redraw = self.horizontal_line.get_visible() != visible\n        self.horizontal_line.set_visible(visible)\n        self.vertical_line.set_visible(visible)\n        self.text.set_visible(visible)\n        return need_redraw\n\n    def on_mouse_move(self, event):\n        if not event.inaxes:\n            self._last_index = None\n            need_redraw = self.set_cross_hair_visible(False)\n            if need_redraw:\n                self.ax.figure.canvas.draw()\n        else:\n            self.set_cross_hair_visible(True)\n            x, y = event.xdata, event.ydata\n            index = min(np.searchsorted(self.x, x), len(self.x) - 1)\n            if index == self._last_index:\n                return  # still on the same data point. Nothing to do.\n            self._last_index = index\n            x = self.x[index]\n            y = self.y[index]\n            # update the line positions\n            self.horizontal_line.set_ydata([y])\n            self.vertical_line.set_xdata([x])\n            self.text.set_text(f'x={x:1.2f}, y={y:1.2f}')\n            self.ax.figure.canvas.draw()\n\n\nx = np.arange(0, 1, 0.01)\ny = np.sin(2 * 2 * np.pi * x)\n\nfig, ax = plt.subplots()\nax.set_title('Snapping cursor')\nline, = ax.plot(x, y, 'o')\nsnap_cursor = SnappingCursor(ax, line)\nfig.canvas.mpl_connect('motion_notify_event', snap_cursor.on_mouse_move)\n\n# Simulate a mouse move to (0.5, 0.5), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((0.5, 0.5))\n)._process()\n\nplt.show()\n"
    },
    {
      "filename": "data_browser.py",
      "title": "Data Browser",
      "code": "\"\"\"\n============\nData browser\n============\n\nConnecting data between multiple canvases.\n\nThis example covers how to interact data with multiple canvases. This\nlets you select and highlight a point on one axis, and generating the\ndata of that point on the other axis.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\nimport numpy as np\n\n\nclass PointBrowser:\n    \"\"\"\n    Click on a point to select and highlight it -- the data that\n    generated the point will be shown in the lower Axes.  Use the 'n'\n    and 'p' keys to browse through the next and previous points\n    \"\"\"\n\n    def __init__(self):\n        self.lastind = 0\n\n        self.text = ax.text(0.05, 0.95, 'selected: none',\n                            transform=ax.transAxes, va='top')\n        self.selected, = ax.plot([xs[0]], [ys[0]], 'o', ms=12, alpha=0.4,\n                                 color='yellow', visible=False)\n\n    def on_press(self, event):\n        if self.lastind is None:\n            return\n        if event.key not in ('n', 'p'):\n            return\n        if event.key == 'n':\n            inc = 1\n        else:\n            inc = -1\n\n        self.lastind += inc\n        self.lastind = np.clip(self.lastind, 0, len(xs) - 1)\n        self.update()\n\n    def on_pick(self, event):\n\n        if event.artist != line:\n            return True\n\n        N = len(event.ind)\n        if not N:\n            return True\n\n        # the click locations\n        x = event.mouseevent.xdata\n        y = event.mouseevent.ydata\n\n        distances = np.hypot(x - xs[event.ind], y - ys[event.ind])\n        indmin = distances.argmin()\n        dataind = event.ind[indmin]\n\n        self.lastind = dataind\n        self.update()\n\n    def update(self):\n        if self.lastind is None:\n            return\n\n        dataind = self.lastind\n\n        ax2.clear()\n        ax2.plot(X[dataind])\n\n        ax2.text(0.05, 0.9, f'mu={xs[dataind]:1.3f}\\nsigma={ys[dataind]:1.3f}',\n                 transform=ax2.transAxes, va='top')\n        ax2.set_ylim(-0.5, 1.5)\n        self.selected.set_visible(True)\n        self.selected.set_data([xs[dataind]], [ys[dataind]])\n\n        self.text.set_text('selected: %d' % dataind)\n        fig.canvas.draw()\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    X = np.random.rand(100, 200)\n    xs = np.mean(X, axis=1)\n    ys = np.std(X, axis=1)\n\n    fig, (ax, ax2) = plt.subplots(2, 1)\n    ax.set_title('click on point to plot time series')\n    line, = ax.plot(xs, ys, 'o', picker=True, pickradius=5)\n\n    browser = PointBrowser()\n\n    fig.canvas.mpl_connect('pick_event', browser.on_pick)\n    fig.canvas.mpl_connect('key_press_event', browser.on_press)\n\n    plt.show()\n"
    },
    {
      "filename": "figure_axes_enter_leave.py",
      "title": "Figure Axes Enter Leave",
      "code": "\"\"\"\n==================================\nFigure/Axes enter and leave events\n==================================\n\nIllustrate the figure and Axes enter and leave events by changing the\nframe colors on enter and leave.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\nimport matplotlib.pyplot as plt\n\n\ndef on_enter_axes(event):\n    print('enter_axes', event.inaxes)\n    event.inaxes.patch.set_facecolor('yellow')\n    event.canvas.draw()\n\n\ndef on_leave_axes(event):\n    print('leave_axes', event.inaxes)\n    event.inaxes.patch.set_facecolor('white')\n    event.canvas.draw()\n\n\ndef on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n\n\ndef on_leave_figure(event):\n    print('leave_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('grey')\n    event.canvas.draw()\n\n\nfig, axs = plt.subplots(2, 1)\nfig.suptitle('mouse hover over figure or Axes to trigger events')\n\nfig.canvas.mpl_connect('figure_enter_event', on_enter_figure)\nfig.canvas.mpl_connect('figure_leave_event', on_leave_figure)\nfig.canvas.mpl_connect('axes_enter_event', on_enter_axes)\nfig.canvas.mpl_connect('axes_leave_event', on_leave_axes)\n\nplt.show()\n"
    },
    {
      "filename": "ginput_manual_clabel_sgskip.py",
      "title": "Ginput Manual Clabel Sgskip",
      "code": "\"\"\"\n=====================\nInteractive functions\n=====================\n\nThis provides examples of uses of interactive functions, such as ginput,\nwaitforbuttonpress and manual clabel placement.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef tellme(s):\n    print(s)\n    plt.title(s, fontsize=16)\n    plt.draw()\n\n# %%\n# Define a triangle by clicking three points\n\n\nplt.figure()\nplt.xlim(0, 1)\nplt.ylim(0, 1)\n\ntellme('You will define a triangle, click to begin')\n\nplt.waitforbuttonpress()\n\nwhile True:\n    pts = []\n    while len(pts) < 3:\n        tellme('Select 3 corners with mouse')\n        pts = np.asarray(plt.ginput(3, timeout=-1))\n        if len(pts) < 3:\n            tellme('Too few points, starting over')\n            time.sleep(1)  # Wait a second\n\n    ph = plt.fill(pts[:, 0], pts[:, 1], 'r', lw=2)\n\n    tellme('Happy? Key click for yes, mouse click for no')\n\n    if plt.waitforbuttonpress():\n        break\n\n    # Get rid of fill\n    for p in ph:\n        p.remove()\n\n\n# %%\n# Now contour according to distance from triangle\n# corners - just an example\n\n# Define a nice function of distance from individual pts\ndef f(x, y, pts):\n    z = np.zeros_like(x)\n    for p in pts:\n        z = z + 1/(np.sqrt((x - p[0])**2 + (y - p[1])**2))\n    return 1/z\n\n\nX, Y = np.meshgrid(np.linspace(-1, 1, 51), np.linspace(-1, 1, 51))\nZ = f(X, Y, pts)\n\nCS = plt.contour(X, Y, Z, 20)\n\ntellme('Use mouse to select contour label locations, middle button to finish')\nCL = plt.clabel(CS, manual=True)\n\n# %%\n# Now do a zoom\n\ntellme('Now do a nested zoom, click to begin')\nplt.waitforbuttonpress()\n\nwhile True:\n    tellme('Select two corners of zoom, middle mouse button to finish')\n    pts = plt.ginput(2, timeout=-1)\n    if len(pts) < 2:\n        break\n    (x0, y0), (x1, y1) = pts\n    xmin, xmax = sorted([x0, x1])\n    ymin, ymax = sorted([y0, y1])\n    plt.xlim(xmin, xmax)\n    plt.ylim(ymin, ymax)\n\ntellme('All Done!')\nplt.show()\n"
    },
    {
      "filename": "image_slices_viewer.py",
      "title": "Image Slices Viewer",
      "code": "\"\"\"\n============\nScroll event\n============\n\nIn this example a scroll wheel event is used to scroll through 2D slices of\n3D data.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass IndexTracker:\n    def __init__(self, ax, X):\n        self.index = 0\n        self.X = X\n        self.ax = ax\n        self.im = ax.imshow(self.X[:, :, self.index])\n        self.update()\n\n    def on_scroll(self, event):\n        print(event.button, event.step)\n        increment = 1 if event.button == 'up' else -1\n        max_index = self.X.shape[-1] - 1\n        self.index = np.clip(self.index + increment, 0, max_index)\n        self.update()\n\n    def update(self):\n        self.im.set_data(self.X[:, :, self.index])\n        self.ax.set_title(\n            f'Use scroll wheel to navigate\\nindex {self.index}')\n        self.im.axes.figure.canvas.draw()\n\n\nx, y, z = np.ogrid[-10:10:100j, -10:10:100j, 1:10:20j]\nX = np.sin(x * y * z) / (x * y * z)\n\nfig, ax = plt.subplots()\n# create an IndexTracker and make sure it lives during the whole\n# lifetime of the figure by assigning it to a variable\ntracker = IndexTracker(ax, X)\n\nfig.canvas.mpl_connect('scroll_event', tracker.on_scroll)\nplt.show()\n"
    },
    {
      "filename": "keypress_demo.py",
      "title": "Keypress Demo",
      "code": "\"\"\"\n==============\nKeypress event\n==============\n\nShow how to connect to keypress events.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\nimport sys\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef on_press(event):\n    print('press', event.key)\n    sys.stdout.flush()\n    if event.key == 'x':\n        visible = xl.get_visible()\n        xl.set_visible(not visible)\n        fig.canvas.draw()\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\nfig.canvas.mpl_connect('key_press_event', on_press)\n\nax.plot(np.random.rand(12), np.random.rand(12), 'go')\nxl = ax.set_xlabel('easy come, easy go')\nax.set_title('Press a key')\nplt.show()\n"
    },
    {
      "filename": "lasso_demo.py",
      "title": "Lasso Demo",
      "code": "\"\"\"\n==========\nLasso Demo\n==========\n\nUse a lasso to select a set of points and get the indices of the selected points.\nA callback is used to change the color of the selected points.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors as mcolors\nfrom matplotlib import path\nfrom matplotlib.collections import RegularPolyCollection\nfrom matplotlib.widgets import Lasso\n\n\nclass LassoManager:\n    def __init__(self, ax, data):\n        # The information of whether a point has been selected or not is stored in the\n        # collection's array (0 = out, 1 = in), which then gets colormapped to blue\n        # (out) and red (in).\n        self.collection = RegularPolyCollection(\n            6, sizes=(100,), offset_transform=ax.transData,\n            offsets=data, array=np.zeros(len(data)),\n            clim=(0, 1), cmap=mcolors.ListedColormap([\"tab:blue\", \"tab:red\"]))\n        ax.add_collection(self.collection)\n        canvas = ax.figure.canvas\n        canvas.mpl_connect('button_press_event', self.on_press)\n        canvas.mpl_connect('button_release_event', self.on_release)\n\n    def callback(self, verts):\n        data = self.collection.get_offsets()\n        self.collection.set_array(path.Path(verts).contains_points(data))\n        canvas = self.collection.figure.canvas\n        canvas.draw_idle()\n        del self.lasso\n\n    def on_press(self, event):\n        canvas = self.collection.figure.canvas\n        if event.inaxes is not self.collection.axes or canvas.widgetlock.locked():\n            return\n        self.lasso = Lasso(event.inaxes, (event.xdata, event.ydata), self.callback)\n        canvas.widgetlock(self.lasso)  # acquire a lock on the widget drawing\n\n    def on_release(self, event):\n        canvas = self.collection.figure.canvas\n        if hasattr(self, 'lasso') and canvas.widgetlock.isowner(self.lasso):\n            canvas.widgetlock.release(self.lasso)\n\n\nif __name__ == '__main__':\n    np.random.seed(19680801)\n    ax = plt.figure().add_subplot(\n        xlim=(0, 1), ylim=(0, 1), title='Lasso points using left mouse button')\n    manager = LassoManager(ax, np.random.rand(100, 2))\n    plt.show()\n"
    },
    {
      "filename": "legend_picking.py",
      "title": "Legend Picking",
      "code": "\"\"\"\n==============\nLegend picking\n==============\n\nEnable picking on the legend to toggle the original line on and off\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 1)\ny1 = 2 * np.sin(2 * np.pi * t)\ny2 = 4 * np.sin(2 * np.pi * 2 * t)\n\nfig, ax = plt.subplots()\nax.set_title('Click on legend line to toggle line on/off')\n(line1, ) = ax.plot(t, y1, lw=2, label='1 Hz')\n(line2, ) = ax.plot(t, y2, lw=2, label='2 Hz')\nleg = ax.legend(fancybox=True, shadow=True)\n\nlines = [line1, line2]\nmap_legend_to_ax = {}  # Will map legend lines to original lines.\n\npickradius = 5  # Points (Pt). How close the click needs to be to trigger an event.\n\nfor legend_line, ax_line in zip(leg.get_lines(), lines):\n    legend_line.set_picker(pickradius)  # Enable picking on the legend line.\n    map_legend_to_ax[legend_line] = ax_line\n\n\ndef on_pick(event):\n    # On the pick event, find the original line corresponding to the legend\n    # proxy line, and toggle its visibility.\n    legend_line = event.artist\n\n    # Do nothing if the source of the event is not a legend line.\n    if legend_line not in map_legend_to_ax:\n        return\n\n    ax_line = map_legend_to_ax[legend_line]\n    visible = not ax_line.get_visible()\n    ax_line.set_visible(visible)\n    # Change the alpha on the line in the legend, so we can see what lines\n    # have been toggled.\n    legend_line.set_alpha(1.0 if visible else 0.2)\n    fig.canvas.draw()\n\n\nfig.canvas.mpl_connect('pick_event', on_pick)\n\n# Works even if the legend is draggable. This is independent from picking legend lines.\nleg.set_draggable(True)\n\nplt.show()\n"
    },
    {
      "filename": "looking_glass.py",
      "title": "Looking Glass",
      "code": "\"\"\"\n=============\nLooking glass\n=============\n\nExample using mouse events to simulate a looking glass for inspecting data.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as patches\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx, y = np.random.rand(2, 200)\n\nfig, ax = plt.subplots()\ncirc = patches.Circle((0.5, 0.5), 0.25, alpha=0.8, fc='yellow')\nax.add_patch(circ)\n\n\nax.plot(x, y, alpha=0.2)\nline, = ax.plot(x, y, alpha=1.0, clip_path=circ)\nax.set_title(\"Left click and drag to move looking glass\")\n\n\nclass EventHandler:\n    def __init__(self):\n        fig.canvas.mpl_connect('button_press_event', self.on_press)\n        fig.canvas.mpl_connect('button_release_event', self.on_release)\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n        self.x0, self.y0 = circ.center\n        self.pressevent = None\n\n    def on_press(self, event):\n        if event.inaxes != ax:\n            return\n\n        if not circ.contains(event)[0]:\n            return\n\n        self.pressevent = event\n\n    def on_release(self, event):\n        self.pressevent = None\n        self.x0, self.y0 = circ.center\n\n    def on_move(self, event):\n        if self.pressevent is None or event.inaxes != self.pressevent.inaxes:\n            return\n\n        dx = event.xdata - self.pressevent.xdata\n        dy = event.ydata - self.pressevent.ydata\n        circ.center = self.x0 + dx, self.y0 + dy\n        line.set_clip_path(circ)\n        fig.canvas.draw()\n\nhandler = EventHandler()\nplt.show()\n"
    },
    {
      "filename": "path_editor.py",
      "title": "Path Editor",
      "code": "\"\"\"\n===========\nPath editor\n===========\n\nSharing events across GUIs.\n\nThis example demonstrates a cross-GUI application using Matplotlib event\nhandling to interact with and modify objects on the canvas.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseButton\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nfig, ax = plt.subplots()\n\npathdata = [\n    (Path.MOVETO, (1.58, -2.57)),\n    (Path.CURVE4, (0.35, -1.1)),\n    (Path.CURVE4, (-1.75, 2.0)),\n    (Path.CURVE4, (0.375, 2.0)),\n    (Path.LINETO, (0.85, 1.15)),\n    (Path.CURVE4, (2.2, 3.2)),\n    (Path.CURVE4, (3, 0.05)),\n    (Path.CURVE4, (2.0, -0.5)),\n    (Path.CLOSEPOLY, (1.58, -2.57)),\n]\n\ncodes, verts = zip(*pathdata)\npath = Path(verts, codes)\npatch = PathPatch(\n    path, facecolor='green', edgecolor='yellow', alpha=0.5)\nax.add_patch(patch)\n\n\nclass PathInteractor:\n    \"\"\"\n    A path editor.\n\n    Press 't' to toggle vertex markers on and off.  When vertex markers are on,\n    they can be dragged with the mouse.\n    \"\"\"\n\n    showverts = True\n    epsilon = 5  # max pixel distance to count as a vertex hit\n\n    def __init__(self, pathpatch):\n\n        self.ax = pathpatch.axes\n        canvas = self.ax.figure.canvas\n        self.pathpatch = pathpatch\n        self.pathpatch.set_animated(True)\n\n        x, y = zip(*self.pathpatch.get_path().vertices)\n\n        self.line, = ax.plot(\n            x, y, marker='o', markerfacecolor='r', animated=True)\n\n        self._ind = None  # the active vertex\n\n        canvas.mpl_connect('draw_event', self.on_draw)\n        canvas.mpl_connect('button_press_event', self.on_button_press)\n        canvas.mpl_connect('key_press_event', self.on_key_press)\n        canvas.mpl_connect('button_release_event', self.on_button_release)\n        canvas.mpl_connect('motion_notify_event', self.on_mouse_move)\n        self.canvas = canvas\n\n    def get_ind_under_point(self, event):\n        \"\"\"\n        Return the index of the point closest to the event position or *None*\n        if no point is within ``self.epsilon`` to the event position.\n        \"\"\"\n        xy = self.pathpatch.get_path().vertices\n        xyt = self.pathpatch.get_transform().transform(xy)  # to display coords\n        xt, yt = xyt[:, 0], xyt[:, 1]\n        d = np.sqrt((xt - event.x)**2 + (yt - event.y)**2)\n        ind = d.argmin()\n        return ind if d[ind] < self.epsilon else None\n\n    def on_draw(self, event):\n        \"\"\"Callback for draws.\"\"\"\n        self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n        self.ax.draw_artist(self.pathpatch)\n        self.ax.draw_artist(self.line)\n\n    def on_button_press(self, event):\n        \"\"\"Callback for mouse button presses.\"\"\"\n        if (event.inaxes is None\n                or event.button != MouseButton.LEFT\n                or not self.showverts):\n            return\n        self._ind = self.get_ind_under_point(event)\n\n    def on_button_release(self, event):\n        \"\"\"Callback for mouse button releases.\"\"\"\n        if (event.button != MouseButton.LEFT\n                or not self.showverts):\n            return\n        self._ind = None\n\n    def on_key_press(self, event):\n        \"\"\"Callback for key presses.\"\"\"\n        if not event.inaxes:\n            return\n        if event.key == 't':\n            self.showverts = not self.showverts\n            self.line.set_visible(self.showverts)\n            if not self.showverts:\n                self._ind = None\n        self.canvas.draw()\n\n    def on_mouse_move(self, event):\n        \"\"\"Callback for mouse movements.\"\"\"\n        if (self._ind is None\n                or event.inaxes is None\n                or event.button != MouseButton.LEFT\n                or not self.showverts):\n            return\n\n        vertices = self.pathpatch.get_path().vertices\n\n        vertices[self._ind] = event.xdata, event.ydata\n        self.line.set_data(zip(*vertices))\n\n        self.canvas.restore_region(self.background)\n        self.ax.draw_artist(self.pathpatch)\n        self.ax.draw_artist(self.line)\n        self.canvas.blit(self.ax.bbox)\n\n\ninteractor = PathInteractor(patch)\nax.set_title('drag vertices to update path')\nax.set_xlim(-3, 4)\nax.set_ylim(-3, 4)\n\nplt.show()\n"
    },
    {
      "filename": "pick_event_demo.py",
      "title": "Pick Event Demo",
      "code": "\"\"\"\n===============\nPick event demo\n===============\n\nYou can enable picking by setting the \"picker\" property of an artist\n(for example, a Matplotlib Line2D, Text, Patch, Polygon, AxesImage,\netc.)\n\nThere are a variety of meanings of the picker property:\n\n* *None* - picking is disabled for this artist (default)\n\n* bool - if *True* then picking will be enabled and the artist will fire a pick\n  event if the mouse event is over the artist.\n\n  Setting ``pickradius`` will add an epsilon tolerance in points and the artist\n  will fire off an event if its data is within epsilon of the mouse event.  For\n  some artists like lines and patch collections, the artist may provide\n  additional data to the pick event that is generated, for example, the indices\n  of the data within epsilon of the pick event\n\n* function - if picker is callable, it is a user supplied function which\n  determines whether the artist is hit by the mouse event. ::\n\n     hit, props = picker(artist, mouseevent)\n\n  to determine the hit test.  If the mouse event is over the artist, return\n  hit=True and props is a dictionary of properties you want added to the\n  PickEvent attributes.\n\nAfter you have enabled an artist for picking by setting the \"picker\"\nproperty, you need to connect to the figure canvas pick_event to get\npick callbacks on mouse press events.  For example, ::\n\n  def pick_handler(event):\n      mouseevent = event.mouseevent\n      artist = event.artist\n      # now do something with this...\n\n\nThe pick event (matplotlib.backend_bases.PickEvent) which is passed to\nyour callback is always fired with two attributes:\n\nmouseevent\n  the mouse event that generate the pick event.\n\n  The mouse event in turn has attributes like x and y (the coordinates in\n  display space, such as pixels from left, bottom) and xdata, ydata (the\n  coords in data space).  Additionally, you can get information about\n  which buttons were pressed, which keys were pressed, which Axes\n  the mouse is over, etc.  See matplotlib.backend_bases.MouseEvent\n  for details.\n\nartist\n  the matplotlib.artist that generated the pick event.\n\nAdditionally, certain artists like Line2D and PatchCollection may\nattach additional metadata like the indices into the data that meet\nthe picker criteria (for example, all the points in the line that are within\nthe specified epsilon tolerance)\n\nThe examples below illustrate each of these methods.\n\n.. note::\n    These examples exercises the interactive capabilities of Matplotlib, and\n    this will not appear in the static documentation. Please run this code on\n    your machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import rand\n\nfrom matplotlib.image import AxesImage\nfrom matplotlib.lines import Line2D\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# %%\n# Simple picking, lines, rectangles and text\n# ------------------------------------------\n\nfig, (ax1, ax2) = plt.subplots(2, 1)\nax1.set_title('click on points, rectangles or text', picker=True)\nax1.set_ylabel('ylabel', picker=True, bbox=dict(facecolor='red'))\nline, = ax1.plot(rand(100), 'o', picker=True, pickradius=5)\n\n# Pick the rectangle.\nax2.bar(range(10), rand(10), picker=True)\nfor label in ax2.get_xticklabels():  # Make the xtick labels pickable.\n    label.set_picker(True)\n\n\ndef onpick1(event):\n    if isinstance(event.artist, Line2D):\n        thisline = event.artist\n        xdata = thisline.get_xdata()\n        ydata = thisline.get_ydata()\n        ind = event.ind\n        print('onpick1 line:', np.column_stack([xdata[ind], ydata[ind]]))\n    elif isinstance(event.artist, Rectangle):\n        patch = event.artist\n        print('onpick1 patch:', patch.get_path())\n    elif isinstance(event.artist, Text):\n        text = event.artist\n        print('onpick1 text:', text.get_text())\n\n\nfig.canvas.mpl_connect('pick_event', onpick1)\n\n\n# %%\n# Picking with a custom hit test function\n# ---------------------------------------\n# You can define custom pickers by setting picker to a callable function. The\n# function has the signature::\n#\n#  hit, props = func(artist, mouseevent)\n#\n# to determine the hit test. If the mouse event is over the artist, return\n# ``hit=True`` and ``props`` is a dictionary of properties you want added to\n# the `.PickEvent` attributes.\n\ndef line_picker(line, mouseevent):\n    \"\"\"\n    Find the points within a certain distance from the mouseclick in\n    data coords and attach some extra attributes, pickx and picky\n    which are the data points that were picked.\n    \"\"\"\n    if mouseevent.xdata is None:\n        return False, dict()\n    xdata = line.get_xdata()\n    ydata = line.get_ydata()\n    maxd = 0.05\n    d = np.sqrt(\n        (xdata - mouseevent.xdata)**2 + (ydata - mouseevent.ydata)**2)\n\n    ind, = np.nonzero(d <= maxd)\n    if len(ind):\n        pickx = xdata[ind]\n        picky = ydata[ind]\n        props = dict(ind=ind, pickx=pickx, picky=picky)\n        return True, props\n    else:\n        return False, dict()\n\n\ndef onpick2(event):\n    print('onpick2 line:', event.pickx, event.picky)\n\n\nfig, ax = plt.subplots()\nax.set_title('custom picker for line data')\nline, = ax.plot(rand(100), rand(100), 'o', picker=line_picker)\nfig.canvas.mpl_connect('pick_event', onpick2)\n\n\n# %%\n# Picking on a scatter plot\n# -------------------------\n# A scatter plot is backed by a `~matplotlib.collections.PathCollection`.\n\nx, y, c, s = rand(4, 100)\n\n\ndef onpick3(event):\n    ind = event.ind\n    print('onpick3 scatter:', ind, x[ind], y[ind])\n\n\nfig, ax = plt.subplots()\nax.scatter(x, y, 100*s, c, picker=True)\nfig.canvas.mpl_connect('pick_event', onpick3)\n\n\n# %%\n# Picking images\n# --------------\n# Images plotted using `.Axes.imshow` are `~matplotlib.image.AxesImage`\n# objects.\n\nfig, ax = plt.subplots()\nax.imshow(rand(10, 5), extent=(1, 2, 1, 2), picker=True)\nax.imshow(rand(5, 10), extent=(3, 4, 1, 2), picker=True)\nax.imshow(rand(20, 25), extent=(1, 2, 3, 4), picker=True)\nax.imshow(rand(30, 12), extent=(3, 4, 3, 4), picker=True)\nax.set(xlim=(0, 5), ylim=(0, 5))\n\n\ndef onpick4(event):\n    artist = event.artist\n    if isinstance(artist, AxesImage):\n        im = artist\n        A = im.get_array()\n        print('onpick4 image', A.shape)\n\n\nfig.canvas.mpl_connect('pick_event', onpick4)\n\nplt.show()\n"
    },
    {
      "filename": "pick_event_demo2.py",
      "title": "Pick Event Demo2",
      "code": "\"\"\"\n=================\nPick event demo 2\n=================\n\nCompute the mean (mu) and standard deviation (sigma) of 100 data sets and plot\nmu vs. sigma.  When you click on one of the (mu, sigma) points, plot the raw\ndata from the dataset that generated this point.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nX = np.random.rand(100, 1000)\nxs = np.mean(X, axis=1)\nys = np.std(X, axis=1)\n\nfig, ax = plt.subplots()\nax.set_title('click on point to plot time series')\nline, = ax.plot(xs, ys, 'o', picker=True, pickradius=5)\n\n\ndef onpick(event):\n\n    if event.artist != line:\n        return\n\n    N = len(event.ind)\n    if not N:\n        return\n\n    figi, axs = plt.subplots(N, squeeze=False)\n    for ax, dataind in zip(axs.flat, event.ind):\n        ax.plot(X[dataind])\n        ax.text(.05, .9, f'mu={xs[dataind]:1.3f}\\nsigma={ys[dataind]:1.3f}',\n                transform=ax.transAxes, va='top')\n        ax.set_ylim(-0.5, 1.5)\n    figi.show()\n\n\nfig.canvas.mpl_connect('pick_event', onpick)\n\nplt.show()\n"
    },
    {
      "filename": "poly_editor.py",
      "title": "Poly Editor",
      "code": "\"\"\"\n==============\nPolygon editor\n==============\n\nThis is an example to show how to build cross-GUI applications using\nMatplotlib event handling to interact with objects on the canvas.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport numpy as np\n\nfrom matplotlib.artist import Artist\nfrom matplotlib.lines import Line2D\n\n\ndef dist_point_to_segment(p, s0, s1):\n    \"\"\"\n    Get the distance from the point *p* to the segment (*s0*, *s1*), where\n    *p*, *s0*, *s1* are ``[x, y]`` arrays.\n    \"\"\"\n    s01 = s1 - s0\n    s0p = p - s0\n    if (s01 == 0).all():\n        return np.hypot(*s0p)\n    # Project onto segment, without going past segment ends.\n    p1 = s0 + np.clip((s0p @ s01) / (s01 @ s01), 0, 1) * s01\n    return np.hypot(*(p - p1))\n\n\nclass PolygonInteractor:\n    \"\"\"\n    A polygon editor.\n\n    Key-bindings\n\n      't' toggle vertex markers on and off.  When vertex markers are on,\n          you can move them, delete them\n\n      'd' delete the vertex under point\n\n      'i' insert a vertex at point.  You must be within epsilon of the\n          line connecting two existing vertices\n\n    \"\"\"\n\n    showverts = True\n    epsilon = 5  # max pixel distance to count as a vertex hit\n\n    def __init__(self, ax, poly):\n        if poly.figure is None:\n            raise RuntimeError('You must first add the polygon to a figure '\n                               'or canvas before defining the interactor')\n        self.ax = ax\n        canvas = poly.figure.canvas\n        self.poly = poly\n\n        x, y = zip(*self.poly.xy)\n        self.line = Line2D(x, y,\n                           marker='o', markerfacecolor='r',\n                           animated=True)\n        self.ax.add_line(self.line)\n\n        self.cid = self.poly.add_callback(self.poly_changed)\n        self._ind = None  # the active vert\n\n        canvas.mpl_connect('draw_event', self.on_draw)\n        canvas.mpl_connect('button_press_event', self.on_button_press)\n        canvas.mpl_connect('key_press_event', self.on_key_press)\n        canvas.mpl_connect('button_release_event', self.on_button_release)\n        canvas.mpl_connect('motion_notify_event', self.on_mouse_move)\n        self.canvas = canvas\n\n    def on_draw(self, event):\n        self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n        self.ax.draw_artist(self.poly)\n        self.ax.draw_artist(self.line)\n        # do not need to blit here, this will fire before the screen is\n        # updated\n\n    def poly_changed(self, poly):\n        \"\"\"This method is called whenever the pathpatch object is called.\"\"\"\n        # only copy the artist props to the line (except visibility)\n        vis = self.line.get_visible()\n        Artist.update_from(self.line, poly)\n        self.line.set_visible(vis)  # don't use the poly visibility state\n\n    def get_ind_under_point(self, event):\n        \"\"\"\n        Return the index of the point closest to the event position or *None*\n        if no point is within ``self.epsilon`` to the event position.\n        \"\"\"\n        # display coords\n        xy = np.asarray(self.poly.xy)\n        xyt = self.poly.get_transform().transform(xy)\n        xt, yt = xyt[:, 0], xyt[:, 1]\n        d = np.hypot(xt - event.x, yt - event.y)\n        indseq, = np.nonzero(d == d.min())\n        ind = indseq[0]\n\n        if d[ind] >= self.epsilon:\n            ind = None\n\n        return ind\n\n    def on_button_press(self, event):\n        \"\"\"Callback for mouse button presses.\"\"\"\n        if not self.showverts:\n            return\n        if event.inaxes is None:\n            return\n        if event.button != 1:\n            return\n        self._ind = self.get_ind_under_point(event)\n\n    def on_button_release(self, event):\n        \"\"\"Callback for mouse button releases.\"\"\"\n        if not self.showverts:\n            return\n        if event.button != 1:\n            return\n        self._ind = None\n\n    def on_key_press(self, event):\n        \"\"\"Callback for key presses.\"\"\"\n        if not event.inaxes:\n            return\n        if event.key == 't':\n            self.showverts = not self.showverts\n            self.line.set_visible(self.showverts)\n            if not self.showverts:\n                self._ind = None\n        elif event.key == 'd':\n            ind = self.get_ind_under_point(event)\n            if ind is not None:\n                self.poly.xy = np.delete(self.poly.xy,\n                                         ind, axis=0)\n                self.line.set_data(zip(*self.poly.xy))\n        elif event.key == 'i':\n            xys = self.poly.get_transform().transform(self.poly.xy)\n            p = event.x, event.y  # display coords\n            for i in range(len(xys) - 1):\n                s0 = xys[i]\n                s1 = xys[i + 1]\n                d = dist_point_to_segment(p, s0, s1)\n                if d <= self.epsilon:\n                    self.poly.xy = np.insert(\n                        self.poly.xy, i+1,\n                        [event.xdata, event.ydata],\n                        axis=0)\n                    self.line.set_data(zip(*self.poly.xy))\n                    break\n        if self.line.stale:\n            self.canvas.draw_idle()\n\n    def on_mouse_move(self, event):\n        \"\"\"Callback for mouse movements.\"\"\"\n        if not self.showverts:\n            return\n        if self._ind is None:\n            return\n        if event.inaxes is None:\n            return\n        if event.button != 1:\n            return\n        x, y = event.xdata, event.ydata\n\n        self.poly.xy[self._ind] = x, y\n        if self._ind == 0:\n            self.poly.xy[-1] = x, y\n        elif self._ind == len(self.poly.xy) - 1:\n            self.poly.xy[0] = x, y\n        self.line.set_data(zip(*self.poly.xy))\n\n        self.canvas.restore_region(self.background)\n        self.ax.draw_artist(self.poly)\n        self.ax.draw_artist(self.line)\n        self.canvas.blit(self.ax.bbox)\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    from matplotlib.patches import Polygon\n\n    theta = np.arange(0, 2*np.pi, 0.1)\n    r = 1.5\n\n    xs = r * np.cos(theta)\n    ys = r * np.sin(theta)\n\n    poly = Polygon(np.column_stack([xs, ys]), animated=True)\n\n    fig, ax = plt.subplots()\n    ax.add_patch(poly)\n    p = PolygonInteractor(ax, poly)\n\n    ax.set_title('Click and drag a point to move it')\n    ax.set_xlim((-2, 2))\n    ax.set_ylim((-2, 2))\n    plt.show()\n"
    },
    {
      "filename": "pong_sgskip.py",
      "title": "Pong Sgskip",
      "code": "\"\"\"\n====\nPong\n====\n\nA Matplotlib based game of Pong illustrating one way to write interactive\nanimations that are easily ported to multiple backends.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import randint, randn\n\nfrom matplotlib.font_manager import FontProperties\n\ninstructions = \"\"\"\nPlayer A:       Player B:\n  'e'      up     'i'\n  'd'     down    'k'\n\npress 't' -- close these instructions\n            (animation will be much faster)\npress 'a' -- add a puck\npress 'A' -- remove a puck\npress '1' -- slow down all pucks\npress '2' -- speed up all pucks\npress '3' -- slow down distractors\npress '4' -- speed up distractors\npress ' ' -- reset the first puck\npress 'n' -- toggle distractors on/off\npress 'g' -- toggle the game on/off\n\n  \"\"\"\n\n\nclass Pad:\n    def __init__(self, disp, x, y, type='l'):\n        self.disp = disp\n        self.x = x\n        self.y = y\n        self.w = .3\n        self.score = 0\n        self.xoffset = 0.3\n        self.yoffset = 0.1\n        if type == 'r':\n            self.xoffset *= -1.0\n\n        if type == 'l' or type == 'r':\n            self.signx = -1.0\n            self.signy = 1.0\n        else:\n            self.signx = 1.0\n            self.signy = -1.0\n\n    def contains(self, loc):\n        return self.disp.get_bbox().contains(loc.x, loc.y)\n\n\nclass Puck:\n    def __init__(self, disp, pad, field):\n        self.vmax = .2\n        self.disp = disp\n        self.field = field\n        self._reset(pad)\n\n    def _reset(self, pad):\n        self.x = pad.x + pad.xoffset\n        if pad.y < 0:\n            self.y = pad.y + pad.yoffset\n        else:\n            self.y = pad.y - pad.yoffset\n        self.vx = pad.x - self.x\n        self.vy = pad.y + pad.w/2 - self.y\n        self._speedlimit()\n        self._slower()\n        self._slower()\n\n    def update(self, pads):\n        self.x += self.vx\n        self.y += self.vy\n        for pad in pads:\n            if pad.contains(self):\n                self.vx *= 1.2 * pad.signx\n                self.vy *= 1.2 * pad.signy\n        fudge = .001\n        # probably cleaner with something like...\n        if self.x < fudge:\n            pads[1].score += 1\n            self._reset(pads[0])\n            return True\n        if self.x > 7 - fudge:\n            pads[0].score += 1\n            self._reset(pads[1])\n            return True\n        if self.y < -1 + fudge or self.y > 1 - fudge:\n            self.vy *= -1.0\n            # add some randomness, just to make it interesting\n            self.vy -= (randn()/300.0 + 1/300.0) * np.sign(self.vy)\n        self._speedlimit()\n        return False\n\n    def _slower(self):\n        self.vx /= 5.0\n        self.vy /= 5.0\n\n    def _faster(self):\n        self.vx *= 5.0\n        self.vy *= 5.0\n\n    def _speedlimit(self):\n        if self.vx > self.vmax:\n            self.vx = self.vmax\n        if self.vx < -self.vmax:\n            self.vx = -self.vmax\n\n        if self.vy > self.vmax:\n            self.vy = self.vmax\n        if self.vy < -self.vmax:\n            self.vy = -self.vmax\n\n\nclass Game:\n    def __init__(self, ax):\n        # create the initial line\n        self.ax = ax\n        ax.xaxis.set_visible(False)\n        ax.set_xlim([0, 7])\n        ax.yaxis.set_visible(False)\n        ax.set_ylim([-1, 1])\n        pad_a_x = 0\n        pad_b_x = .50\n        pad_a_y = pad_b_y = .30\n        pad_b_x += 6.3\n\n        # pads\n        pA, = self.ax.barh(pad_a_y, .2,\n                           height=.3, color='k', alpha=.5, edgecolor='b',\n                           lw=2, label=\"Player B\",\n                           animated=True)\n        pB, = self.ax.barh(pad_b_y, .2,\n                           height=.3, left=pad_b_x, color='k', alpha=.5,\n                           edgecolor='r', lw=2, label=\"Player A\",\n                           animated=True)\n\n        # distractors\n        self.x = np.arange(0, 2.22*np.pi, 0.01)\n        self.line, = self.ax.plot(self.x, np.sin(self.x), \"r\",\n                                  animated=True, lw=4)\n        self.line2, = self.ax.plot(self.x, np.cos(self.x), \"g\",\n                                   animated=True, lw=4)\n        self.line3, = self.ax.plot(self.x, np.cos(self.x), \"g\",\n                                   animated=True, lw=4)\n        self.line4, = self.ax.plot(self.x, np.cos(self.x), \"r\",\n                                   animated=True, lw=4)\n\n        # center line\n        self.centerline, = self.ax.plot([3.5, 3.5], [1, -1], 'k',\n                                        alpha=.5, animated=True, lw=8)\n\n        # puck (s)\n        self.puckdisp = self.ax.scatter([1], [1], label='_nolegend_',\n                                        s=200, c='g',\n                                        alpha=.9, animated=True)\n\n        self.canvas = self.ax.figure.canvas\n        self.background = None\n        self.cnt = 0\n        self.distract = True\n        self.res = 100.0\n        self.on = False\n        self.inst = True    # show instructions from the beginning\n        self.pads = [Pad(pA, pad_a_x, pad_a_y),\n                     Pad(pB, pad_b_x, pad_b_y, 'r')]\n        self.pucks = []\n        self.i = self.ax.annotate(instructions, (.5, 0.5),\n                                  name='monospace',\n                                  verticalalignment='center',\n                                  horizontalalignment='center',\n                                  multialignment='left',\n                                  xycoords='axes fraction',\n                                  animated=False)\n        self.canvas.mpl_connect('key_press_event', self.on_key_press)\n\n    def draw(self):\n        draw_artist = self.ax.draw_artist\n        if self.background is None:\n            self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n\n        # restore the clean slate background\n        self.canvas.restore_region(self.background)\n\n        # show the distractors\n        if self.distract:\n            self.line.set_ydata(np.sin(self.x + self.cnt/self.res))\n            self.line2.set_ydata(np.cos(self.x - self.cnt/self.res))\n            self.line3.set_ydata(np.tan(self.x + self.cnt/self.res))\n            self.line4.set_ydata(np.tan(self.x - self.cnt/self.res))\n            draw_artist(self.line)\n            draw_artist(self.line2)\n            draw_artist(self.line3)\n            draw_artist(self.line4)\n\n        # pucks and pads\n        if self.on:\n            self.ax.draw_artist(self.centerline)\n            for pad in self.pads:\n                pad.disp.set_y(pad.y)\n                pad.disp.set_x(pad.x)\n                self.ax.draw_artist(pad.disp)\n\n            for puck in self.pucks:\n                if puck.update(self.pads):\n                    # we only get here if someone scored\n                    self.pads[0].disp.set_label(f\"   {self.pads[0].score}\")\n                    self.pads[1].disp.set_label(f\"   {self.pads[1].score}\")\n                    self.ax.legend(loc='center', framealpha=.2,\n                                   facecolor='0.5',\n                                   prop=FontProperties(size='xx-large',\n                                                       weight='bold'))\n\n                    self.background = None\n                    self.ax.figure.canvas.draw_idle()\n                    return\n                puck.disp.set_offsets([[puck.x, puck.y]])\n                self.ax.draw_artist(puck.disp)\n\n        # just redraw the Axes rectangle\n        self.canvas.blit(self.ax.bbox)\n        self.canvas.flush_events()\n        if self.cnt == 50000:\n            # just so we don't get carried away\n            print(\"...and you've been playing for too long!!!\")\n            plt.close()\n\n        self.cnt += 1\n\n    def on_key_press(self, event):\n        if event.key == '3':\n            self.res *= 5.0\n        if event.key == '4':\n            self.res /= 5.0\n\n        if event.key == 'e':\n            self.pads[0].y += .1\n            if self.pads[0].y > 1 - .3:\n                self.pads[0].y = 1 - .3\n        if event.key == 'd':\n            self.pads[0].y -= .1\n            if self.pads[0].y < -1:\n                self.pads[0].y = -1\n\n        if event.key == 'i':\n            self.pads[1].y += .1\n            if self.pads[1].y > 1 - .3:\n                self.pads[1].y = 1 - .3\n        if event.key == 'k':\n            self.pads[1].y -= .1\n            if self.pads[1].y < -1:\n                self.pads[1].y = -1\n\n        if event.key == 'a':\n            self.pucks.append(Puck(self.puckdisp,\n                                   self.pads[randint(2)],\n                                   self.ax.bbox))\n        if event.key == 'A' and len(self.pucks):\n            self.pucks.pop()\n        if event.key == ' ' and len(self.pucks):\n            self.pucks[0]._reset(self.pads[randint(2)])\n        if event.key == '1':\n            for p in self.pucks:\n                p._slower()\n        if event.key == '2':\n            for p in self.pucks:\n                p._faster()\n\n        if event.key == 'n':\n            self.distract = not self.distract\n\n        if event.key == 'g':\n            self.on = not self.on\n        if event.key == 't':\n            self.inst = not self.inst\n            self.i.set_visible(not self.i.get_visible())\n            self.background = None\n            self.canvas.draw_idle()\n        if event.key == 'q':\n            plt.close()\n\n\nfig, ax = plt.subplots()\ncanvas = ax.figure.canvas\nanimation = Game(ax)\n\n# disable the default key bindings\nif fig.canvas.manager.key_press_handler_id is not None:\n    canvas.mpl_disconnect(fig.canvas.manager.key_press_handler_id)\n\n\n# reset the blitting background on redraw\ndef on_redraw(event):\n    animation.background = None\n\n\n# bootstrap after the first draw\ndef start_anim(event):\n    canvas.mpl_disconnect(start_anim.cid)\n\n    start_anim.timer.add_callback(animation.draw)\n    start_anim.timer.start()\n    canvas.mpl_connect('draw_event', on_redraw)\n\n\nstart_anim.cid = canvas.mpl_connect('draw_event', start_anim)\nstart_anim.timer = animation.canvas.new_timer(interval=1)\n\ntstart = time.time()\n\nplt.show()\nprint('FPS: %f' % (animation.cnt/(time.time() - tstart)))\n"
    },
    {
      "filename": "resample.py",
      "title": "Resample",
      "code": "\"\"\"\n===============\nResampling Data\n===============\n\nDownsampling lowers the sample rate or sample size of a signal. In\nthis tutorial, the signal is downsampled when the plot is adjusted\nthrough dragging and zooming.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# A class that will downsample the data and recompute when zoomed.\nclass DataDisplayDownsampler:\n    def __init__(self, xdata, y1data, y2data):\n        self.origY1Data = y1data\n        self.origY2Data = y2data\n        self.origXData = xdata\n        self.max_points = 50\n        self.delta = xdata[-1] - xdata[0]\n\n    def plot(self, ax):\n        x, y1, y2 = self._downsample(self.origXData.min(), self.origXData.max())\n        (self.line,) = ax.plot(x, y1, 'o-')\n        self.poly_collection = ax.fill_between(x, y1, y2, step=\"pre\", color=\"r\")\n\n    def _downsample(self, xstart, xend):\n        # get the points in the view range\n        mask = (self.origXData > xstart) & (self.origXData < xend)\n        # dilate the mask by one to catch the points just outside\n        # of the view range to not truncate the line\n        mask = np.convolve([1, 1, 1], mask, mode='same').astype(bool)\n        # sort out how many points to drop\n        ratio = max(np.sum(mask) // self.max_points, 1)\n\n        # mask data\n        xdata = self.origXData[mask]\n        y1data = self.origY1Data[mask]\n        y2data = self.origY2Data[mask]\n\n        # downsample data\n        xdata = xdata[::ratio]\n        y1data = y1data[::ratio]\n        y2data = y2data[::ratio]\n\n        print(f\"using {len(y1data)} of {np.sum(mask)} visible points\")\n\n        return xdata, y1data, y2data\n\n    def update(self, ax):\n        # Update the artists\n        lims = ax.viewLim\n        if abs(lims.width - self.delta) > 1e-8:\n            self.delta = lims.width\n            xstart, xend = lims.intervalx\n            x, y1, y2 = self._downsample(xstart, xend)\n            self.line.set_data(x, y1)\n            self.poly_collection.set_data(x, y1, y2, step=\"pre\")\n            ax.figure.canvas.draw_idle()\n\n\n# Create a signal\nxdata = np.linspace(16, 365, (365-16)*4)\ny1data = np.sin(2*np.pi*xdata/153) + np.cos(2*np.pi*xdata/127)\ny2data = y1data + .2\n\nd = DataDisplayDownsampler(xdata, y1data, y2data)\n\nfig, ax = plt.subplots()\n\n# Hook up the line\nd.plot(ax)\nax.set_autoscale_on(False)  # Otherwise, infinite loop\n\n# Connect for changing the view limits\nax.callbacks.connect('xlim_changed', d.update)\nax.set_xlim(16, 365)\nplt.show()\n\n# %%\n# .. tags:: interactivity: zoom, event-handling\n"
    },
    {
      "filename": "timers.py",
      "title": "Timers",
      "code": "\"\"\"\n======\nTimers\n======\n\nSimple example of using general timer objects. This is used to update\nthe time placed in the title of the figure.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\nfrom datetime import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef update_title(axes):\n    axes.set_title(datetime.now())\n    axes.figure.canvas.draw()\n\nfig, ax = plt.subplots()\n\nx = np.linspace(-3, 3)\nax.plot(x, x ** 2)\n\n# Create a new timer object. Set the interval to 100 milliseconds\n# (1000 is default) and tell the timer what function should be called.\ntimer = fig.canvas.new_timer(interval=100)\ntimer.add_callback(update_title, ax)\ntimer.start()\n\n# Or could start the timer on first figure draw:\n# def start_timer(event):\n#     timer.start()\n#     fig.canvas.mpl_disconnect(drawid)\n# drawid = fig.canvas.mpl_connect('draw_event', start_timer)\n\nplt.show()\n"
    },
    {
      "filename": "trifinder_event_demo.py",
      "title": "Trifinder Event Demo",
      "code": "\"\"\"\n====================\nTrifinder Event Demo\n====================\n\nExample showing the use of a TriFinder object.  As the mouse is moved over the\ntriangulation, the triangle under the cursor is highlighted and the index of\nthe triangle is displayed in the plot title.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\nfrom matplotlib.tri import Triangulation\n\n\ndef update_polygon(tri):\n    if tri == -1:\n        points = [0, 0, 0]\n    else:\n        points = triang.triangles[tri]\n    xs = triang.x[points]\n    ys = triang.y[points]\n    polygon.set_xy(np.column_stack([xs, ys]))\n\n\ndef on_mouse_move(event):\n    if event.inaxes is None:\n        tri = -1\n    else:\n        tri = trifinder(event.xdata, event.ydata)\n    update_polygon(tri)\n    ax.set_title(f'In triangle {tri}')\n    event.canvas.draw()\n\n\n# Create a Triangulation.\nn_angles = 16\nn_radii = 5\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\ntriang = Triangulation(x, y)\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# Use the triangulation's default TriFinder object.\ntrifinder = triang.get_trifinder()\n\n# Setup plot and callbacks.\nfig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})\nax.triplot(triang, 'bo-')\npolygon = Polygon([[0, 0], [0, 0]], facecolor='y')  # dummy data for (xs, ys)\nupdate_polygon(-1)\nax.add_patch(polygon)\nfig.canvas.mpl_connect('motion_notify_event', on_mouse_move)\nplt.show()\n"
    },
    {
      "filename": "viewlims.py",
      "title": "Viewlims",
      "code": "\"\"\"\n========\nViewlims\n========\n\nCreates two identical panels.  Zooming in on the right panel will show\na rectangle in the first panel, denoting the zoomed region.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport functools\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Rectangle\n\n\n# A class that will regenerate a fractal set as we zoom in, so that you\n# can actually see the increasing detail.  A box in the left panel will show\n# the area to which we are zoomed.\nclass MandelbrotDisplay:\n    def __init__(self, h=500, w=500, niter=50, radius=2., power=2):\n        self.height = h\n        self.width = w\n        self.niter = niter\n        self.radius = radius\n        self.power = power\n\n    def compute_image(self, xlim, ylim):\n        self.x = np.linspace(*xlim, self.width)\n        self.y = np.linspace(*ylim, self.height).reshape(-1, 1)\n        c = self.x + 1.0j * self.y\n        threshold_time = np.zeros((self.height, self.width))\n        z = np.zeros(threshold_time.shape, dtype=complex)\n        mask = np.ones(threshold_time.shape, dtype=bool)\n        for i in range(self.niter):\n            z[mask] = z[mask]**self.power + c[mask]\n            mask = (np.abs(z) < self.radius)\n            threshold_time += mask\n        return threshold_time\n\n    def ax_update(self, ax):\n        ax.set_autoscale_on(False)  # Otherwise, infinite loop\n        # Get the number of points from the number of pixels in the window\n        self.width, self.height = ax.patch.get_window_extent().size.round().astype(int)\n        # Update the image object with our new data and extent\n        ax.images[-1].set(data=self.compute_image(ax.get_xlim(), ax.get_ylim()),\n                          extent=(*ax.get_xlim(), *ax.get_ylim()))\n        ax.figure.canvas.draw_idle()\n\n\nmd = MandelbrotDisplay()\n\nfig1, (ax_full, ax_zoom) = plt.subplots(1, 2)\nax_zoom.imshow([[0]], origin=\"lower\")  # Empty initial image.\nax_zoom.set_title(\"Zoom here\")\n\nrect = Rectangle(\n    [0, 0], 0, 0, facecolor=\"none\", edgecolor=\"black\", linewidth=1.0)\nax_full.add_patch(rect)\n\n\ndef update_rect(rect, ax):  # Let the rectangle track the bounds of the zoom axes.\n    xlo, xhi = ax.get_xlim()\n    ylo, yhi = ax.get_ylim()\n    rect.set_bounds((xlo, ylo, xhi - xlo, yhi - ylo))\n    ax.figure.canvas.draw_idle()\n\n\n# Connect for changing the view limits.\nax_zoom.callbacks.connect(\"xlim_changed\", functools.partial(update_rect, rect))\nax_zoom.callbacks.connect(\"ylim_changed\", functools.partial(update_rect, rect))\n\nax_zoom.callbacks.connect(\"xlim_changed\", md.ax_update)\nax_zoom.callbacks.connect(\"ylim_changed\", md.ax_update)\n\n# Initialize: trigger image computation by setting view limits; set colormap limits;\n# copy image to full view.\nax_zoom.set(xlim=(-2, .5), ylim=(-1.25, 1.25))\nim = ax_zoom.images[0]\nax_zoom.images[0].set(clim=(im.get_array().min(), im.get_array().max()))\nax_full.imshow(im.get_array(), extent=im.get_extent(), origin=\"lower\")\n\nplt.show()\n"
    },
    {
      "filename": "zoom_window.py",
      "title": "Zoom Window",
      "code": "\"\"\"\n========================\nZoom modifies other Axes\n========================\n\nThis example shows how to connect events in one window, for example, a mouse\npress, to another figure window.\n\nIf you click on a point in the first window, the z and y limits of the second\nwill be adjusted so that the center of the zoom in the second window will be\nthe (x, y) coordinates of the clicked point.\n\nNote the diameter of the circles in the scatter are defined in points**2, so\ntheir size is independent of the zoom.\n\n.. note::\n    This example exercises the interactive capabilities of Matplotlib, and this\n    will not appear in the static documentation. Please run this code on your\n    machine to see the interactivity.\n\n    You can copy and paste individual parts, or download the entire example\n    using the link at the bottom of the page.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfigsrc, axsrc = plt.subplots(figsize=(3.7, 3.7))\nfigzoom, axzoom = plt.subplots(figsize=(3.7, 3.7))\naxsrc.set(xlim=(0, 1), ylim=(0, 1), autoscale_on=False,\n          title='Click to zoom')\naxzoom.set(xlim=(0.45, 0.55), ylim=(0.4, 0.6), autoscale_on=False,\n           title='Zoom window')\n\nx, y, s, c = np.random.rand(4, 200)\ns *= 200\n\naxsrc.scatter(x, y, s, c)\naxzoom.scatter(x, y, s, c)\n\n\ndef on_press(event):\n    if event.button != 1:\n        return\n    x, y = event.xdata, event.ydata\n    axzoom.set_xlim(x - 0.1, x + 0.1)\n    axzoom.set_ylim(y - 0.1, y + 0.1)\n    figzoom.canvas.draw()\n\nfigsrc.canvas.mpl_connect('button_press_event', on_press)\nplt.show()\n"
    }
  ],
  "images_contours_and_fields": [
    {
      "filename": "affine_image.py",
      "title": "Affine Image",
      "code": "\"\"\"\n============================\nAffine transform of an image\n============================\n\n\nPrepending an affine transformation (`~.transforms.Affine2D`) to the :ref:`data\ntransform <data-coords>` of an image allows to manipulate the image's shape and\norientation.  This is an example of the concept of :ref:`transform chaining\n<transformation-pipeline>`.\n\nThe image of the output should have its boundary match the dashed yellow\nrectangle.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.transforms as mtransforms\n\n\ndef get_image():\n    delta = 0.25\n    x = y = np.arange(-3.0, 3.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2)\n    return Z\n\n\ndef do_plot(ax, Z, transform):\n    im = ax.imshow(Z, interpolation='none',\n                   origin='lower',\n                   extent=[-2, 4, -3, 2], clip_on=True)\n\n    trans_data = transform + ax.transData\n    im.set_transform(trans_data)\n\n    # display intended extent of the image\n    x1, x2, y1, y2 = im.get_extent()\n    ax.plot([x1, x2, x2, x1, x1], [y1, y1, y2, y2, y1], \"y--\",\n            transform=trans_data)\n    ax.set_xlim(-5, 5)\n    ax.set_ylim(-4, 4)\n\n\n# prepare image and figure\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nZ = get_image()\n\n# image rotation\ndo_plot(ax1, Z, mtransforms.Affine2D().rotate_deg(30))\n\n# image skew\ndo_plot(ax2, Z, mtransforms.Affine2D().skew_deg(30, 15))\n\n# scale and reflection\ndo_plot(ax3, Z, mtransforms.Affine2D().scale(-1, .5))\n\n# everything and a translation\ndo_plot(ax4, Z, mtransforms.Affine2D().\n        rotate_deg(30).skew_deg(30, 15).scale(-1, .5).translate(.5, -1))\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.transforms.Affine2D`\n"
    },
    {
      "filename": "barb_demo.py",
      "title": "Barb Demo",
      "code": "\"\"\"\n==========\nWind barbs\n==========\n\nDemonstration of wind barb plots.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-5, 5, 5)\nX, Y = np.meshgrid(x, x)\nU, V = 12 * X, 12 * Y\n\ndata = [(-1.5, .5, -6, -6),\n        (1, -1, -46, 46),\n        (-3, -1, 11, -11),\n        (1, 1.5, 80, 80),\n        (0.5, 0.25, 25, 15),\n        (-1.5, -0.5, -5, 40)]\n\ndata = np.array(data, dtype=[('x', np.float32), ('y', np.float32),\n                             ('u', np.float32), ('v', np.float32)])\n\nfig1, axs1 = plt.subplots(nrows=2, ncols=2)\n# Default parameters, uniform grid\naxs1[0, 0].barbs(X, Y, U, V)\n\n# Arbitrary set of vectors, make them longer and change the pivot point\n# (point around which they're rotated) to be the middle\naxs1[0, 1].barbs(\n    data['x'], data['y'], data['u'], data['v'], length=8, pivot='middle')\n\n# Showing colormapping with uniform grid.  Fill the circle for an empty barb,\n# don't round the values, and change some of the size parameters\naxs1[1, 0].barbs(\n    X, Y, U, V, np.sqrt(U ** 2 + V ** 2), fill_empty=True, rounding=False,\n    sizes=dict(emptybarb=0.25, spacing=0.2, height=0.3))\n\n# Change colors as well as the increments for parts of the barbs\naxs1[1, 1].barbs(data['x'], data['y'], data['u'], data['v'], flagcolor='r',\n                 barbcolor=['b', 'g'], flip_barb=True,\n                 barb_increments=dict(half=10, full=20, flag=100))\n\n# Masked arrays are also supported\nmasked_u = np.ma.masked_array(data['u'])\nmasked_u[4] = 1000  # Bad value that should not be plotted when masked\nmasked_u[4] = np.ma.masked\n\n# %%\n# Identical plot to panel 2 in the first figure, but with the point at\n# (0.5, 0.25) missing (masked)\nfig2, ax2 = plt.subplots()\nax2.barbs(data['x'], data['y'], masked_u, data['v'], length=8, pivot='middle')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.barbs` / `matplotlib.pyplot.barbs`\n"
    },
    {
      "filename": "barcode_demo.py",
      "title": "Barcode Demo",
      "code": "\"\"\"\n=======\nBarcode\n=======\nThis demo shows how to produce a bar code.\n\nThe figure size is calculated so that the width in pixels is a multiple of the\nnumber of data points to prevent interpolation artifacts. Additionally, the\n``Axes`` is defined to span the whole figure and all ``Axis`` are turned off.\n\nThe data itself is rendered with `~.Axes.imshow` using\n\n- ``code.reshape(1, -1)`` to turn the data into a 2D array with one row.\n- ``imshow(..., aspect='auto')`` to allow for non-square pixels.\n- ``imshow(..., interpolation='nearest')`` to prevent blurred edges. This\n  should not happen anyway because we fine-tuned the figure width in pixels,\n  but just to be safe.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncode = np.array([\n    1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1,\n    0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,\n    1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,\n    1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1])\n\npixel_per_bar = 4\ndpi = 100\n\nfig = plt.figure(figsize=(len(code) * pixel_per_bar / dpi, 2), dpi=dpi)\nax = fig.add_axes([0, 0, 1, 1])  # span the whole figure\nax.set_axis_off()\nax.imshow(code.reshape(1, -1), cmap='binary', aspect='auto',\n          interpolation='nearest')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.add_axes`\n"
    },
    {
      "filename": "colormap_interactive_adjustment.py",
      "title": "Colormap Interactive Adjustment",
      "code": "\"\"\"\n========================================\nInteractive adjustment of colormap range\n========================================\n\nDemonstration of how a colorbar can be used to interactively adjust the\nrange of colormapping on an image. To use the interactive feature, you must\nbe in either zoom mode (magnifying glass toolbar button) or\npan mode (4-way arrow toolbar button) and click inside the colorbar.\n\nWhen zooming, the bounding box of the zoom region defines the new vmin and\nvmax of the norm. Zooming using the right mouse button will expand the\nvmin and vmax proportionally to the selected region, in the same manner that\none can zoom out on an axis. When panning, the vmin and vmax of the norm are\nboth shifted according to the direction of movement. The\nHome/Back/Forward buttons can also be used to get back to a previous state.\n\n.. redirect-from:: /gallery/userdemo/colormap_interactive_adjustment\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 2 * np.pi, 1024)\ndata2d = np.sin(t)[:, np.newaxis] * np.cos(t)[np.newaxis, :]\n\nfig, ax = plt.subplots()\nim = ax.imshow(data2d)\nax.set_title('Pan on the colorbar to shift the color mapping\\n'\n             'Zoom on the colorbar to scale the color mapping')\n\nfig.colorbar(im, ax=ax, label='Interactive colorbar')\n\nplt.show()\n"
    },
    {
      "filename": "colormap_normalizations.py",
      "title": "Colormap Normalizations",
      "code": "\"\"\"\n=======================\nColormap normalizations\n=======================\n\nDemonstration of using norm to map colormaps onto data in non-linear ways.\n\n.. redirect-from:: /gallery/userdemo/colormap_normalizations\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n\nN = 100\n\n# %%\n# LogNorm\n# -------\n# This example data has a low hump with a spike coming out of its center. If plotted\n# using a linear colour scale, then only the spike will be visible. To see both hump and\n# spike, this requires the z/colour axis on a log scale.\n#\n# Instead of transforming the data with ``pcolor(log10(Z))``, the color mapping can be\n# made logarithmic using a `.LogNorm`.\n\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nZ = Z1 + 50 * Z2\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolor(X, Y, Z, cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='max', label='linear scaling')\n\npcm = ax[1].pcolor(X, Y, Z, cmap='PuBu_r', shading='nearest',\n                   norm=colors.LogNorm(vmin=Z.min(), vmax=Z.max()))\nfig.colorbar(pcm, ax=ax[1], extend='max', label='LogNorm')\n\n# %%\n# PowerNorm\n# ---------\n# This example data mixes a power-law trend in X with a rectified sine wave in Y. If\n# plotted using a linear colour scale, then the power-law trend in X partially obscures\n# the sine wave in Y.\n#\n# The power law can be removed using a `.PowerNorm`.\n\nX, Y = np.mgrid[0:3:complex(0, N), 0:2:complex(0, N)]\nZ = (1 + np.sin(Y * 10)) * X**2\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z, cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='max', label='linear scaling')\n\npcm = ax[1].pcolormesh(X, Y, Z, cmap='PuBu_r', shading='nearest',\n                       norm=colors.PowerNorm(gamma=0.5))\nfig.colorbar(pcm, ax=ax[1], extend='max', label='PowerNorm')\n\n# %%\n# SymLogNorm\n# ----------\n# This example data has two humps, one negative and one positive, The positive hump has\n# 5 times the amplitude of the negative. If plotted with a linear colour scale, then\n# the detail in the negative hump is obscured.\n#\n# Here we logarithmically scale the positive and negative data separately with\n# `.SymLogNorm`.\n#\n# Note that colorbar labels do not come out looking very good.\n\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (5 * Z1 - Z2) * 2\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z, cmap='RdBu_r', shading='nearest',\n                       vmin=-np.max(Z))\nfig.colorbar(pcm, ax=ax[0], extend='both', label='linear scaling')\n\npcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', shading='nearest',\n                       norm=colors.SymLogNorm(linthresh=0.015,\n                                              vmin=-10.0, vmax=10.0, base=10))\nfig.colorbar(pcm, ax=ax[1], extend='both', label='SymLogNorm')\n\n# %%\n# Custom Norm\n# -----------\n# Alternatively, the above example data can be scaled with a customized normalization.\n# This one normalizes the negative data differently from the positive.\n\n\n# Example of making your own norm.  Also see matplotlib.colors.\n# From Joe Kington: This one gives two different linear ramps:\nclass MidpointNormalize(colors.Normalize):\n    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n        self.midpoint = midpoint\n        super().__init__(vmin, vmax, clip)\n\n    def __call__(self, value, clip=None):\n        # I'm ignoring masked values and all kinds of edge cases to make a\n        # simple example...\n        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n        return np.ma.masked_array(np.interp(value, x, y))\n\n\n# %%\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z, cmap='RdBu_r', shading='nearest',\n                       vmin=-np.max(Z))\nfig.colorbar(pcm, ax=ax[0], extend='both', label='linear scaling')\n\npcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', shading='nearest',\n                       norm=MidpointNormalize(midpoint=0))\nfig.colorbar(pcm, ax=ax[1], extend='both', label='Custom norm')\n\n# %%\n# BoundaryNorm\n# ------------\n# For arbitrarily dividing the color scale, the `.BoundaryNorm` may be used; by\n# providing the boundaries for colors, this norm puts the first color in between the\n# first pair, the second color between the second pair, etc.\n\nfig, ax = plt.subplots(3, 1, layout='constrained')\n\npcm = ax[0].pcolormesh(X, Y, Z, cmap='RdBu_r', shading='nearest',\n                       vmin=-np.max(Z))\nfig.colorbar(pcm, ax=ax[0], extend='both', orientation='vertical',\n             label='linear scaling')\n\n# Evenly-spaced bounds gives a contour-like effect.\nbounds = np.linspace(-2, 2, 11)\nnorm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\npcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', shading='nearest',\n                       norm=norm)\nfig.colorbar(pcm, ax=ax[1], extend='both', orientation='vertical',\n             label='BoundaryNorm\\nlinspace(-2, 2, 11)')\n\n# Unevenly-spaced bounds changes the colormapping.\nbounds = np.array([-1, -0.5, 0, 2.5, 5])\nnorm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\npcm = ax[2].pcolormesh(X, Y, Z, cmap='RdBu_r', shading='nearest',\n                       norm=norm)\nfig.colorbar(pcm, ax=ax[2], extend='both', orientation='vertical',\n             label='BoundaryNorm\\n[-1, -0.5, 0, 2.5, 5]')\n\nplt.show()\n"
    },
    {
      "filename": "colormap_normalizations_symlognorm.py",
      "title": "Colormap Normalizations Symlognorm",
      "code": "\"\"\"\n==================================\nColormap normalizations SymLogNorm\n==================================\n\nDemonstration of using norm to map colormaps onto data in non-linear ways.\n\n.. redirect-from:: /gallery/userdemo/colormap_normalization_symlognorm\n\"\"\"\n\n# %%\n# Synthetic dataset consisting of two humps, one negative and one positive,\n# the positive with 8-times the amplitude.\n# Linearly, the negative hump is almost invisible,\n# and it is very difficult to see any detail of its profile.\n# With the logarithmic scaling applied to both positive and negative values,\n# it is much easier to see the shape of each hump.\n#\n# See `~.colors.SymLogNorm`.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n\n\ndef rbf(x, y):\n    return 1.0 / (1 + 5 * ((x ** 2) + (y ** 2)))\n\nN = 200\ngain = 8\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ1 = rbf(X + 0.5, Y + 0.5)\nZ2 = rbf(X - 0.5, Y - 0.5)\nZ = gain * Z1 - Z2\n\nshadeopts = {'cmap': 'PRGn', 'shading': 'gouraud'}\ncolormap = 'PRGn'\nlnrwidth = 0.5\n\nfig, ax = plt.subplots(2, 1, sharex=True, sharey=True)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=colors.SymLogNorm(linthresh=lnrwidth, linscale=1,\n                                              vmin=-gain, vmax=gain, base=10),\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[0], extend='both')\nax[0].text(-2.5, 1.5, 'symlog')\n\npcm = ax[1].pcolormesh(X, Y, Z, vmin=-gain, vmax=gain,\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[1], extend='both')\nax[1].text(-2.5, 1.5, 'linear')\n\n\n# %%\n# In order to find the best visualization for any particular dataset,\n# it may be necessary to experiment with multiple different color scales.\n# As well as the `~.colors.SymLogNorm` scaling, there is also\n# the option of using `~.colors.AsinhNorm` (experimental), which has a smoother\n# transition between the linear and logarithmic regions of the transformation\n# applied to the data values, \"Z\".\n# In the plots below, it may be possible to see contour-like artifacts\n# around each hump despite there being no sharp features\n# in the dataset itself. The ``asinh`` scaling shows a smoother shading\n# of each hump.\n\nfig, ax = plt.subplots(2, 1, sharex=True, sharey=True)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=colors.SymLogNorm(linthresh=lnrwidth, linscale=1,\n                                              vmin=-gain, vmax=gain, base=10),\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[0], extend='both')\nax[0].text(-2.5, 1.5, 'symlog')\n\npcm = ax[1].pcolormesh(X, Y, Z,\n                       norm=colors.AsinhNorm(linear_width=lnrwidth,\n                                             vmin=-gain, vmax=gain),\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[1], extend='both')\nax[1].text(-2.5, 1.5, 'asinh')\n\n\nplt.show()\n"
    },
    {
      "filename": "contour_corner_mask.py",
      "title": "Contour Corner Mask",
      "code": "\"\"\"\n===================\nContour corner mask\n===================\n\nIllustrate the difference between ``corner_mask=False`` and\n``corner_mask=True`` for masked contour plots.  The default is controlled by\n:rc:`contour.corner_mask`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Data to plot.\nx, y = np.meshgrid(np.arange(7), np.arange(10))\nz = np.sin(0.5 * x) * np.cos(0.52 * y)\n\n# Mask various z values.\nmask = np.zeros_like(z, dtype=bool)\nmask[2, 3:5] = True\nmask[3:5, 4] = True\nmask[7, 2] = True\nmask[5, 0] = True\nmask[0, 6] = True\nz = np.ma.array(z, mask=mask)\n\ncorner_masks = [False, True]\nfig, axs = plt.subplots(ncols=2)\nfor ax, corner_mask in zip(axs, corner_masks):\n    cs = ax.contourf(x, y, z, corner_mask=corner_mask)\n    ax.contour(cs, colors='k')\n    ax.set_title(f'{corner_mask=}')\n\n    # Plot grid.\n    ax.grid(c='k', ls='-', alpha=0.3)\n\n    # Indicate masked points with red circles.\n    ax.plot(np.ma.array(x, mask=~mask), y, 'ro')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n"
    },
    {
      "filename": "contour_demo.py",
      "title": "Contour Demo",
      "code": "\"\"\"\n============\nContour Demo\n============\n\nIllustrate simple contour plotting, contours on an image with\na colorbar for the contours, and labelled contours.\n\nSee also the :doc:`contour image example\n</gallery/images_contours_and_fields/contour_image>`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\n\ndelta = 0.025\nx = np.arange(-3.0, 3.0, delta)\ny = np.arange(-2.0, 2.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# %%\n# Create a simple contour plot with labels using default colors.  The inline\n# argument to clabel will control whether the labels are draw over the line\n# segments of the contour, removing the lines beneath the label.\n\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z)\nax.clabel(CS, fontsize=10)\nax.set_title('Simplest default with labels')\n\n# %%\n# Contour labels can be placed manually by providing list of positions (in data\n# coordinate).  See :doc:`/gallery/event_handling/ginput_manual_clabel_sgskip`\n# for interactive placement.\n\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z)\nmanual_locations = [\n    (-1, -1.4), (-0.62, -0.7), (-2, 0.5), (1.7, 1.2), (2.0, 1.4), (2.4, 1.7)]\nax.clabel(CS, fontsize=10, manual=manual_locations)\nax.set_title('labels at selected locations')\n\n# %%\n# You can force all the contours to be the same color.\n\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z, 6, colors='k')  # Negative contours default to dashed.\nax.clabel(CS, fontsize=9)\nax.set_title('Single color - negative contours dashed')\n\n# %%\n# You can set negative contours to be solid instead of dashed:\n\nplt.rcParams['contour.negative_linestyle'] = 'solid'\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z, 6, colors='k')  # Negative contours default to dashed.\nax.clabel(CS, fontsize=9)\nax.set_title('Single color - negative contours solid')\n\n# %%\n# And you can manually specify the colors of the contour\n\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z, 6,\n                linewidths=np.arange(.5, 4, .5),\n                colors=('r', 'green', 'blue', (1, 1, 0), '#afeeee', '0.5'),\n                )\nax.clabel(CS, fontsize=9)\nax.set_title('Crazy lines')\n\n# %%\n# Or you can use a colormap to specify the colors; the default\n# colormap will be used for the contour lines\n\nfig, ax = plt.subplots()\nim = ax.imshow(Z, interpolation='bilinear', origin='lower',\n               cmap=cm.gray, extent=(-3, 3, -2, 2))\nlevels = np.arange(-1.2, 1.6, 0.2)\nCS = ax.contour(Z, levels, origin='lower', cmap='flag', extend='both',\n                linewidths=2, extent=(-3, 3, -2, 2))\n\n# Thicken the zero contour.\nlws = np.resize(CS.get_linewidth(), len(levels))\nlws[6] = 4\nCS.set_linewidth(lws)\n\nax.clabel(CS, levels[1::2],  # label every second level\n          fmt='%1.1f', fontsize=14)\n\n# make a colorbar for the contour lines\nCB = fig.colorbar(CS, shrink=0.8)\n\nax.set_title('Lines with colorbar')\n\n# We can still add a colorbar for the image, too.\nCBI = fig.colorbar(im, orientation='horizontal', shrink=0.8)\n\n# This makes the original colorbar look a bit out of place,\n# so let's improve its position.\n\nl, b, w, h = ax.get_position().bounds\nll, bb, ww, hh = CB.ax.get_position().bounds\nCB.ax.set_position([ll, b + 0.1*h, ww, h*0.8])\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.axes.Axes.clabel` / `matplotlib.pyplot.clabel`\n#    - `matplotlib.axes.Axes.get_position`\n#    - `matplotlib.axes.Axes.set_position`\n"
    },
    {
      "filename": "contour_image.py",
      "title": "Contour Image",
      "code": "\"\"\"\n=============\nContour image\n=============\n\nTest combinations of contouring, filled contouring, and image plotting.\nFor contour labelling, see also the :doc:`contour demo example\n</gallery/images_contours_and_fields/contour_demo>`.\n\nThe emphasis in this demo is on showing how to make contours register\ncorrectly on images, and on how to get both of them oriented as desired.\nIn particular, note the usage of the :ref:`\"origin\" and \"extent\"\n<imshow_extent>` keyword arguments to imshow and\ncontour.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\n\n# Default delta is large because that makes it fast, and it illustrates\n# the correct registration between image and contours.\ndelta = 0.5\n\nextent = (-3, 4, -4, 3)\n\nx = np.arange(-3.0, 4.001, delta)\ny = np.arange(-4.0, 3.001, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Boost the upper limit to avoid truncation errors.\nlevels = np.arange(-2.0, 1.601, 0.4)\n\nnorm = cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max())\ncmap = cm.PRGn\n\nfig, _axs = plt.subplots(nrows=2, ncols=2)\nfig.subplots_adjust(hspace=0.3)\naxs = _axs.flatten()\n\ncset1 = axs[0].contourf(X, Y, Z, levels, norm=norm,\n                        cmap=cmap.resampled(len(levels) - 1))\n# It is not necessary, but for the colormap, we need only the\n# number of levels minus 1.  To avoid discretization error, use\n# either this number or a large number such as the default (256).\n\n# If we want lines as well as filled regions, we need to call\n# contour separately; don't try to change the edgecolor or edgewidth\n# of the polygons in the collections returned by contourf.\n# Use levels output from previous call to guarantee they are the same.\n\ncset2 = axs[0].contour(X, Y, Z, cset1.levels, colors='k')\n\n# We don't really need dashed contour lines to indicate negative\n# regions, so let's turn them off.\ncset2.set_linestyle('solid')\n\n# It is easier here to make a separate call to contour than\n# to set up an array of colors and linewidths.\n# We are making a thick green line as a zero contour.\n# Specify the zero level as a tuple with only 0 in it.\n\ncset3 = axs[0].contour(X, Y, Z, (0,), colors='g', linewidths=2)\naxs[0].set_title('Filled contours')\nfig.colorbar(cset1, ax=axs[0])\n\n\naxs[1].imshow(Z, extent=extent, cmap=cmap, norm=norm)\naxs[1].contour(Z, levels, colors='k', origin='upper', extent=extent)\naxs[1].set_title(\"Image, origin 'upper'\")\n\naxs[2].imshow(Z, origin='lower', extent=extent, cmap=cmap, norm=norm)\naxs[2].contour(Z, levels, colors='k', origin='lower', extent=extent)\naxs[2].set_title(\"Image, origin 'lower'\")\n\n# We will use the interpolation \"nearest\" here to show the actual\n# image pixels.\n# Note that the contour lines don't extend to the edge of the box.\n# This is intentional. The Z values are defined at the center of each\n# image pixel (each color block on the following subplot), so the\n# domain that is contoured does not extend beyond these pixel centers.\nim = axs[3].imshow(Z, interpolation='nearest', extent=extent,\n                   cmap=cmap, norm=norm)\naxs[3].contour(Z, levels, colors='k', origin='image', extent=extent)\nylim = axs[3].get_ylim()\naxs[3].set_ylim(ylim[::-1])\naxs[3].set_title(\"Origin from rc, reversed y-axis\")\nfig.colorbar(im, ax=axs[3])\n\nfig.tight_layout()\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.Normalize`\n"
    },
    {
      "filename": "contour_label_demo.py",
      "title": "Contour Label Demo",
      "code": "\"\"\"\n==================\nContour Label Demo\n==================\n\nIllustrate some of the more advanced things that one can do with\ncontour labels.\n\nSee also the :doc:`contour demo example\n</gallery/images_contours_and_fields/contour_demo>`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\n\n# %%\n# Define our surface\n\ndelta = 0.025\nx = np.arange(-3.0, 3.0, delta)\ny = np.arange(-2.0, 2.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# %%\n# Make contour labels with custom level formatters\n\n\n# This custom formatter removes trailing zeros, e.g. \"1.0\" becomes \"1\", and\n# then adds a percent sign.\ndef fmt(x):\n    s = f\"{x:.1f}\"\n    if s.endswith(\"0\"):\n        s = f\"{x:.0f}\"\n    return rf\"{s} \\%\" if plt.rcParams[\"text.usetex\"] else f\"{s} %\"\n\n\n# Basic contour plot\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z)\n\nax.clabel(CS, CS.levels, fmt=fmt, fontsize=10)\n\n# %%\n# Label contours with arbitrary strings using a dictionary\n\nfig1, ax1 = plt.subplots()\n\n# Basic contour plot\nCS1 = ax1.contour(X, Y, Z)\n\nfmt = {}\nstrs = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh']\nfor l, s in zip(CS1.levels, strs):\n    fmt[l] = s\n\n# Label every other level using strings\nax1.clabel(CS1, CS1.levels[::2], fmt=fmt, fontsize=10)\n\n# %%\n# Use a Formatter\n\nfig2, ax2 = plt.subplots()\n\nCS2 = ax2.contour(X, Y, 100**Z, locator=plt.LogLocator())\nfmt = ticker.LogFormatterMathtext()\nfmt.create_dummy_axis()\nax2.clabel(CS2, CS2.levels, fmt=fmt)\nax2.set_title(\"$100^Z$\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.clabel` / `matplotlib.pyplot.clabel`\n#    - `matplotlib.ticker.LogFormatterMathtext`\n#    - `matplotlib.ticker.TickHelper.create_dummy_axis`\n"
    },
    {
      "filename": "contourf_demo.py",
      "title": "Contourf Demo",
      "code": "\"\"\"\n=============\nContourf demo\n=============\n\nHow to use the `.axes.Axes.contourf` method to create filled contour plots.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndelta = 0.025\n\nx = y = np.arange(-3.0, 3.01, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\nnr, nc = Z.shape\n\n# put NaNs in one corner:\nZ[-nr // 6:, -nc // 6:] = np.nan\n# contourf will convert these to masked\n\n\nZ = np.ma.array(Z)\n# mask another corner:\nZ[:nr // 6, :nc // 6] = np.ma.masked\n\n# mask a circle in the middle:\ninterior = np.sqrt(X**2 + Y**2) < 0.5\nZ[interior] = np.ma.masked\n\n# %%\n# Automatic contour levels\n# ------------------------\n# We are using automatic selection of contour levels; this is usually not such\n# a good idea, because they don't occur on nice boundaries, but we do it here\n# for purposes of illustration.\n\nfig1, ax2 = plt.subplots(layout='constrained')\nCS = ax2.contourf(X, Y, Z, 10, cmap=plt.cm.bone)\n\n# Note that in the following, we explicitly pass in a subset of the contour\n# levels used for the filled contours.  Alternatively, we could pass in\n# additional levels to provide extra resolution, or leave out the *levels*\n# keyword argument to use all of the original levels.\n\nCS2 = ax2.contour(CS, levels=CS.levels[::2], colors='r')\n\nax2.set_title('Nonsense (3 masked regions)')\nax2.set_xlabel('word length anomaly')\nax2.set_ylabel('sentence length anomaly')\n\n# Make a colorbar for the ContourSet returned by the contourf call.\ncbar = fig1.colorbar(CS)\ncbar.ax.set_ylabel('verbosity coefficient')\n# Add the contour line levels to the colorbar\ncbar.add_lines(CS2)\n\n# %%\n# Explicit contour levels\n# -----------------------\n# Now make a contour plot with the levels specified, and with the colormap\n# generated automatically from a list of colors.\n\nfig2, ax2 = plt.subplots(layout='constrained')\nlevels = [-1.5, -1, -0.5, 0, 0.5, 1]\nCS3 = ax2.contourf(X, Y, Z, levels, colors=('r', 'g', 'b'), extend='both')\n# Our data range extends outside the range of levels; make\n# data below the lowest contour level yellow, and above the\n# highest level cyan:\nCS3.cmap.set_under('yellow')\nCS3.cmap.set_over('cyan')\n\nCS4 = ax2.contour(X, Y, Z, levels, colors=('k',), linewidths=(3,))\nax2.set_title('Listed colors (3 masked regions)')\nax2.clabel(CS4, fmt='%2.1f', colors='w', fontsize=14)\n\n# Notice that the colorbar gets all the information it\n# needs from the ContourSet object, CS3.\nfig2.colorbar(CS3)\n\n# %%\n# Extension settings\n# ------------------\n# Illustrate all 4 possible \"extend\" settings:\nextends = [\"neither\", \"both\", \"min\", \"max\"]\ncmap = plt.colormaps[\"winter\"].with_extremes(under=\"magenta\", over=\"yellow\")\n# Note: contouring simply excludes masked or nan regions, so\n# instead of using the \"bad\" colormap value for them, it draws\n# nothing at all in them.  Therefore, the following would have\n# no effect:\n# cmap.set_bad(\"red\")\n\nfig, axs = plt.subplots(2, 2, layout=\"constrained\")\n\nfor ax, extend in zip(axs.flat, extends):\n    cs = ax.contourf(X, Y, Z, levels, cmap=cmap, extend=extend)\n    fig.colorbar(cs, ax=ax, shrink=0.9)\n    ax.set_title(\"extend = %s\" % extend)\n    ax.locator_params(nbins=4)\n\nplt.show()\n\n# %%\n# Orient contour plots using the origin keyword\n# ---------------------------------------------\n# This code demonstrates orienting contour plot data using the \"origin\" keyword\n\nx = np.arange(1, 10)\ny = x.reshape(-1, 1)\nh = x * y\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\nax1.set_title(\"origin='upper'\")\nax2.set_title(\"origin='lower'\")\nax1.contourf(h, levels=np.arange(5, 70, 5), extend='both', origin=\"upper\")\nax2.contourf(h, levels=np.arange(5, 70, 5), extend='both', origin=\"lower\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.axes.Axes.clabel` / `matplotlib.pyplot.clabel`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.Colormap`\n#    - `matplotlib.colors.Colormap.set_bad`\n#    - `matplotlib.colors.Colormap.set_under`\n#    - `matplotlib.colors.Colormap.set_over`\n"
    },
    {
      "filename": "contourf_hatching.py",
      "title": "Contourf Hatching",
      "code": "\"\"\"\n=================\nContourf hatching\n=================\n\nDemo filled contour plots with hatched patterns.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# invent some numbers, turning the x and y arrays into simple\n# 2d arrays, which make combining them together easier.\nx = np.linspace(-3, 5, 150).reshape(1, -1)\ny = np.linspace(-3, 5, 120).reshape(-1, 1)\nz = np.cos(x) + np.sin(y)\n\n# we no longer need x and y to be 2 dimensional, so flatten them.\nx, y = x.flatten(), y.flatten()\n\n# %%\n# Plot 1: the simplest hatched plot with a colorbar\n\nfig1, ax1 = plt.subplots()\ncs = ax1.contourf(x, y, z, hatches=['-', '/', '\\\\', '//'],\n                  cmap='gray', extend='both', alpha=0.5)\nfig1.colorbar(cs)\n\n# %%\n# Plot 2: a plot of hatches without color with a legend\n\nfig2, ax2 = plt.subplots()\nn_levels = 6\nax2.contour(x, y, z, n_levels, colors='black', linestyles='-')\ncs = ax2.contourf(x, y, z, n_levels, colors='none',\n                  hatches=['.', '/', '\\\\', None, '\\\\\\\\', '*'],\n                  extend='lower')\n\n# create a legend for the contour set\nartists, labels = cs.legend_elements(str_format='{:2.1f}'.format)\nax2.legend(artists, labels, handleheight=2, framealpha=1)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.contour.ContourSet`\n#    - `matplotlib.contour.ContourSet.legend_elements`\n"
    },
    {
      "filename": "contourf_log.py",
      "title": "Contourf Log",
      "code": "\"\"\"\n============================\nContourf and log color scale\n============================\n\nDemonstrate use of a log color scale in contourf\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy import ma\n\nfrom matplotlib import cm, ticker\n\nN = 100\nx = np.linspace(-3.0, 3.0, N)\ny = np.linspace(-2.0, 2.0, N)\n\nX, Y = np.meshgrid(x, y)\n\n# A low hump with a spike coming out.\n# Needs to have z/colour axis on a log scale, so we see both hump and spike.\n# A linear scale only shows the spike.\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nz = Z1 + 50 * Z2\n\n# Put in some negative values (lower left corner) to cause trouble with logs:\nz[:5, :5] = -1\n\n# The following is not strictly essential, but it will eliminate\n# a warning.  Comment it out to see the warning.\nz = ma.masked_where(z <= 0, z)\n\n\n# Automatic selection of levels works; setting the\n# log locator tells contourf to use a log scale:\nfig, ax = plt.subplots()\ncs = ax.contourf(X, Y, z, locator=ticker.LogLocator(), cmap=cm.PuBu_r)\n\n# Alternatively, you can manually set the levels\n# and the norm:\n# lev_exp = np.arange(np.floor(np.log10(z.min())-1),\n#                    np.ceil(np.log10(z.max())+1))\n# levs = np.power(10, lev_exp)\n# cs = ax.contourf(X, Y, z, levs, norm=colors.LogNorm())\n\ncbar = fig.colorbar(cs)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.ticker.LogLocator`\n"
    },
    {
      "filename": "contours_in_optimization_demo.py",
      "title": "Contours In Optimization Demo",
      "code": "\"\"\"\n==============================================\nContouring the solution space of optimizations\n==============================================\n\nContour plotting is particularly handy when illustrating the solution\nspace of optimization problems.  Not only can `.axes.Axes.contour` be\nused to represent the topography of the objective function, it can be\nused to generate boundary curves of the constraint functions.  The\nconstraint lines can be drawn with\n`~matplotlib.patheffects.TickedStroke` to distinguish the valid and\ninvalid sides of the constraint boundaries.\n\n`.axes.Axes.contour` generates curves with larger values to the left\nof the contour.  The angle parameter is measured zero ahead with\nincreasing values to the left.  Consequently, when using\n`~matplotlib.patheffects.TickedStroke` to illustrate a constraint in\na typical optimization problem, the angle should be set between\nzero and 180 degrees.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\nnx = 101\nny = 105\n\n# Set up survey vectors\nxvec = np.linspace(0.001, 4.0, nx)\nyvec = np.linspace(0.001, 4.0, ny)\n\n# Set up survey matrices.  Design disk loading and gear ratio.\nx1, x2 = np.meshgrid(xvec, yvec)\n\n# Evaluate some stuff to plot\nobj = x1**2 + x2**2 - 2*x1 - 2*x2 + 2\ng1 = -(3*x1 + x2 - 5.5)\ng2 = -(x1 + 2*x2 - 4.5)\ng3 = 0.8 + x1**-3 - x2\n\ncntr = ax.contour(x1, x2, obj, [0.01, 0.1, 0.5, 1, 2, 4, 8, 16],\n                  colors='black')\nax.clabel(cntr, fmt=\"%2.1f\", use_clabeltext=True)\n\ncg1 = ax.contour(x1, x2, g1, [0], colors='sandybrown')\ncg1.set(path_effects=[patheffects.withTickedStroke(angle=135)])\n\ncg2 = ax.contour(x1, x2, g2, [0], colors='orangered')\ncg2.set(path_effects=[patheffects.withTickedStroke(angle=60, length=2)])\n\ncg3 = ax.contour(x1, x2, g3, [0], colors='mediumblue')\ncg3.set(path_effects=[patheffects.withTickedStroke(spacing=7)])\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nplt.show()\n"
    },
    {
      "filename": "demo_bboximage.py",
      "title": "Demo Bboximage",
      "code": "\"\"\"\n==============\nBboxImage Demo\n==============\n\nA `~matplotlib.image.BboxImage` can be used to position an image according to\na bounding box. This demo shows how to show an image inside a `.text.Text`'s\nbounding box as well as how to manually create a bounding box for the image.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.image import BboxImage\nfrom matplotlib.transforms import Bbox, TransformedBbox\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\n# ----------------------------\n# Create a BboxImage with Text\n# ----------------------------\ntxt = ax1.text(0.5, 0.5, \"test\", size=30, ha=\"center\", color=\"w\")\nax1.add_artist(\n    BboxImage(txt.get_window_extent, data=np.arange(256).reshape((1, -1))))\n\n# ------------------------------------\n# Create a BboxImage for each colormap\n# ------------------------------------\n# List of all colormaps; skip reversed colormaps.\ncmap_names = sorted(m for m in plt.colormaps if not m.endswith(\"_r\"))\n\nncol = 2\nnrow = len(cmap_names) // ncol + 1\n\nxpad_fraction = 0.3\ndx = 1 / (ncol + xpad_fraction * (ncol - 1))\n\nypad_fraction = 0.3\ndy = 1 / (nrow + ypad_fraction * (nrow - 1))\n\nfor i, cmap_name in enumerate(cmap_names):\n    ix, iy = divmod(i, nrow)\n    bbox0 = Bbox.from_bounds(ix*dx*(1+xpad_fraction),\n                             1 - iy*dy*(1+ypad_fraction) - dy,\n                             dx, dy)\n    bbox = TransformedBbox(bbox0, ax2.transAxes)\n    ax2.add_artist(\n        BboxImage(bbox, cmap=cmap_name, data=np.arange(256).reshape((1, -1))))\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.image.BboxImage`\n#    - `matplotlib.transforms.Bbox`\n#    - `matplotlib.transforms.TransformedBbox`\n#    - `matplotlib.text.Text`\n"
    },
    {
      "filename": "figimage_demo.py",
      "title": "Figimage Demo",
      "code": "\"\"\"\n=============\nFigimage Demo\n=============\n\nThis illustrates placing images directly in the figure, with no Axes objects.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nZ = np.arange(10000).reshape((100, 100))\nZ[:, 50:] = 1\n\nim1 = fig.figimage(Z, xo=50, yo=0, origin='lower')\nim2 = fig.figimage(Z, xo=100, yo=100, alpha=.8, origin='lower')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure`\n#    - `matplotlib.figure.Figure.figimage` / `matplotlib.pyplot.figimage`\n"
    },
    {
      "filename": "image_annotated_heatmap.py",
      "title": "Image Annotated Heatmap",
      "code": "\"\"\"\n=================\nAnnotated heatmap\n=================\n\nIt is often desirable to show data which depends on two independent\nvariables as a color coded image plot. This is often referred to as a\nheatmap. If the data is categorical, this would be called a categorical\nheatmap.\n\nMatplotlib's `~matplotlib.axes.Axes.imshow` function makes\nproduction of such plots particularly easy.\n\nThe following examples show how to create a heatmap with annotations.\nWe will start with an easy example and expand it to be usable as a\nuniversal function.\n\"\"\"\n\n\n# %%\n#\n# A simple categorical heatmap\n# ----------------------------\n#\n# We may start by defining some data. What we need is a 2D list or array\n# which defines the data to color code. We then also need two lists or arrays\n# of categories; of course the number of elements in those lists\n# need to match the data along the respective axes.\n# The heatmap itself is an `~matplotlib.axes.Axes.imshow` plot\n# with the labels set to the categories we have.\n# Note that it is important to set both, the tick locations\n# (`~matplotlib.axes.Axes.set_xticks`) as well as the\n# tick labels (`~matplotlib.axes.Axes.set_xticklabels`),\n# otherwise they would become out of sync. The locations are just\n# the ascending integer numbers, while the ticklabels are the labels to show.\n# Finally, we can label the data itself by creating a `~matplotlib.text.Text`\n# within each cell showing the value of that cell.\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib\nimport matplotlib as mpl\n\n# sphinx_gallery_thumbnail_number = 2\n\nvegetables = [\"cucumber\", \"tomato\", \"lettuce\", \"asparagus\",\n              \"potato\", \"wheat\", \"barley\"]\nfarmers = [\"Farmer Joe\", \"Upland Bros.\", \"Smith Gardening\",\n           \"Agrifun\", \"Organiculture\", \"BioGoods Ltd.\", \"Cornylee Corp.\"]\n\nharvest = np.array([[0.8, 2.4, 2.5, 3.9, 0.0, 4.0, 0.0],\n                    [2.4, 0.0, 4.0, 1.0, 2.7, 0.0, 0.0],\n                    [1.1, 2.4, 0.8, 4.3, 1.9, 4.4, 0.0],\n                    [0.6, 0.0, 0.3, 0.0, 3.1, 0.0, 0.0],\n                    [0.7, 1.7, 0.6, 2.6, 2.2, 6.2, 0.0],\n                    [1.3, 1.2, 0.0, 0.0, 0.0, 3.2, 5.1],\n                    [0.1, 2.0, 0.0, 1.4, 0.0, 1.9, 6.3]])\n\n\nfig, ax = plt.subplots()\nim = ax.imshow(harvest)\n\n# Show all ticks and label them with the respective list entries\nax.set_xticks(range(len(farmers)), labels=farmers,\n              rotation=45, ha=\"right\", rotation_mode=\"anchor\")\nax.set_yticks(range(len(vegetables)), labels=vegetables)\n\n# Loop over data dimensions and create text annotations.\nfor i in range(len(vegetables)):\n    for j in range(len(farmers)):\n        text = ax.text(j, i, harvest[i, j],\n                       ha=\"center\", va=\"center\", color=\"w\")\n\nax.set_title(\"Harvest of local farmers (in tons/year)\")\nfig.tight_layout()\nplt.show()\n\n\n# %%\n# Using the helper function code style\n# ------------------------------------\n#\n# As discussed in the :ref:`Coding styles <coding_styles>`\n# one might want to reuse such code to create some kind of heatmap\n# for different input data and/or on different axes.\n# We create a function that takes the data and the row and column labels as\n# input, and allows arguments that are used to customize the plot\n#\n# Here, in addition to the above we also want to create a colorbar and\n# position the labels above of the heatmap instead of below it.\n# The annotations shall get different colors depending on a threshold\n# for better contrast against the pixel color.\n# Finally, we turn the surrounding axes spines off and create\n# a grid of white lines to separate the cells.\n\n\ndef heatmap(data, row_labels, col_labels, ax=None,\n            cbar_kw=None, cbarlabel=\"\", **kwargs):\n    \"\"\"\n    Create a heatmap from a numpy array and two lists of labels.\n\n    Parameters\n    ----------\n    data\n        A 2D numpy array of shape (M, N).\n    row_labels\n        A list or array of length M with the labels for the rows.\n    col_labels\n        A list or array of length N with the labels for the columns.\n    ax\n        A `matplotlib.axes.Axes` instance to which the heatmap is plotted.  If\n        not provided, use current Axes or create a new one.  Optional.\n    cbar_kw\n        A dictionary with arguments to `matplotlib.Figure.colorbar`.  Optional.\n    cbarlabel\n        The label for the colorbar.  Optional.\n    **kwargs\n        All other arguments are forwarded to `imshow`.\n    \"\"\"\n\n    if ax is None:\n        ax = plt.gca()\n\n    if cbar_kw is None:\n        cbar_kw = {}\n\n    # Plot the heatmap\n    im = ax.imshow(data, **kwargs)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(im, ax=ax, **cbar_kw)\n    cbar.ax.set_ylabel(cbarlabel, rotation=-90, va=\"bottom\")\n\n    # Show all ticks and label them with the respective list entries.\n    ax.set_xticks(range(data.shape[1]), labels=col_labels,\n                  rotation=-30, ha=\"right\", rotation_mode=\"anchor\")\n    ax.set_yticks(range(data.shape[0]), labels=row_labels)\n\n    # Let the horizontal axes labeling appear on top.\n    ax.tick_params(top=True, bottom=False,\n                   labeltop=True, labelbottom=False)\n\n    # Turn spines off and create white grid.\n    ax.spines[:].set_visible(False)\n\n    ax.set_xticks(np.arange(data.shape[1]+1)-.5, minor=True)\n    ax.set_yticks(np.arange(data.shape[0]+1)-.5, minor=True)\n    ax.grid(which=\"minor\", color=\"w\", linestyle='-', linewidth=3)\n    ax.tick_params(which=\"minor\", bottom=False, left=False)\n\n    return im, cbar\n\n\ndef annotate_heatmap(im, data=None, valfmt=\"{x:.2f}\",\n                     textcolors=(\"black\", \"white\"),\n                     threshold=None, **textkw):\n    \"\"\"\n    A function to annotate a heatmap.\n\n    Parameters\n    ----------\n    im\n        The AxesImage to be labeled.\n    data\n        Data used to annotate.  If None, the image's data is used.  Optional.\n    valfmt\n        The format of the annotations inside the heatmap.  This should either\n        use the string format method, e.g. \"$ {x:.2f}\", or be a\n        `matplotlib.ticker.Formatter`.  Optional.\n    textcolors\n        A pair of colors.  The first is used for values below a threshold,\n        the second for those above.  Optional.\n    threshold\n        Value in data units according to which the colors from textcolors are\n        applied.  If None (the default) uses the middle of the colormap as\n        separation.  Optional.\n    **kwargs\n        All other arguments are forwarded to each call to `text` used to create\n        the text labels.\n    \"\"\"\n\n    if not isinstance(data, (list, np.ndarray)):\n        data = im.get_array()\n\n    # Normalize the threshold to the images color range.\n    if threshold is not None:\n        threshold = im.norm(threshold)\n    else:\n        threshold = im.norm(data.max())/2.\n\n    # Set default alignment to center, but allow it to be\n    # overwritten by textkw.\n    kw = dict(horizontalalignment=\"center\",\n              verticalalignment=\"center\")\n    kw.update(textkw)\n\n    # Get the formatter in case a string is supplied\n    if isinstance(valfmt, str):\n        valfmt = matplotlib.ticker.StrMethodFormatter(valfmt)\n\n    # Loop over the data and create a `Text` for each \"pixel\".\n    # Change the text's color depending on the data.\n    texts = []\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            kw.update(color=textcolors[int(im.norm(data[i, j]) > threshold)])\n            text = im.axes.text(j, i, valfmt(data[i, j], None), **kw)\n            texts.append(text)\n\n    return texts\n\n\n# %%\n# The above now allows us to keep the actual plot creation pretty compact.\n#\n\nfig, ax = plt.subplots()\n\nim, cbar = heatmap(harvest, vegetables, farmers, ax=ax,\n                   cmap=\"YlGn\", cbarlabel=\"harvest [t/year]\")\ntexts = annotate_heatmap(im, valfmt=\"{x:.1f} t\")\n\nfig.tight_layout()\nplt.show()\n\n\n# %%\n# Some more complex heatmap examples\n# ----------------------------------\n#\n# In the following we show the versatility of the previously created\n# functions by applying it in different cases and using different arguments.\n#\n\nnp.random.seed(19680801)\n\nfig, ((ax, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(8, 6))\n\n# Replicate the above example with a different font size and colormap.\n\nim, _ = heatmap(harvest, vegetables, farmers, ax=ax,\n                cmap=\"Wistia\", cbarlabel=\"harvest [t/year]\")\nannotate_heatmap(im, valfmt=\"{x:.1f}\", size=7)\n\n# Create some new data, give further arguments to imshow (vmin),\n# use an integer format on the annotations and provide some colors.\n\ndata = np.random.randint(2, 100, size=(7, 7))\ny = [f\"Book {i}\" for i in range(1, 8)]\nx = [f\"Store {i}\" for i in list(\"ABCDEFG\")]\nim, _ = heatmap(data, y, x, ax=ax2, vmin=0,\n                cmap=\"magma_r\", cbarlabel=\"weekly sold copies\")\nannotate_heatmap(im, valfmt=\"{x:d}\", size=7, threshold=20,\n                 textcolors=(\"red\", \"white\"))\n\n# Sometimes even the data itself is categorical. Here we use a\n# `matplotlib.colors.BoundaryNorm` to get the data into classes\n# and use this to colorize the plot, but also to obtain the class\n# labels from an array of classes.\n\ndata = np.random.randn(6, 6)\ny = [f\"Prod. {i}\" for i in range(10, 70, 10)]\nx = [f\"Cycle {i}\" for i in range(1, 7)]\n\nqrates = list(\"ABCDEFG\")\nnorm = matplotlib.colors.BoundaryNorm(np.linspace(-3.5, 3.5, 8), 7)\nfmt = matplotlib.ticker.FuncFormatter(lambda x, pos: qrates[::-1][norm(x)])\n\nim, _ = heatmap(data, y, x, ax=ax3,\n                cmap=mpl.colormaps[\"PiYG\"].resampled(7), norm=norm,\n                cbar_kw=dict(ticks=np.arange(-3, 4), format=fmt),\n                cbarlabel=\"Quality Rating\")\n\nannotate_heatmap(im, valfmt=fmt, size=9, fontweight=\"bold\", threshold=-1,\n                 textcolors=(\"red\", \"black\"))\n\n# We can nicely plot a correlation matrix. Since this is bound by -1 and 1,\n# we use those as vmin and vmax. We may also remove leading zeros and hide\n# the diagonal elements (which are all 1) by using a\n# `matplotlib.ticker.FuncFormatter`.\n\ncorr_matrix = np.corrcoef(harvest)\nim, _ = heatmap(corr_matrix, vegetables, vegetables, ax=ax4,\n                cmap=\"PuOr\", vmin=-1, vmax=1,\n                cbarlabel=\"correlation coeff.\")\n\n\ndef func(x, pos):\n    return f\"{x:.2f}\".replace(\"0.\", \".\").replace(\"1.00\", \"\")\n\nannotate_heatmap(im, valfmt=matplotlib.ticker.FuncFormatter(func), size=7)\n\n\nplt.tight_layout()\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n"
    },
    {
      "filename": "image_antialiasing.py",
      "title": "Image Antialiasing",
      "code": "\"\"\"\n================\nImage resampling\n================\n\nImages are represented by discrete pixels assigned color values, either on the\nscreen or in an image file.  When a user calls `~.Axes.imshow` with a data\narray, it is rare that the size of the data array exactly matches the number of\npixels allotted to the image in the figure, so Matplotlib resamples or `scales\n<https://en.wikipedia.org/wiki/Image_scaling>`_ the data or image to fit.  If\nthe data array is larger than the number of pixels allotted in the rendered figure,\nthen the image will be \"down-sampled\" and image information will be lost.\nConversely, if the data array is smaller than the number of output pixels then each\ndata point will get multiple pixels, and the image is \"up-sampled\".\n\nIn the following figure, the first data array has size (450, 450), but is\nrepresented by far fewer pixels in the figure, and hence is down-sampled.  The\nsecond data array has size (4, 4), and is represented by far more pixels, and\nhence is up-sampled.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axs = plt.subplots(1, 2, figsize=(4, 2))\n\n# First we generate a 450x450 pixel image with varying frequency content:\nN = 450\nx = np.arange(N) / N - 0.5\ny = np.arange(N) / N - 0.5\naa = np.ones((N, N))\naa[::2, :] = -1\n\nX, Y = np.meshgrid(x, y)\nR = np.sqrt(X**2 + Y**2)\nf0 = 5\nk = 100\na = np.sin(np.pi * 2 * (f0 * R + k * R**2 / 2))\n# make the left hand side of this\na[:int(N / 2), :][R[:int(N / 2), :] < 0.4] = -1\na[:int(N / 2), :][R[:int(N / 2), :] < 0.3] = 1\naa[:, int(N / 3):] = a[:, int(N / 3):]\nalarge = aa\n\naxs[0].imshow(alarge, cmap='RdBu_r')\naxs[0].set_title('(450, 450) Down-sampled', fontsize='medium')\n\nnp.random.seed(19680801+9)\nasmall = np.random.rand(4, 4)\naxs[1].imshow(asmall, cmap='viridis')\naxs[1].set_title('(4, 4) Up-sampled', fontsize='medium')\n\n# %%\n# Matplotlib's `~.Axes.imshow` method has two keyword arguments to allow the user\n# to control how resampling is done.  The *interpolation* keyword argument allows\n# a choice of the kernel that is used for resampling, allowing either `anti-alias\n# <https://en.wikipedia.org/wiki/Anti-aliasing_filter>`_ filtering if\n# down-sampling, or smoothing of pixels if up-sampling.  The\n# *interpolation_stage* keyword argument, determines if this smoothing kernel is\n# applied to the underlying data, or if the kernel is applied to the RGBA pixels.\n#\n# ``interpolation_stage='rgba'``: Data -> Normalize -> RGBA -> Interpolate/Resample\n#\n# ``interpolation_stage='data'``: Data -> Interpolate/Resample -> Normalize -> RGBA\n#\n# For both keyword arguments, Matplotlib has a default \"antialiased\", that is\n# recommended for most situations, and is described below.  Note that this\n# default behaves differently if the image is being down- or up-sampled, as\n# described below.\n#\n# Down-sampling and modest up-sampling\n# ====================================\n#\n# When down-sampling data, we usually want to remove aliasing by smoothing the\n# image first and then sub-sampling it.  In Matplotlib, we can do that smoothing\n# before mapping the data to colors, or we can do the smoothing on the RGB(A)\n# image pixels.  The differences between these are shown below, and controlled\n# with the *interpolation_stage* keyword argument.\n#\n# The following images are down-sampled from 450 data pixels to approximately\n# 125 pixels or 250 pixels (depending on your display).\n# The underlying image has alternating +1, -1 stripes on the left side, and\n# a varying wavelength (`chirp <https://en.wikipedia.org/wiki/Chirp>`_) pattern\n# in the rest of the image.  If we zoom, we can see this detail without any\n# down-sampling:\n\nfig, ax = plt.subplots(figsize=(4, 4), layout='compressed')\nax.imshow(alarge, interpolation='nearest', cmap='RdBu_r')\nax.set_xlim(100, 200)\nax.set_ylim(275, 175)\nax.set_title('Zoom')\n\n# %%\n# If we down-sample, the simplest algorithm is to decimate the data using\n# `nearest-neighbor interpolation\n# <https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation>`_.  We can\n# do this in either data space or RGBA space:\n\nfig, axs = plt.subplots(1, 2, figsize=(5, 2.7), layout='compressed')\nfor ax, interp, space in zip(axs.flat, ['nearest', 'nearest'],\n                                       ['data', 'rgba']):\n    ax.imshow(alarge, interpolation=interp, interpolation_stage=space,\n              cmap='RdBu_r')\n    ax.set_title(f\"interpolation='{interp}'\\nstage='{space}'\")\n\n# %%\n# Nearest interpolation is identical in data and RGBA space, and both exhibit\n# `Moir\u00e9 <https://en.wikipedia.org/wiki/Moir\u00e9_pattern>`_ patterns because the\n# high-frequency data is being down-sampled and shows up as lower frequency\n# patterns. We can reduce the Moir\u00e9 patterns by applying an anti-aliasing filter\n# to the image before rendering:\n\nfig, axs = plt.subplots(1, 2, figsize=(5, 2.7), layout='compressed')\nfor ax, interp, space in zip(axs.flat, ['hanning', 'hanning'],\n                                       ['data', 'rgba']):\n    ax.imshow(alarge, interpolation=interp, interpolation_stage=space,\n              cmap='RdBu_r')\n    ax.set_title(f\"interpolation='{interp}'\\nstage='{space}'\")\nplt.show()\n\n# %%\n# The `Hanning <https://en.wikipedia.org/wiki/Hann_function>`_ filter smooths\n# the underlying data so that each new pixel is a weighted average of the\n# original underlying pixels.  This greatly reduces the Moir\u00e9 patterns.\n# However, when the *interpolation_stage* is set to 'data', it also introduces\n# white regions to the image that are not in the original data, both in the\n# alternating bands on the left hand side of the image, and in the boundary\n# between the red and blue of the large circles in the middle of the image.\n# The interpolation at the 'rgba' stage has a different artifact, with the alternating\n# bands coming out a shade of purple; even though purple is not in the original\n# colormap, it is what we perceive when a blue and red stripe are close to each\n# other.\n#\n# The default for the *interpolation* keyword argument is 'auto' which\n# will choose a Hanning filter if the image is being down-sampled or up-sampled\n# by less than a factor of three.  The default *interpolation_stage* keyword\n# argument is also 'auto', and for images that are down-sampled or\n# up-sampled by less than a factor of three it defaults to 'rgba'\n# interpolation.\n#\n# Anti-aliasing filtering is needed, even when up-sampling. The following image\n# up-samples 450 data pixels to 530 rendered pixels. You may note a grid of\n# line-like artifacts which stem from the extra pixels that had to be made up.\n# Since interpolation is 'nearest' they are the same as a neighboring line of\n# pixels and thus stretch the image locally so that it looks distorted.\n\nfig, ax = plt.subplots(figsize=(6.8, 6.8))\nax.imshow(alarge, interpolation='nearest', cmap='grey')\nax.set_title(\"up-sampled by factor a 1.17, interpolation='nearest'\")\n\n# %%\n# Better anti-aliasing algorithms can reduce this effect:\nfig, ax = plt.subplots(figsize=(6.8, 6.8))\nax.imshow(alarge, interpolation='auto', cmap='grey')\nax.set_title(\"up-sampled by factor a 1.17, interpolation='auto'\")\n\n# %%\n# Apart from the default 'hanning' anti-aliasing, `~.Axes.imshow` supports a\n# number of different interpolation algorithms, which may work better or\n# worse depending on the underlying data.\nfig, axs = plt.subplots(1, 2, figsize=(7, 4), layout='constrained')\nfor ax, interp in zip(axs, ['hanning', 'lanczos']):\n    ax.imshow(alarge, interpolation=interp, cmap='gray')\n    ax.set_title(f\"interpolation='{interp}'\")\n\n# %%\n# A final example shows the desirability of performing the anti-aliasing at the\n# RGBA stage when using non-trivial interpolation kernels.  In the following,\n# the data in the upper 100 rows is exactly 0.0, and data in the inner circle\n# is exactly 2.0. If we perform the *interpolation_stage* in 'data' space and\n# use an anti-aliasing filter (first panel), then floating point imprecision\n# makes some of the data values just a bit less than zero or a bit more than\n# 2.0, and they get assigned the under- or over- colors. This can be avoided if\n# you do not use an anti-aliasing filter (*interpolation* set set to\n# 'nearest'), however, that makes the part of the data susceptible to Moir\u00e9\n# patterns much worse (second panel).  Therefore, we recommend the default\n# *interpolation* of 'hanning'/'auto', and *interpolation_stage* of\n# 'rgba'/'auto' for most down-sampling situations (last panel).\n\na = alarge + 1\ncmap = plt.get_cmap('RdBu_r')\ncmap.set_under('yellow')\ncmap.set_over('limegreen')\n\nfig, axs = plt.subplots(1, 3, figsize=(7, 3), layout='constrained')\nfor ax, interp, space in zip(axs.flat,\n                             ['hanning', 'nearest', 'hanning', ],\n                             ['data', 'data', 'rgba']):\n    im = ax.imshow(a, interpolation=interp, interpolation_stage=space,\n                   cmap=cmap, vmin=0, vmax=2)\n    title = f\"interpolation='{interp}'\\nstage='{space}'\"\n    if ax == axs[2]:\n        title += '\\nDefault'\n    ax.set_title(title, fontsize='medium')\nfig.colorbar(im, ax=axs, extend='both', shrink=0.8)\n\n# %%\n# Up-sampling\n# ===========\n#\n# If we up-sample, then we can represent a data pixel by many image or screen pixels.\n# In the following example, we greatly over-sample the small data matrix.\n\nnp.random.seed(19680801+9)\na = np.random.rand(4, 4)\n\nfig, axs = plt.subplots(1, 2, figsize=(6.5, 4), layout='compressed')\naxs[0].imshow(asmall, cmap='viridis')\naxs[0].set_title(\"interpolation='auto'\\nstage='auto'\")\naxs[1].imshow(asmall, cmap='viridis', interpolation=\"nearest\",\n              interpolation_stage=\"data\")\naxs[1].set_title(\"interpolation='nearest'\\nstage='data'\")\nplt.show()\n\n# %%\n# The *interpolation* keyword argument can be used to smooth the pixels if desired.\n# However, that almost always is better done in data space, rather than in RGBA space\n# where the filters can cause colors that are not in the colormap to be the result of\n# the interpolation.  In the following example, note that when the interpolation is\n# 'rgba' there are red colors as interpolation artifacts.  Therefore, the default\n# 'auto' choice for *interpolation_stage* is set to be the same as 'data'\n# when up-sampling is greater than a factor of three:\n\nfig, axs = plt.subplots(1, 2, figsize=(6.5, 4), layout='compressed')\nim = axs[0].imshow(a, cmap='viridis', interpolation='sinc', interpolation_stage='data')\naxs[0].set_title(\"interpolation='sinc'\\nstage='data'\\n(default for upsampling)\")\naxs[1].imshow(a, cmap='viridis', interpolation='sinc', interpolation_stage='rgba')\naxs[1].set_title(\"interpolation='sinc'\\nstage='rgba'\")\nfig.colorbar(im, ax=axs, shrink=0.7, extend='both')\n\n# %%\n# Avoiding resampling\n# ===================\n#\n# It is possible to avoid resampling data when making an image.  One method is\n# to simply save to a vector backend (pdf, eps, svg) and use\n# ``interpolation='none'``.  Vector backends allow embedded images, however be\n# aware that some vector image viewers may smooth image pixels.\n#\n# The second method is to exactly match the size of your axes to the size of\n# your data. The following figure is exactly 2 inches by 2 inches, and\n# if the dpi is 200, then the 400x400 data is not resampled at all. If you download\n# this image and zoom in an image viewer you should see the individual stripes\n# on the left hand side (note that if you have a non hiDPI or \"retina\" screen, the html\n# may serve a 100x100 version of the image, which will be downsampled.)\n\nfig = plt.figure(figsize=(2, 2))\nax = fig.add_axes([0, 0, 1, 1])\nax.imshow(aa[:400, :400], cmap='RdBu_r', interpolation='nearest')\nplt.show()\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow`\n"
    },
    {
      "filename": "image_clip_path.py",
      "title": "Image Clip Path",
      "code": "\"\"\"\n============================\nClipping images with patches\n============================\n\nDemo of image that's been clipped by a circular patch.\n\"\"\"\nimport matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.patches as patches\n\nwith cbook.get_sample_data('grace_hopper.jpg') as image_file:\n    image = plt.imread(image_file)\n\nfig, ax = plt.subplots()\nim = ax.imshow(image)\npatch = patches.Circle((260, 200), radius=200, transform=ax.transData)\nim.set_clip_path(patch)\n\nax.axis('off')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.artist.Artist.set_clip_path`\n"
    },
    {
      "filename": "image_demo.py",
      "title": "Image Demo",
      "code": "\"\"\"\n========================\nMany ways to plot images\n========================\n\nThe most common way to plot images in Matplotlib is with\n`~.axes.Axes.imshow`. The following examples demonstrate much of the\nfunctionality of imshow and the many images you can create.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\nimport matplotlib.cm as cm\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# %%\n# First we'll generate a simple bivariate normal distribution.\n\ndelta = 0.025\nx = y = np.arange(-3.0, 3.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\nfig, ax = plt.subplots()\nim = ax.imshow(Z, interpolation='bilinear', cmap=cm.RdYlGn,\n               origin='lower', extent=[-3, 3, -3, 3],\n               vmax=abs(Z).max(), vmin=-abs(Z).max())\n\nplt.show()\n\n\n# %%\n# It is also possible to show images of pictures.\n\n# A sample image\nwith cbook.get_sample_data('grace_hopper.jpg') as image_file:\n    image = plt.imread(image_file)\n\n# And another image, using 256x256 16-bit integers.\nw, h = 256, 256\nwith cbook.get_sample_data('s1045.ima.gz') as datafile:\n    s = datafile.read()\nA = np.frombuffer(s, np.uint16).astype(float).reshape((w, h))\nextent = (0, 25, 0, 25)\n\nfig, ax = plt.subplot_mosaic([\n    ['hopper', 'mri']\n], figsize=(7, 3.5))\n\nax['hopper'].imshow(image)\nax['hopper'].axis('off')  # clear x-axis and y-axis\n\nim = ax['mri'].imshow(A, cmap=plt.cm.hot, origin='upper', extent=extent)\n\nmarkers = [(15.9, 14.5), (16.8, 15)]\nx, y = zip(*markers)\nax['mri'].plot(x, y, 'o')\n\nax['mri'].set_title('MRI')\n\nplt.show()\n\n\n# %%\n# Interpolating images\n# --------------------\n#\n# It is also possible to interpolate images before displaying them. Be careful,\n# as this may manipulate the way your data looks, but it can be helpful for\n# achieving the look you want. Below we'll display the same (small) array,\n# interpolated with three different interpolation methods.\n#\n# The center of the pixel at A[i, j] is plotted at (i+0.5, i+0.5).  If you\n# are using interpolation='nearest', the region bounded by (i, j) and\n# (i+1, j+1) will have the same color.  If you are using interpolation,\n# the pixel center will have the same color as it does with nearest, but\n# other pixels will be interpolated between the neighboring pixels.\n#\n# To prevent edge effects when doing interpolation, Matplotlib pads the input\n# array with identical pixels around the edge: if you have a 5x5 array with\n# colors a-y as below::\n#\n#   a b c d e\n#   f g h i j\n#   k l m n o\n#   p q r s t\n#   u v w x y\n#\n# Matplotlib computes the interpolation and resizing on the padded array ::\n#\n#   a a b c d e e\n#   a a b c d e e\n#   f f g h i j j\n#   k k l m n o o\n#   p p q r s t t\n#   o u v w x y y\n#   o u v w x y y\n#\n# and then extracts the central region of the result.  (Extremely old versions\n# of Matplotlib (<0.63) did not pad the array, but instead adjusted the view\n# limits to hide the affected edge areas.)\n#\n# This approach allows plotting the full extent of an array without\n# edge effects, and for example to layer multiple images of different\n# sizes over one another with different interpolation methods -- see\n# :doc:`/gallery/images_contours_and_fields/layer_images`.  It also implies\n# a performance hit, as this new temporary, padded array must be created.\n# Sophisticated interpolation also implies a performance hit; for maximal\n# performance or very large images, interpolation='nearest' is suggested.\n\nA = np.random.rand(5, 5)\n\nfig, axs = plt.subplots(1, 3, figsize=(10, 3))\nfor ax, interp in zip(axs, ['nearest', 'bilinear', 'bicubic']):\n    ax.imshow(A, interpolation=interp)\n    ax.set_title(interp.capitalize())\n    ax.grid(True)\n\nplt.show()\n\n\n# %%\n# You can specify whether images should be plotted with the array origin\n# x[0, 0] in the upper left or lower right by using the origin parameter.\n# You can also control the default setting image.origin in your\n# :ref:`matplotlibrc file <customizing-with-matplotlibrc-files>`. For more on\n# this topic see the :ref:`complete guide on origin and extent\n# <imshow_extent>`.\n\nx = np.arange(120).reshape((10, 12))\n\ninterp = 'bilinear'\nfig, axs = plt.subplots(nrows=2, sharex=True, figsize=(3, 5))\naxs[0].set_title('blue should be up')\naxs[0].imshow(x, origin='upper', interpolation=interp)\n\naxs[1].set_title('blue should be down')\naxs[1].imshow(x, origin='lower', interpolation=interp)\nplt.show()\n\n\n# %%\n# Finally, we'll show an image using a clip path.\n\ndelta = 0.025\nx = y = np.arange(-3.0, 3.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\npath = Path([[0, 1], [1, 0], [0, -1], [-1, 0], [0, 1]])\npatch = PathPatch(path, facecolor='none')\n\nfig, ax = plt.subplots()\nax.add_patch(patch)\n\nim = ax.imshow(Z, interpolation='bilinear', cmap=cm.gray,\n               origin='lower', extent=[-3, 3, -3, 3],\n               clip_path=patch, clip_on=True)\nim.set_clip_path(patch)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.artist.Artist.set_clip_path`\n#    - `matplotlib.patches.PathPatch`\n"
    },
    {
      "filename": "image_masked.py",
      "title": "Image Masked",
      "code": "\"\"\"\n========================\nImage with masked values\n========================\n\nimshow with masked array input and out-of-range colors.\n\nThe second subplot illustrates the use of BoundaryNorm to\nget a filled contour effect.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n\n# compute some interesting data\nx0, x1 = -5, 5\ny0, y1 = -3, 3\nx = np.linspace(x0, x1, 500)\ny = np.linspace(y0, y1, 500)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Set up a colormap:\npalette = plt.cm.gray.with_extremes(over='r', under='g', bad='b')\n# Alternatively, we could use\n# palette.set_bad(alpha = 0.0)\n# to make the bad region transparent.  This is the default.\n# If you comment out all the palette.set* lines, you will see\n# all the defaults; under and over will be colored with the\n# first and last colors in the palette, respectively.\nZm = np.ma.masked_where(Z > 1.2, Z)\n\n# By setting vmin and vmax in the norm, we establish the\n# range to which the regular palette color scale is applied.\n# Anything above that range is colored based on palette.set_over, etc.\n\n# set up the Axes objects\nfig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(6, 5.4))\n\n# plot using 'continuous' colormap\nim = ax1.imshow(Zm, interpolation='bilinear',\n                cmap=palette,\n                norm=colors.Normalize(vmin=-1.0, vmax=1.0),\n                aspect='auto',\n                origin='lower',\n                extent=[x0, x1, y0, y1])\nax1.set_title('Green=low, Red=high, Blue=masked')\ncbar = fig.colorbar(im, extend='both', shrink=0.9, ax=ax1)\ncbar.set_label('uniform')\nax1.tick_params(axis='x', labelbottom=False)\n\n# Plot using a small number of colors, with unevenly spaced boundaries.\nim = ax2.imshow(Zm, interpolation='nearest',\n                cmap=palette,\n                norm=colors.BoundaryNorm([-1, -0.5, -0.2, 0, 0.2, 0.5, 1],\n                                         ncolors=palette.N),\n                aspect='auto',\n                origin='lower',\n                extent=[x0, x1, y0, y1])\nax2.set_title('With BoundaryNorm')\ncbar = fig.colorbar(im, extend='both', spacing='proportional',\n                    shrink=0.9, ax=ax2)\ncbar.set_label('proportional')\n\nfig.suptitle('imshow, with out-of-range and masked data')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.BoundaryNorm`\n#    - `matplotlib.colorbar.Colorbar.set_label`\n"
    },
    {
      "filename": "image_nonuniform.py",
      "title": "Image Nonuniform",
      "code": "\"\"\"\n================\nImage nonuniform\n================\n\n`.NonUniformImage` is a generalized image with pixels on a rectilinear grid,\ni.e. it allows rows and columns with individual heights / widths.\n\nThere is no high-level plotting method on `~.axes.Axes` or `.pyplot` to\ncreate a NonUniformImage. Instead, you have to instantiate the image\nexplicitly add it to the Axes using `.Axes.add_image`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom matplotlib.image import NonUniformImage\n\ninterp = 'nearest'\n\n# Linear x array for cell centers:\nx = np.linspace(-4, 4, 9)\n\n# Highly nonlinear x array:\nx2 = x**3\n\ny = np.linspace(-4, 4, 9)\n\nz = np.sqrt(x[np.newaxis, :]**2 + y[:, np.newaxis]**2)\n\nfig, axs = plt.subplots(nrows=2, ncols=2, layout='constrained')\nfig.suptitle('NonUniformImage class', fontsize='large')\nax = axs[0, 0]\nim = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x, y, z)\nax.add_image(im)\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nax = axs[0, 1]\nim = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x2, y, z)\nax.add_image(im)\nax.set_xlim(-64, 64)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\ninterp = 'bilinear'\n\nax = axs[1, 0]\nim = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x, y, z)\nax.add_image(im)\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nax = axs[1, 1]\nim = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x2, y, z)\nax.add_image(im)\nax.set_xlim(-64, 64)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nplt.show()\n"
    },
    {
      "filename": "image_transparency_blend.py",
      "title": "Image Transparency Blend",
      "code": "\"\"\"\n==========================================\nBlend transparency with color in 2D images\n==========================================\n\nBlend transparency with color to highlight parts of data with imshow.\n\nA common use for `matplotlib.pyplot.imshow` is to plot a 2D statistical\nmap. The function makes it easy to visualize a 2D matrix as an image and add\ntransparency to the output. For example, one can plot a statistic (such as a\nt-statistic) and color the transparency of each pixel according to its p-value.\nThis example demonstrates how you can achieve this effect.\n\nFirst we will generate some data, in this case, we'll create two 2D \"blobs\"\nin a 2D grid. One blob will be positive, and the other negative.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n# sphinx_gallery_thumbnail_number = 3\nimport numpy as np\n\nfrom matplotlib.colors import Normalize\n\n\ndef normal_pdf(x, mean, var):\n    return np.exp(-(x - mean)**2 / (2*var))\n\n\n# Generate the space in which the blobs will live\nxmin, xmax, ymin, ymax = (0, 100, 0, 100)\nn_bins = 100\nxx = np.linspace(xmin, xmax, n_bins)\nyy = np.linspace(ymin, ymax, n_bins)\n\n# Generate the blobs. The range of the values is roughly -.0002 to .0002\nmeans_high = [20, 50]\nmeans_low = [50, 60]\nvar = [150, 200]\n\ngauss_x_high = normal_pdf(xx, means_high[0], var[0])\ngauss_y_high = normal_pdf(yy, means_high[1], var[0])\n\ngauss_x_low = normal_pdf(xx, means_low[0], var[1])\ngauss_y_low = normal_pdf(yy, means_low[1], var[1])\n\nweights = (np.outer(gauss_y_high, gauss_x_high)\n           - np.outer(gauss_y_low, gauss_x_low))\n\n# We'll also create a grey background into which the pixels will fade\ngreys = np.full((*weights.shape, 3), 70, dtype=np.uint8)\n\n# First we'll plot these blobs using ``imshow`` without transparency.\nvmax = np.abs(weights).max()\nimshow_kwargs = {\n    'vmax': vmax,\n    'vmin': -vmax,\n    'cmap': 'RdYlBu',\n    'extent': (xmin, xmax, ymin, ymax),\n}\n\nfig, ax = plt.subplots()\nax.imshow(greys)\nax.imshow(weights, **imshow_kwargs)\nax.set_axis_off()\n\n# %%\n# Blending in transparency\n# ========================\n#\n# The simplest way to include transparency when plotting data with\n# `matplotlib.pyplot.imshow` is to pass an array matching the shape of\n# the data to the ``alpha`` argument. For example, we'll create a gradient\n# moving from left to right below.\n\n# Create an alpha channel of linearly increasing values moving to the right.\nalphas = np.ones(weights.shape)\nalphas[:, 30:] = np.linspace(1, 0, 70)\n\n# Create the figure and image\n# Note that the absolute values may be slightly different\nfig, ax = plt.subplots()\nax.imshow(greys)\nax.imshow(weights, alpha=alphas, **imshow_kwargs)\nax.set_axis_off()\n\n# %%\n# Using transparency to highlight values with high amplitude\n# ==========================================================\n#\n# Finally, we'll recreate the same plot, but this time we'll use transparency\n# to highlight the extreme values in the data. This is often used to highlight\n# data points with smaller p-values. We'll also add in contour lines to\n# highlight the image values.\n\n# Create an alpha channel based on weight values\n# Any value whose absolute value is > .0001 will have zero transparency\nalphas = Normalize(0, .3, clip=True)(np.abs(weights))\nalphas = np.clip(alphas, .4, 1)  # alpha value clipped at the bottom at .4\n\n# Create the figure and image\n# Note that the absolute values may be slightly different\nfig, ax = plt.subplots()\nax.imshow(greys)\nax.imshow(weights, alpha=alphas, **imshow_kwargs)\n\n# Add contour lines to further highlight different levels.\nax.contour(weights[::-1], levels=[-.1, .1], colors='k', linestyles='-')\nax.set_axis_off()\nplt.show()\n\nax.contour(weights[::-1], levels=[-.0001, .0001], colors='k', linestyles='-')\nax.set_axis_off()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.colors.Normalize`\n#    - `matplotlib.axes.Axes.set_axis_off`\n"
    },
    {
      "filename": "image_zcoord.py",
      "title": "Image Zcoord",
      "code": "\"\"\"\n==================================\nModifying the coordinate formatter\n==================================\n\nModify the coordinate formatter to report the image \"z\" value of the nearest\npixel given x and y.  This functionality is built in by default; this example\njust showcases how to customize the `~.axes.Axes.format_coord` function.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nX = 10*np.random.rand(5, 3)\n\nfig, ax = plt.subplots()\nax.imshow(X)\n\n\ndef format_coord(x, y):\n    col = round(x)\n    row = round(y)\n    nrows, ncols = X.shape\n    if 0 <= col < ncols and 0 <= row < nrows:\n        z = X[row, col]\n        return f'x={x:1.4f}, y={y:1.4f}, z={z:1.4f}'\n    else:\n        return f'x={x:1.4f}, y={y:1.4f}'\n\n\nax.format_coord = format_coord\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.format_coord`\n#    - `matplotlib.axes.Axes.imshow`\n"
    },
    {
      "filename": "interpolation_methods.py",
      "title": "Interpolation Methods",
      "code": "\"\"\"\n=========================\nInterpolations for imshow\n=========================\n\nThis example displays the difference between interpolation methods for\n`~.axes.Axes.imshow`.\n\nIf *interpolation* is None, it defaults to the :rc:`image.interpolation`.\nIf the interpolation is ``'none'``, then no interpolation is performed for the\nAgg, ps and pdf backends. Other backends will default to ``'auto'``.\n\nFor the Agg, ps and pdf backends, ``interpolation='none'`` works well when a\nbig image is scaled down, while ``interpolation='nearest'`` works well when\na small image is scaled up.\n\nSee :doc:`/gallery/images_contours_and_fields/image_antialiasing` for a\ndiscussion on the default ``interpolation='auto'`` option.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nmethods = [None, 'none', 'nearest', 'bilinear', 'bicubic', 'spline16',\n           'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric',\n           'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos']\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ngrid = np.random.rand(4, 4)\n\nfig, axs = plt.subplots(nrows=3, ncols=6, figsize=(9, 6),\n                        subplot_kw={'xticks': [], 'yticks': []})\n\nfor ax, interp_method in zip(axs.flat, methods):\n    ax.imshow(grid, interpolation=interp_method, cmap='viridis')\n    ax.set_title(str(interp_method))\n\nplt.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n"
    },
    {
      "filename": "irregulardatagrid.py",
      "title": "Irregulardatagrid",
      "code": "\"\"\"\n=======================================\nContour plot of irregularly spaced data\n=======================================\n\nComparison of a contour plot of irregularly spaced data interpolated\non a regular grid versus a tricontour plot for an unstructured triangular grid.\n\nSince `~.axes.Axes.contour` and `~.axes.Axes.contourf` expect the data to live\non a regular grid, plotting a contour plot of irregularly spaced data requires\ndifferent methods. The two options are:\n\n* Interpolate the data to a regular grid first. This can be done with on-board\n  means, e.g. via `~.tri.LinearTriInterpolator` or using external functionality\n  e.g. via `scipy.interpolate.griddata`. Then plot the interpolated data with\n  the usual `~.axes.Axes.contour`.\n* Directly use `~.axes.Axes.tricontour` or `~.axes.Axes.tricontourf` which will\n  perform a triangulation internally.\n\nThis example shows both methods in action.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\nnp.random.seed(19680801)\nnpts = 200\nngridx = 100\nngridy = 200\nx = np.random.uniform(-2, 2, npts)\ny = np.random.uniform(-2, 2, npts)\nz = x * np.exp(-x**2 - y**2)\n\nfig, (ax1, ax2) = plt.subplots(nrows=2)\n\n# -----------------------\n# Interpolation on a grid\n# -----------------------\n# A contour plot of irregularly spaced data coordinates\n# via interpolation on a grid.\n\n# Create grid values first.\nxi = np.linspace(-2.1, 2.1, ngridx)\nyi = np.linspace(-2.1, 2.1, ngridy)\n\n# Linearly interpolate the data (x, y) on a grid defined by (xi, yi).\ntriang = tri.Triangulation(x, y)\ninterpolator = tri.LinearTriInterpolator(triang, z)\nXi, Yi = np.meshgrid(xi, yi)\nzi = interpolator(Xi, Yi)\n\n# Note that scipy.interpolate provides means to interpolate data on a grid\n# as well. The following would be an alternative to the four lines above:\n# from scipy.interpolate import griddata\n# zi = griddata((x, y), z, (xi[None, :], yi[:, None]), method='linear')\n\nax1.contour(xi, yi, zi, levels=14, linewidths=0.5, colors='k')\ncntr1 = ax1.contourf(xi, yi, zi, levels=14, cmap=\"RdBu_r\")\n\nfig.colorbar(cntr1, ax=ax1)\nax1.plot(x, y, 'ko', ms=3)\nax1.set(xlim=(-2, 2), ylim=(-2, 2))\nax1.set_title('grid and contour (%d points, %d grid points)' %\n              (npts, ngridx * ngridy))\n\n# ----------\n# Tricontour\n# ----------\n# Directly supply the unordered, irregularly spaced coordinates\n# to tricontour.\n\nax2.tricontour(x, y, z, levels=14, linewidths=0.5, colors='k')\ncntr2 = ax2.tricontourf(x, y, z, levels=14, cmap=\"RdBu_r\")\n\nfig.colorbar(cntr2, ax=ax2)\nax2.plot(x, y, 'ko', ms=3)\nax2.set(xlim=(-2, 2), ylim=(-2, 2))\nax2.set_title('tricontour (%d points)' % npts)\n\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.contour` / `matplotlib.pyplot.contour`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.axes.Axes.tricontour` / `matplotlib.pyplot.tricontour`\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`\n"
    },
    {
      "filename": "layer_images.py",
      "title": "Layer Images",
      "code": "\"\"\"\n================================\nLayer images with alpha blending\n================================\n\nLayer images above one another using alpha blending\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef func3(x, y):\n    return (1 - x / 2 + x**5 + y**3) * np.exp(-(x**2 + y**2))\n\n\n# make these smaller to increase the resolution\ndx, dy = 0.05, 0.05\n\nx = np.arange(-3.0, 3.0, dx)\ny = np.arange(-3.0, 3.0, dy)\nX, Y = np.meshgrid(x, y)\n\n# when layering multiple images, the images need to have the same\n# extent.  This does not mean they need to have the same shape, but\n# they both need to render to the same coordinate system determined by\n# xmin, xmax, ymin, ymax.  Note if you use different interpolations\n# for the images their apparent extent could be different due to\n# interpolation edge effects\n\nextent = np.min(x), np.max(x), np.min(y), np.max(y)\nfig = plt.figure(frameon=False)\n\nZ1 = np.add.outer(range(8), range(8)) % 2  # chessboard\nim1 = plt.imshow(Z1, cmap=plt.cm.gray, interpolation='nearest',\n                 extent=extent)\n\nZ2 = func3(X, Y)\n\nim2 = plt.imshow(Z2, cmap=plt.cm.viridis, alpha=.9, interpolation='bilinear',\n                 extent=extent)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n"
    },
    {
      "filename": "matshow.py",
      "title": "Matshow",
      "code": "\"\"\"\n===============================\nVisualize matrices with matshow\n===============================\n\n`~.axes.Axes.matshow` visualizes a 2D matrix or array as color-coded image.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# a 2D array with linearly increasing values on the diagonal\na = np.diag(range(15))\n\nplt.matshow(a)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n"
    },
    {
      "filename": "multi_image.py",
      "title": "Multi Image",
      "code": "\"\"\"\n=================================\nMultiple images with one colorbar\n=================================\n\nUse a single colorbar for multiple images.\n\nCurrently, a colorbar can only be connected to one image. The connection\nguarantees that the data coloring is consistent with the colormap scale\n(i.e. the color of value *x* in the colormap is used for coloring a data\nvalue *x* in the image).\n\nIf we want one colorbar to be representative for multiple images, we have\nto explicitly ensure consistent data coloring by using the same data\nnormalization for all the images. We ensure this by explicitly creating a\n``norm`` object that we pass to all the image plotting methods.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors\n\nnp.random.seed(19680801)\n\ndatasets = [\n    (i+1)/10 * np.random.rand(10, 20)\n    for i in range(4)\n]\n\nfig, axs = plt.subplots(2, 2)\nfig.suptitle('Multiple images')\n\n# create a single norm to be shared across all images\nnorm = colors.Normalize(vmin=np.min(datasets), vmax=np.max(datasets))\n\nimages = []\nfor ax, data in zip(axs.flat, datasets):\n    images.append(ax.imshow(data, norm=norm))\n\nfig.colorbar(images[0], ax=axs, orientation='horizontal', fraction=.1)\n\nplt.show()\n\n# %%\n# The colors are now kept consistent across all images when changing the\n# scaling, e.g. through zooming in the colorbar or via the \"edit axis,\n# curves and images parameters\" GUI of the Qt backend. This is sufficient\n# for most practical use cases.\n#\n# Advanced: Additionally sync the colormap\n# ----------------------------------------\n#\n# Sharing a common norm object guarantees synchronized scaling because scale\n# changes modify the norm object in-place and thus propagate to all images\n# that use this norm. This approach does not help with synchronizing colormaps\n# because changing the colormap of an image (e.g. through the \"edit axis,\n# curves and images parameters\" GUI of the Qt backend) results in the image\n# referencing the new colormap object. Thus, the other images are not updated.\n#\n# To update the other images, sync the\n# colormaps using the following code::\n#\n#     def sync_cmaps(changed_image):\n#         for im in images:\n#             if changed_image.get_cmap() != im.get_cmap():\n#                 im.set_cmap(changed_image.get_cmap())\n#\n#     for im in images:\n#         im.callbacks.connect('changed', sync_cmaps)\n#\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.Normalize`\n#    - `matplotlib.cm.ScalarMappable.set_cmap`\n#    - `matplotlib.cbook.CallbackRegistry.connect`\n"
    },
    {
      "filename": "pcolor_demo.py",
      "title": "Pcolor Demo",
      "code": "\"\"\"\n=============\npcolor images\n=============\n\n`~.Axes.pcolor` generates 2D image-style plots, as illustrated below.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import LogNorm\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# %%\n# A simple pcolor demo\n# --------------------\n\nZ = np.random.rand(6, 10)\n\nfig, (ax0, ax1) = plt.subplots(2, 1)\n\nc = ax0.pcolor(Z)\nax0.set_title('default: no edges')\n\nc = ax1.pcolor(Z, edgecolors='k', linewidths=4)\nax1.set_title('thick edges')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n# Comparing pcolor with similar functions\n# ---------------------------------------\n#\n# Demonstrates similarities between `~.axes.Axes.pcolor`,\n# `~.axes.Axes.pcolormesh`, `~.axes.Axes.imshow` and\n# `~.axes.Axes.pcolorfast` for drawing quadrilateral grids.\n# Note that we call ``imshow`` with ``aspect=\"auto\"`` so that it doesn't force\n# the data pixels to be square (the default is ``aspect=\"equal\"``).\n\n# make these smaller to increase the resolution\ndx, dy = 0.15, 0.05\n\n# generate 2 2d grids for the x & y bounds\ny, x = np.mgrid[-3:3+dy:dy, -3:3+dx:dx]\nz = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)\n# x and y are bounds, so z should be the value *inside* those bounds.\n# Therefore, remove the last value from the z array.\nz = z[:-1, :-1]\nz_min, z_max = -abs(z).max(), abs(z).max()\n\nfig, axs = plt.subplots(2, 2)\n\nax = axs[0, 0]\nc = ax.pcolor(x, y, z, cmap='RdBu', vmin=z_min, vmax=z_max)\nax.set_title('pcolor')\nfig.colorbar(c, ax=ax)\n\nax = axs[0, 1]\nc = ax.pcolormesh(x, y, z, cmap='RdBu', vmin=z_min, vmax=z_max)\nax.set_title('pcolormesh')\nfig.colorbar(c, ax=ax)\n\nax = axs[1, 0]\nc = ax.imshow(z, cmap='RdBu', vmin=z_min, vmax=z_max,\n              extent=[x.min(), x.max(), y.min(), y.max()],\n              interpolation='nearest', origin='lower', aspect='auto')\nax.set_title('image (nearest, aspect=\"auto\")')\nfig.colorbar(c, ax=ax)\n\nax = axs[1, 1]\nc = ax.pcolorfast(x, y, z, cmap='RdBu', vmin=z_min, vmax=z_max)\nax.set_title('pcolorfast')\nfig.colorbar(c, ax=ax)\n\nfig.tight_layout()\nplt.show()\n\n\n# %%\n# Pcolor with a log scale\n# -----------------------\n#\n# The following shows pcolor plots with a log scale.\n\nN = 100\nX, Y = np.meshgrid(np.linspace(-3, 3, N), np.linspace(-2, 2, N))\n\n# A low hump with a spike coming out.\n# Needs to have z/colour axis on a log scale, so we see both hump and spike.\n# A linear scale only shows the spike.\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nZ = Z1 + 50 * Z2\n\nfig, (ax0, ax1) = plt.subplots(2, 1)\n\nc = ax0.pcolor(X, Y, Z, shading='auto',\n               norm=LogNorm(vmin=Z.min(), vmax=Z.max()), cmap='PuBu_r')\nfig.colorbar(c, ax=ax0)\n\nc = ax1.pcolor(X, Y, Z, cmap='PuBu_r', shading='auto')\nfig.colorbar(c, ax=ax1)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolor` / `matplotlib.pyplot.pcolor`\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`\n#    - `matplotlib.axes.Axes.pcolorfast`\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.LogNorm`\n"
    },
    {
      "filename": "pcolormesh_grids.py",
      "title": "Pcolormesh Grids",
      "code": "\"\"\"\n============================\npcolormesh grids and shading\n============================\n\n`.axes.Axes.pcolormesh` and `~.axes.Axes.pcolor` have a few options for\nhow grids are laid out and the shading between the grid points.\n\nGenerally, if *Z* has shape *(M, N)* then the grid *X* and *Y* can be\nspecified with either shape *(M+1, N+1)* or *(M, N)*, depending on the\nargument for the ``shading`` keyword argument.  Note that below we specify\nvectors *x* as either length N or N+1 and *y* as length M or M+1, and\n`~.axes.Axes.pcolormesh` internally makes the mesh matrices *X* and *Y* from\nthe input vectors.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n# Flat Shading\n# ------------\n#\n# The grid specification with the least assumptions is ``shading='flat'``\n# and if the grid is one larger than the data in each dimension, i.e. has shape\n# *(M+1, N+1)*.  In that case *X* and *Y* specify the corners of quadrilaterals\n# that are colored with the values in *Z*. Here we specify the edges of the\n# *(3, 5)* quadrilaterals with *X* and *Y* that are *(4, 6)*.\n\nnrows = 3\nncols = 5\nZ = np.arange(nrows * ncols).reshape(nrows, ncols)\nx = np.arange(ncols + 1)\ny = np.arange(nrows + 1)\n\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z, shading='flat', vmin=Z.min(), vmax=Z.max())\n\n\ndef _annotate(ax, x, y, title):\n    # this all gets repeated below:\n    X, Y = np.meshgrid(x, y)\n    ax.plot(X.flat, Y.flat, 'o', color='m')\n    ax.set_xlim(-0.7, 5.2)\n    ax.set_ylim(-0.7, 3.2)\n    ax.set_title(title)\n\n_annotate(ax, x, y, \"shading='flat'\")\n\n\n# %%\n# Flat Shading, same shape grid\n# -----------------------------\n#\n# Often, however, data is provided where *X* and *Y* match the shape of *Z*.\n# While this makes sense for other ``shading`` types, it is not permitted\n# when ``shading='flat'``. Historically, Matplotlib silently dropped the last\n# row and column of *Z* in this case, to match Matlab's behavior. If this\n# behavior is still desired, simply drop the last row and column manually:\n\nx = np.arange(ncols)  # note *not* ncols + 1 as before\ny = np.arange(nrows)\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z[:-1, :-1], shading='flat', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='flat': X, Y, C same shape\")\n\n# %%\n# Nearest Shading, same shape grid\n# --------------------------------\n#\n# Usually, dropping a row and column of data is not what the user means when\n# they make *X*, *Y* and *Z* all the same shape.  For this case, Matplotlib\n# allows ``shading='nearest'`` and centers the colored quadrilaterals on the\n# grid points.\n#\n# If a grid that is not the correct shape is passed with ``shading='nearest'``\n# an error is raised.\n\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z, shading='nearest', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='nearest'\")\n\n# %%\n# Auto Shading\n# ------------\n#\n# It's possible that the user would like the code to automatically choose which\n# to use, in this case ``shading='auto'`` will decide whether to use 'flat' or\n# 'nearest' shading based on the shapes of *X*, *Y* and *Z*.\n\nfig, axs = plt.subplots(2, 1, layout='constrained')\nax = axs[0]\nx = np.arange(ncols)\ny = np.arange(nrows)\nax.pcolormesh(x, y, Z, shading='auto', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='auto'; X, Y, Z: same shape (nearest)\")\n\nax = axs[1]\nx = np.arange(ncols + 1)\ny = np.arange(nrows + 1)\nax.pcolormesh(x, y, Z, shading='auto', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='auto'; X, Y one larger than Z (flat)\")\n\n# %%\n# Gouraud Shading\n# ---------------\n#\n# `Gouraud shading <https://en.wikipedia.org/wiki/Gouraud_shading>`_ can also\n# be specified, where the color in the quadrilaterals is linearly interpolated\n# between the grid points.  The shapes of *X*, *Y*, *Z* must be the same.\n\nfig, ax = plt.subplots(layout='constrained')\nx = np.arange(ncols)\ny = np.arange(nrows)\nax.pcolormesh(x, y, Z, shading='gouraud', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading='gouraud'; X, Y same shape as Z\")\n\nplt.show()\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`\n"
    },
    {
      "filename": "pcolormesh_levels.py",
      "title": "Pcolormesh Levels",
      "code": "\"\"\"\n==========\npcolormesh\n==========\n\n`.axes.Axes.pcolormesh` allows you to generate 2D image-style plots.\nNote that it is faster than the similar `~.axes.Axes.pcolor`.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import BoundaryNorm\nfrom matplotlib.ticker import MaxNLocator\n\n# %%\n# Basic pcolormesh\n# ----------------\n#\n# We usually specify a pcolormesh by defining the edge of quadrilaterals and\n# the value of the quadrilateral.  Note that here *x* and *y* each have one\n# extra element than Z in the respective dimension.\n\nnp.random.seed(19680801)\nZ = np.random.rand(6, 10)\nx = np.arange(-0.5, 10, 1)  # len = 11\ny = np.arange(4.5, 11, 1)  # len = 7\n\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z)\n\n# %%\n# Non-rectilinear pcolormesh\n# --------------------------\n#\n# Note that we can also specify matrices for *X* and *Y* and have\n# non-rectilinear quadrilaterals.\n\nx = np.arange(-0.5, 10, 1)  # len = 11\ny = np.arange(4.5, 11, 1)  # len = 7\nX, Y = np.meshgrid(x, y)\nX = X + 0.2 * Y  # tilt the coordinates.\nY = Y + 0.3 * X\n\nfig, ax = plt.subplots()\nax.pcolormesh(X, Y, Z)\n\n# %%\n# Centered Coordinates\n# ---------------------\n#\n# Often a user wants to pass *X* and *Y* with the same sizes as *Z* to\n# `.axes.Axes.pcolormesh`. This is also allowed if ``shading='auto'`` is\n# passed (default set by :rc:`pcolor.shading`). Pre Matplotlib 3.3,\n# ``shading='flat'`` would drop the last column and row of *Z*, but now gives\n# an error. If this is really what you want, then simply drop the last row and\n# column of Z manually:\n\nx = np.arange(10)  # len = 10\ny = np.arange(6)  # len = 6\nX, Y = np.meshgrid(x, y)\n\nfig, axs = plt.subplots(2, 1, sharex=True, sharey=True)\naxs[0].pcolormesh(X, Y, Z, vmin=np.min(Z), vmax=np.max(Z), shading='auto')\naxs[0].set_title(\"shading='auto' = 'nearest'\")\naxs[1].pcolormesh(X, Y, Z[:-1, :-1], vmin=np.min(Z), vmax=np.max(Z),\n                  shading='flat')\naxs[1].set_title(\"shading='flat'\")\n\n# %%\n# Making levels using Norms\n# -------------------------\n#\n# Shows how to combine Normalization and Colormap instances to draw\n# \"levels\" in `.axes.Axes.pcolor`, `.axes.Axes.pcolormesh`\n# and `.axes.Axes.imshow` type plots in a similar\n# way to the levels keyword argument to contour/contourf.\n\n# make these smaller to increase the resolution\ndx, dy = 0.05, 0.05\n\n# generate 2 2d grids for the x & y bounds\ny, x = np.mgrid[slice(1, 5 + dy, dy),\n                slice(1, 5 + dx, dx)]\n\nz = np.sin(x)**10 + np.cos(10 + y*x) * np.cos(x)\n\n# x and y are bounds, so z should be the value *inside* those bounds.\n# Therefore, remove the last value from the z array.\nz = z[:-1, :-1]\nlevels = MaxNLocator(nbins=15).tick_values(z.min(), z.max())\n\n\n# pick the desired colormap, sensible levels, and define a normalization\n# instance which takes data values and translates those into levels.\ncmap = plt.colormaps['PiYG']\nnorm = BoundaryNorm(levels, ncolors=cmap.N, clip=True)\n\nfig, (ax0, ax1) = plt.subplots(nrows=2)\n\nim = ax0.pcolormesh(x, y, z, cmap=cmap, norm=norm)\nfig.colorbar(im, ax=ax0)\nax0.set_title('pcolormesh with levels')\n\n\n# contours are *point* based plots, so convert our bound into point\n# centers\ncf = ax1.contourf(x[:-1, :-1] + dx/2.,\n                  y[:-1, :-1] + dy/2., z, levels=levels,\n                  cmap=cmap)\nfig.colorbar(cf, ax=ax1)\nax1.set_title('contourf with levels')\n\n# adjust spacing between subplots so `ax1` title and `ax0` tick labels\n# don't overlap\nfig.tight_layout()\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.colors.BoundaryNorm`\n#    - `matplotlib.ticker.MaxNLocator`\n"
    },
    {
      "filename": "plot_streamplot.py",
      "title": "Plot Streamplot",
      "code": "\"\"\"\n==========\nStreamplot\n==========\n\nA stream plot, or streamline plot, is used to display 2D vector fields. This\nexample shows a few features of the `~.axes.Axes.streamplot` function:\n\n* Varying the color along a streamline.\n* Varying the density of streamlines.\n* Varying the line width along a streamline.\n* Controlling the starting points of streamlines.\n* Streamlines skipping masked regions and NaN values.\n* Unbroken streamlines even when exceeding the limit of lines within a single\n  grid cell.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nw = 3\nY, X = np.mgrid[-w:w:100j, -w:w:100j]\nU = -1 - X**2 + Y\nV = 1 + X - Y**2\nspeed = np.sqrt(U**2 + V**2)\n\nfig, axs = plt.subplots(3, 2, figsize=(7, 9), height_ratios=[1, 1, 2])\naxs = axs.flat\n\n#  Varying density along a streamline\naxs[0].streamplot(X, Y, U, V, density=[0.5, 1])\naxs[0].set_title('Varying Density')\n\n# Varying color along a streamline\nstrm = axs[1].streamplot(X, Y, U, V, color=U, linewidth=2, cmap='autumn')\nfig.colorbar(strm.lines)\naxs[1].set_title('Varying Color')\n\n#  Varying line width along a streamline\nlw = 5*speed / speed.max()\naxs[2].streamplot(X, Y, U, V, density=0.6, color='k', linewidth=lw)\naxs[2].set_title('Varying Line Width')\n\n# Controlling the starting points of the streamlines\nseed_points = np.array([[-2, -1, 0, 1, 2, -1], [-2, -1,  0, 1, 2, 2]])\n\nstrm = axs[3].streamplot(X, Y, U, V, color=U, linewidth=2,\n                         cmap='autumn', start_points=seed_points.T)\nfig.colorbar(strm.lines)\naxs[3].set_title('Controlling Starting Points')\n\n# Displaying the starting points with blue symbols.\naxs[3].plot(seed_points[0], seed_points[1], 'bo')\naxs[3].set(xlim=(-w, w), ylim=(-w, w))\n\n# Create a mask\nmask = np.zeros(U.shape, dtype=bool)\nmask[40:60, 40:60] = True\nU[:20, :20] = np.nan\nU = np.ma.array(U, mask=mask)\n\naxs[4].streamplot(X, Y, U, V, color='r')\naxs[4].set_title('Streamplot with Masking')\n\naxs[4].imshow(~mask, extent=(-w, w, -w, w), alpha=0.5, cmap='gray',\n              aspect='auto')\naxs[4].set_aspect('equal')\n\naxs[5].streamplot(X, Y, U, V, broken_streamlines=False)\naxs[5].set_title('Streamplot with unbroken streamlines')\n\nplt.tight_layout()\nplt.show()\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.streamplot` / `matplotlib.pyplot.streamplot`\n#    - `matplotlib.gridspec.GridSpec`\n"
    },
    {
      "filename": "quadmesh_demo.py",
      "title": "Quadmesh Demo",
      "code": "\"\"\"\n=============\nQuadMesh Demo\n=============\n\n`~.axes.Axes.pcolormesh` uses a `~matplotlib.collections.QuadMesh`,\na faster generalization of `~.axes.Axes.pcolor`, but with some restrictions.\n\nThis demo illustrates a bug in quadmesh with masked data.\n\"\"\"\n\nimport numpy as np\n\nfrom matplotlib import pyplot as plt\n\nn = 12\nx = np.linspace(-1.5, 1.5, n)\ny = np.linspace(-1.5, 1.5, n * 2)\nX, Y = np.meshgrid(x, y)\nQx = np.cos(Y) - np.cos(X)\nQz = np.sin(Y) + np.sin(X)\nZ = np.sqrt(X**2 + Y**2) / 5\nZ = (Z - Z.min()) / (Z.max() - Z.min())\n\n# The color array can include masked values.\nZm = np.ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z)\n\nfig, axs = plt.subplots(nrows=1, ncols=3)\naxs[0].pcolormesh(Qx, Qz, Z, shading='gouraud')\naxs[0].set_title('Without masked values')\n\n# You can control the color of the masked region.\ncmap = plt.colormaps[plt.rcParams['image.cmap']].with_extremes(bad='y')\naxs[1].pcolormesh(Qx, Qz, Zm, shading='gouraud', cmap=cmap)\naxs[1].set_title('With masked values')\n\n# Or use the default, which is transparent.\naxs[2].pcolormesh(Qx, Qz, Zm, shading='gouraud')\naxs[2].set_title('With masked values')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`\n"
    },
    {
      "filename": "quiver_demo.py",
      "title": "Quiver Demo",
      "code": "\"\"\"\n=======================================\nAdvanced quiver and quiverkey functions\n=======================================\n\nDemonstrates some more advanced options for `~.axes.Axes.quiver`.  For a simple\nexample refer to :doc:`/gallery/images_contours_and_fields/quiver_simple_demo`.\n\nNote: The plot autoscaling does not take into account the arrows, so\nthose on the boundaries may reach out of the picture.  This is not an easy\nproblem to solve in a perfectly general way.  The recommended workaround is to\nmanually set the Axes limits in such a case.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nX, Y = np.meshgrid(np.arange(0, 2 * np.pi, .2), np.arange(0, 2 * np.pi, .2))\nU = np.cos(X)\nV = np.sin(Y)\n\n# %%\n\nfig1, ax1 = plt.subplots()\nax1.set_title('Arrows scale with plot width, not view')\nQ = ax1.quiver(X, Y, U, V, units='width')\nqk = ax1.quiverkey(Q, 0.9, 0.9, 2, r'$2 \\frac{m}{s}$', labelpos='E',\n                   coordinates='figure')\n\n# %%\n\nfig2, ax2 = plt.subplots()\nax2.set_title(\"pivot='mid'; every third arrow; units='inches'\")\nQ = ax2.quiver(X[::3, ::3], Y[::3, ::3], U[::3, ::3], V[::3, ::3],\n               pivot='mid', units='inches')\nqk = ax2.quiverkey(Q, 0.9, 0.9, 1, r'$1 \\frac{m}{s}$', labelpos='E',\n                   coordinates='figure')\nax2.scatter(X[::3, ::3], Y[::3, ::3], color='r', s=5)\n\n# %%\n\n# sphinx_gallery_thumbnail_number = 3\n\nfig3, ax3 = plt.subplots()\nax3.set_title(\"pivot='tip'; scales with x view\")\nM = np.hypot(U, V)\nQ = ax3.quiver(X, Y, U, V, M, units='x', pivot='tip', width=0.022,\n               scale=1 / 0.15)\nqk = ax3.quiverkey(Q, 0.9, 0.9, 1, r'$1 \\frac{m}{s}$', labelpos='E',\n                   coordinates='figure')\nax3.scatter(X, Y, color='0.5', s=1)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.quiver` / `matplotlib.pyplot.quiver`\n#    - `matplotlib.axes.Axes.quiverkey` / `matplotlib.pyplot.quiverkey`\n"
    },
    {
      "filename": "quiver_simple_demo.py",
      "title": "Quiver Simple Demo",
      "code": "\"\"\"\n==================\nQuiver Simple Demo\n==================\n\nA simple example of a `~.axes.Axes.quiver` plot with a `~.axes.Axes.quiverkey`.\n\nFor more advanced options refer to\n:doc:`/gallery/images_contours_and_fields/quiver_demo`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nX = np.arange(-10, 10, 1)\nY = np.arange(-10, 10, 1)\nU, V = np.meshgrid(X, Y)\n\nfig, ax = plt.subplots()\nq = ax.quiver(X, Y, U, V)\nax.quiverkey(q, X=0.3, Y=1.1, U=10,\n             label='Quiver key, length = 10', labelpos='E')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.quiver` / `matplotlib.pyplot.quiver`\n#    - `matplotlib.axes.Axes.quiverkey` / `matplotlib.pyplot.quiverkey`\n"
    },
    {
      "filename": "shading_example.py",
      "title": "Shading Example",
      "code": "\"\"\"\n===============\nShading example\n===============\n\nExample showing how to make shaded relief plots like Mathematica_ or\n`Generic Mapping Tools`_.\n\n.. _Mathematica: http://reference.wolfram.com/mathematica/ref/ReliefPlot.html\n.. _Generic Mapping Tools: https://www.generic-mapping-tools.org/\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom matplotlib.colors import LightSource\n\n\ndef main():\n    # Test data\n    x, y = np.mgrid[-5:5:0.05, -5:5:0.05]\n    z = 5 * (np.sqrt(x**2 + y**2) + np.sin(x**2 + y**2))\n\n    dem = cbook.get_sample_data('jacksboro_fault_dem.npz')\n    elev = dem['elevation']\n\n    fig = compare(z, plt.cm.copper)\n    fig.suptitle('HSV Blending Looks Best with Smooth Surfaces', y=0.95)\n\n    fig = compare(elev, plt.cm.gist_earth, ve=0.05)\n    fig.suptitle('Overlay Blending Looks Best with Rough Surfaces', y=0.95)\n\n    plt.show()\n\n\ndef compare(z, cmap, ve=1):\n    # Create subplots and hide ticks\n    fig, axs = plt.subplots(ncols=2, nrows=2)\n    for ax in axs.flat:\n        ax.set(xticks=[], yticks=[])\n\n    # Illuminate the scene from the northwest\n    ls = LightSource(azdeg=315, altdeg=45)\n\n    axs[0, 0].imshow(z, cmap=cmap)\n    axs[0, 0].set(xlabel='Colormapped Data')\n\n    axs[0, 1].imshow(ls.hillshade(z, vert_exag=ve), cmap='gray')\n    axs[0, 1].set(xlabel='Illumination Intensity')\n\n    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='hsv')\n    axs[1, 0].imshow(rgb)\n    axs[1, 0].set(xlabel='Blend Mode: \"hsv\" (default)')\n\n    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='overlay')\n    axs[1, 1].imshow(rgb)\n    axs[1, 1].set(xlabel='Blend Mode: \"overlay\"')\n\n    return fig\n\n\nif __name__ == '__main__':\n    main()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors.LightSource`\n#    - `matplotlib.axes.Axes.imshow` / `matplotlib.pyplot.imshow`\n"
    },
    {
      "filename": "specgram_demo.py",
      "title": "Specgram Demo",
      "code": "\"\"\"\n===========\nSpectrogram\n===========\n\nPlotting a spectrogram using `~.Axes.specgram`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.0005\nt = np.arange(0.0, 20.5, dt)\ns1 = np.sin(2 * np.pi * 100 * t)\ns2 = 2 * np.sin(2 * np.pi * 400 * t)\n\n# create a transient \"chirp\"\ns2[t <= 10] = s2[12 <= t] = 0\n\n# add some noise into the mix\nnse = 0.01 * np.random.random(size=len(t))\n\nx = s1 + s2 + nse  # the signal\nNFFT = 1024  # the length of the windowing segments\nFs = 1/dt  # the sampling frequency\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, sharex=True)\nax1.plot(t, x)\nax1.set_ylabel('Signal')\n\nPxx, freqs, bins, im = ax2.specgram(x, NFFT=NFFT, Fs=Fs)\n# The `specgram` method returns 4 objects. They are:\n# - Pxx: the periodogram\n# - freqs: the frequency vector\n# - bins: the centers of the time bins\n# - im: the .image.AxesImage instance representing the data in the plot\nax2.set_xlabel('Time (s)')\nax2.set_ylabel('Frequency (Hz)')\nax2.set_xlim(0, 20)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.specgram` / `matplotlib.pyplot.specgram`\n"
    },
    {
      "filename": "spy_demos.py",
      "title": "Spy Demos",
      "code": "\"\"\"\n=========\nSpy Demos\n=========\n\nPlot the sparsity pattern of arrays.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, axs = plt.subplots(2, 2)\nax1 = axs[0, 0]\nax2 = axs[0, 1]\nax3 = axs[1, 0]\nax4 = axs[1, 1]\n\nx = np.random.randn(20, 20)\nx[5, :] = 0.\nx[:, 12] = 0.\n\nax1.spy(x, markersize=5)\nax2.spy(x, precision=0.1, markersize=5)\n\nax3.spy(x)\nax4.spy(x, precision=0.1)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.spy` / `matplotlib.pyplot.spy`\n"
    },
    {
      "filename": "tricontour_demo.py",
      "title": "Tricontour Demo",
      "code": "\"\"\"\n===============\nTricontour Demo\n===============\n\nContour plots of unstructured triangular grids.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# %%\n# Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.\n\n# First create the x and y coordinates of the points.\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = (np.cos(radii) * np.cos(3 * angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# %%\n# pcolor plot.\n\nfig1, ax1 = plt.subplots()\nax1.set_aspect('equal')\ntcf = ax1.tricontourf(triang, z)\nfig1.colorbar(tcf)\nax1.tricontour(triang, z, colors='k')\nax1.set_title('Contour plot of Delaunay triangulation')\n\n\n# %%\n# You could also specify hatching patterns along with different cmaps.\n\nfig2, ax2 = plt.subplots()\nax2.set_aspect(\"equal\")\ntcf = ax2.tricontourf(\n    triang,\n    z,\n    hatches=[\"*\", \"-\", \"/\", \"//\", \"\\\\\", None],\n    cmap=\"cividis\"\n)\nfig2.colorbar(tcf)\nax2.tricontour(triang, z, linestyles=\"solid\", colors=\"k\", linewidths=2.0)\nax2.set_title(\"Hatched Contour plot of Delaunay triangulation\")\n\n# %%\n# You could also generate hatching patterns labeled with no color.\n\nfig3, ax3 = plt.subplots()\nn_levels = 7\ntcf = ax3.tricontourf(\n    triang,\n    z,\n    n_levels,\n    colors=\"none\",\n    hatches=[\".\", \"/\", \"\\\\\", None, \"\\\\\\\\\", \"*\"],\n)\nax3.tricontour(triang, z, n_levels, colors=\"black\", linestyles=\"-\")\n\n\n# create a legend for the contour set\nartists, labels = tcf.legend_elements(str_format=\"{:2.1f}\".format)\nax3.legend(artists, labels, handleheight=2, framealpha=1)\n\n# %%\n# You can specify your own triangulation rather than perform a Delaunay\n# triangulation of the points, where each triangle is given by the indices of\n# the three points that make up the triangle, ordered in either a clockwise or\n# anticlockwise manner.\n\nxy = np.asarray([\n    [-0.101, 0.872], [-0.080, 0.883], [-0.069, 0.888], [-0.054, 0.890],\n    [-0.045, 0.897], [-0.057, 0.895], [-0.073, 0.900], [-0.087, 0.898],\n    [-0.090, 0.904], [-0.069, 0.907], [-0.069, 0.921], [-0.080, 0.919],\n    [-0.073, 0.928], [-0.052, 0.930], [-0.048, 0.942], [-0.062, 0.949],\n    [-0.054, 0.958], [-0.069, 0.954], [-0.087, 0.952], [-0.087, 0.959],\n    [-0.080, 0.966], [-0.085, 0.973], [-0.087, 0.965], [-0.097, 0.965],\n    [-0.097, 0.975], [-0.092, 0.984], [-0.101, 0.980], [-0.108, 0.980],\n    [-0.104, 0.987], [-0.102, 0.993], [-0.115, 1.001], [-0.099, 0.996],\n    [-0.101, 1.007], [-0.090, 1.010], [-0.087, 1.021], [-0.069, 1.021],\n    [-0.052, 1.022], [-0.052, 1.017], [-0.069, 1.010], [-0.064, 1.005],\n    [-0.048, 1.005], [-0.031, 1.005], [-0.031, 0.996], [-0.040, 0.987],\n    [-0.045, 0.980], [-0.052, 0.975], [-0.040, 0.973], [-0.026, 0.968],\n    [-0.020, 0.954], [-0.006, 0.947], [ 0.003, 0.935], [ 0.006, 0.926],\n    [ 0.005, 0.921], [ 0.022, 0.923], [ 0.033, 0.912], [ 0.029, 0.905],\n    [ 0.017, 0.900], [ 0.012, 0.895], [ 0.027, 0.893], [ 0.019, 0.886],\n    [ 0.001, 0.883], [-0.012, 0.884], [-0.029, 0.883], [-0.038, 0.879],\n    [-0.057, 0.881], [-0.062, 0.876], [-0.078, 0.876], [-0.087, 0.872],\n    [-0.030, 0.907], [-0.007, 0.905], [-0.057, 0.916], [-0.025, 0.933],\n    [-0.077, 0.990], [-0.059, 0.993]])\nx = np.degrees(xy[:, 0])\ny = np.degrees(xy[:, 1])\nx0 = -5\ny0 = 52\nz = np.exp(-0.01 * ((x - x0) ** 2 + (y - y0) ** 2))\n\ntriangles = np.asarray([\n    [67, 66,  1], [65,  2, 66], [ 1, 66,  2], [64,  2, 65], [63,  3, 64],\n    [60, 59, 57], [ 2, 64,  3], [ 3, 63,  4], [ 0, 67,  1], [62,  4, 63],\n    [57, 59, 56], [59, 58, 56], [61, 60, 69], [57, 69, 60], [ 4, 62, 68],\n    [ 6,  5,  9], [61, 68, 62], [69, 68, 61], [ 9,  5, 70], [ 6,  8,  7],\n    [ 4, 70,  5], [ 8,  6,  9], [56, 69, 57], [69, 56, 52], [70, 10,  9],\n    [54, 53, 55], [56, 55, 53], [68, 70,  4], [52, 56, 53], [11, 10, 12],\n    [69, 71, 68], [68, 13, 70], [10, 70, 13], [51, 50, 52], [13, 68, 71],\n    [52, 71, 69], [12, 10, 13], [71, 52, 50], [71, 14, 13], [50, 49, 71],\n    [49, 48, 71], [14, 16, 15], [14, 71, 48], [17, 19, 18], [17, 20, 19],\n    [48, 16, 14], [48, 47, 16], [47, 46, 16], [16, 46, 45], [23, 22, 24],\n    [21, 24, 22], [17, 16, 45], [20, 17, 45], [21, 25, 24], [27, 26, 28],\n    [20, 72, 21], [25, 21, 72], [45, 72, 20], [25, 28, 26], [44, 73, 45],\n    [72, 45, 73], [28, 25, 29], [29, 25, 31], [43, 73, 44], [73, 43, 40],\n    [72, 73, 39], [72, 31, 25], [42, 40, 43], [31, 30, 29], [39, 73, 40],\n    [42, 41, 40], [72, 33, 31], [32, 31, 33], [39, 38, 72], [33, 72, 38],\n    [33, 38, 34], [37, 35, 38], [34, 38, 35], [35, 37, 36]])\n\n# %%\n# Rather than create a Triangulation object, can simply pass x, y and triangles\n# arrays to tripcolor directly.  It would be better to use a Triangulation\n# object if the same triangulation was to be used more than once to save\n# duplicated calculations.\n\nfig4, ax4 = plt.subplots()\nax4.set_aspect('equal')\ntcf = ax4.tricontourf(x, y, triangles, z)\nfig4.colorbar(tcf)\nax4.set_title('Contour plot of user-specified triangulation')\nax4.set_xlabel('Longitude (degrees)')\nax4.set_ylabel('Latitude (degrees)')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`\n#    - `matplotlib.tri.Triangulation`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.contour.ContourSet.legend_elements`\n"
    },
    {
      "filename": "tricontour_smooth_delaunay.py",
      "title": "Tricontour Smooth Delaunay",
      "code": "\"\"\"\n==========================\nTricontour Smooth Delaunay\n==========================\n\nDemonstrates high-resolution tricontouring of a random set of points;\na `matplotlib.tri.TriAnalyzer` is used to improve the plot quality.\n\nThe initial data points and triangular grid for this demo are:\n\n- a set of random points is instantiated, inside [-1, 1] x [-1, 1] square\n- A Delaunay triangulation of these points is then computed, of which a\n  random subset of triangles is masked out by the user (based on\n  *init_mask_frac* parameter). This simulates invalidated data.\n\nThe proposed generic procedure to obtain a high resolution contouring of such\na data set is the following:\n\n1. Compute an extended mask with a `matplotlib.tri.TriAnalyzer`, which will\n   exclude badly shaped (flat) triangles from the border of the\n   triangulation. Apply the mask to the triangulation (using set_mask).\n2. Refine and interpolate the data using a `matplotlib.tri.UniformTriRefiner`.\n3. Plot the refined data with `~.axes.Axes.tricontour`.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.tri import TriAnalyzer, Triangulation, UniformTriRefiner\n\n\n# ----------------------------------------------------------------------------\n# Analytical test function\n# ----------------------------------------------------------------------------\ndef experiment_res(x, y):\n    \"\"\"An analytic function representing experiment results.\"\"\"\n    x = 2 * x\n    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)\n    theta1 = np.arctan2(0.5 - x, 0.5 - y)\n    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)\n    theta2 = np.arctan2(-x - 0.2, -y - 0.2)\n    z = (4 * (np.exp((r1/10)**2) - 1) * 30 * np.cos(3 * theta1) +\n         (np.exp((r2/10)**2) - 1) * 30 * np.cos(5 * theta2) +\n         2 * (x**2 + y**2))\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n# ----------------------------------------------------------------------------\n# Generating the initial data test points and triangulation for the demo\n# ----------------------------------------------------------------------------\n# User parameters for data test points\n\n# Number of test data points, tested from 3 to 5000 for subdiv=3\nn_test = 200\n\n# Number of recursive subdivisions of the initial mesh for smooth plots.\n# Values >3 might result in a very high number of triangles for the refine\n# mesh: new triangles numbering = (4**subdiv)*ntri\nsubdiv = 3\n\n# Float > 0. adjusting the proportion of (invalid) initial triangles which will\n# be masked out. Enter 0 for no mask.\ninit_mask_frac = 0.0\n\n# Minimum circle ratio - border triangles with circle ratio below this will be\n# masked if they touch a border. Suggested value 0.01; use -1 to keep all\n# triangles.\nmin_circle_ratio = .01\n\n# Random points\nrandom_gen = np.random.RandomState(seed=19680801)\nx_test = random_gen.uniform(-1., 1., size=n_test)\ny_test = random_gen.uniform(-1., 1., size=n_test)\nz_test = experiment_res(x_test, y_test)\n\n# meshing with Delaunay triangulation\ntri = Triangulation(x_test, y_test)\nntri = tri.triangles.shape[0]\n\n# Some invalid data are masked out\nmask_init = np.zeros(ntri, dtype=bool)\nmasked_tri = random_gen.randint(0, ntri, int(ntri * init_mask_frac))\nmask_init[masked_tri] = True\ntri.set_mask(mask_init)\n\n\n# ----------------------------------------------------------------------------\n# Improving the triangulation before high-res plots: removing flat triangles\n# ----------------------------------------------------------------------------\n# masking badly shaped triangles at the border of the triangular mesh.\nmask = TriAnalyzer(tri).get_flat_tri_mask(min_circle_ratio)\ntri.set_mask(mask)\n\n# refining the data\nrefiner = UniformTriRefiner(tri)\ntri_refi, z_test_refi = refiner.refine_field(z_test, subdiv=subdiv)\n\n# analytical 'results' for comparison\nz_expected = experiment_res(tri_refi.x, tri_refi.y)\n\n# for the demo: loading the 'flat' triangles for plot\nflat_tri = Triangulation(x_test, y_test)\nflat_tri.set_mask(~mask)\n\n\n# ----------------------------------------------------------------------------\n# Now the plots\n# ----------------------------------------------------------------------------\n# User options for plots\nplot_tri = True          # plot of base triangulation\nplot_masked_tri = True   # plot of excessively flat excluded triangles\nplot_refi_tri = False    # plot of refined triangulation\nplot_expected = False    # plot of analytical function values for comparison\n\n\n# Graphical options for tricontouring\nlevels = np.arange(0., 1., 0.025)\n\nfig, ax = plt.subplots()\nax.set_aspect('equal')\nax.set_title(\"Filtering a Delaunay mesh\\n\"\n             \"(application to high-resolution tricontouring)\")\n\n# 1) plot of the refined (computed) data contours:\nax.tricontour(tri_refi, z_test_refi, levels=levels, cmap='Blues',\n              linewidths=[2.0, 0.5, 1.0, 0.5])\n# 2) plot of the expected (analytical) data contours (dashed):\nif plot_expected:\n    ax.tricontour(tri_refi, z_expected, levels=levels, cmap='Blues',\n                  linestyles='--')\n# 3) plot of the fine mesh on which interpolation was done:\nif plot_refi_tri:\n    ax.triplot(tri_refi, color='0.97')\n# 4) plot of the initial 'coarse' mesh:\nif plot_tri:\n    ax.triplot(tri, color='0.7')\n# 4) plot of the unvalidated triangles from naive Delaunay Triangulation:\nif plot_masked_tri:\n    ax.triplot(flat_tri, color='red')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontour` / `matplotlib.pyplot.tricontour`\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`\n#    - `matplotlib.axes.Axes.triplot` / `matplotlib.pyplot.triplot`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`\n#    - `matplotlib.tri.TriAnalyzer`\n#    - `matplotlib.tri.UniformTriRefiner`\n"
    },
    {
      "filename": "tricontour_smooth_user.py",
      "title": "Tricontour Smooth User",
      "code": "\"\"\"\n======================\nTricontour Smooth User\n======================\n\nDemonstrates high-resolution tricontouring on user-defined triangular grids\nwith `matplotlib.tri.UniformTriRefiner`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n\n# ----------------------------------------------------------------------------\n# Analytical test function\n# ----------------------------------------------------------------------------\ndef function_z(x, y):\n    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)\n    theta1 = np.arctan2(0.5 - x, 0.5 - y)\n    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)\n    theta2 = np.arctan2(-x - 0.2, -y - 0.2)\n    z = -(2 * (np.exp((r1 / 10)**2) - 1) * 30. * np.cos(7. * theta1) +\n          (np.exp((r2 / 10)**2) - 1) * 30. * np.cos(11. * theta2) +\n          0.7 * (x**2 + y**2))\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n# ----------------------------------------------------------------------------\n# Creating a Triangulation\n# ----------------------------------------------------------------------------\n# First create the x and y coordinates of the points.\nn_angles = 20\nn_radii = 10\nmin_radius = 0.15\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = function_z(x, y)\n\n# Now create the Triangulation.\n# (Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.)\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# ----------------------------------------------------------------------------\n# Refine data\n# ----------------------------------------------------------------------------\nrefiner = tri.UniformTriRefiner(triang)\ntri_refi, z_test_refi = refiner.refine_field(z, subdiv=3)\n\n# ----------------------------------------------------------------------------\n# Plot the triangulation and the high-res iso-contours\n# ----------------------------------------------------------------------------\nfig, ax = plt.subplots()\nax.set_aspect('equal')\nax.triplot(triang, lw=0.5, color='white')\n\nlevels = np.arange(0., 1., 0.025)\nax.tricontourf(tri_refi, z_test_refi, levels=levels, cmap='terrain')\nax.tricontour(tri_refi, z_test_refi, levels=levels,\n              colors=['0.25', '0.5', '0.5', '0.5', '0.5'],\n              linewidths=[1.0, 0.5, 0.5, 0.5, 0.5])\n\nax.set_title(\"High-resolution tricontouring\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontour` / `matplotlib.pyplot.tricontour`\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`\n#    - `matplotlib.tri.UniformTriRefiner`\n"
    },
    {
      "filename": "trigradient_demo.py",
      "title": "Trigradient Demo",
      "code": "\"\"\"\n================\nTrigradient Demo\n================\n\nDemonstrates computation of gradient with\n`matplotlib.tri.CubicTriInterpolator`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.tri import (CubicTriInterpolator, Triangulation,\n                            UniformTriRefiner)\n\n\n# ----------------------------------------------------------------------------\n# Electrical potential of a dipole\n# ----------------------------------------------------------------------------\ndef dipole_potential(x, y):\n    \"\"\"The electric dipole potential V, at position *x*, *y*.\"\"\"\n    r_sq = x**2 + y**2\n    theta = np.arctan2(y, x)\n    z = np.cos(theta)/r_sq\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n\n# ----------------------------------------------------------------------------\n# Creating a Triangulation\n# ----------------------------------------------------------------------------\n# First create the x and y coordinates of the points.\nn_angles = 30\nn_radii = 10\nmin_radius = 0.2\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nV = dipole_potential(x, y)\n\n# Create the Triangulation; no triangles specified so Delaunay triangulation\n# created.\ntriang = Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# ----------------------------------------------------------------------------\n# Refine data - interpolates the electrical potential V\n# ----------------------------------------------------------------------------\nrefiner = UniformTriRefiner(triang)\ntri_refi, z_test_refi = refiner.refine_field(V, subdiv=3)\n\n# ----------------------------------------------------------------------------\n# Computes the electrical field (Ex, Ey) as gradient of electrical potential\n# ----------------------------------------------------------------------------\ntci = CubicTriInterpolator(triang, -V)\n# Gradient requested here at the mesh nodes but could be anywhere else:\n(Ex, Ey) = tci.gradient(triang.x, triang.y)\nE_norm = np.sqrt(Ex**2 + Ey**2)\n\n# ----------------------------------------------------------------------------\n# Plot the triangulation, the potential iso-contours and the vector field\n# ----------------------------------------------------------------------------\nfig, ax = plt.subplots()\nax.set_aspect('equal')\n# Enforce the margins, and enlarge them to give room for the vectors.\nax.use_sticky_edges = False\nax.margins(0.07)\n\nax.triplot(triang, color='0.8')\n\nlevels = np.arange(0., 1., 0.01)\nax.tricontour(tri_refi, z_test_refi, levels=levels, cmap='hot',\n              linewidths=[2.0, 1.0, 1.0, 1.0])\n# Plots direction of the electrical vector field\nax.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm,\n          units='xy', scale=10., zorder=3, color='blue',\n          width=0.007, headwidth=3., headlength=4.)\n\nax.set_title('Gradient plot: an electrical dipole')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontour` / `matplotlib.pyplot.tricontour`\n#    - `matplotlib.axes.Axes.triplot` / `matplotlib.pyplot.triplot`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`\n#    - `matplotlib.tri.CubicTriInterpolator`\n#    - `matplotlib.tri.CubicTriInterpolator.gradient`\n#    - `matplotlib.tri.UniformTriRefiner`\n#    - `matplotlib.axes.Axes.quiver` / `matplotlib.pyplot.quiver`\n"
    },
    {
      "filename": "triinterp_demo.py",
      "title": "Triinterp Demo",
      "code": "\"\"\"\n==============\nTriinterp Demo\n==============\n\nInterpolation from triangular grid to quad grid.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as mtri\n\n# Create triangulation.\nx = np.asarray([0, 1, 2, 3, 0.5, 1.5, 2.5, 1, 2, 1.5])\ny = np.asarray([0, 0, 0, 0, 1.0, 1.0, 1.0, 2, 2, 3.0])\ntriangles = [[0, 1, 4], [1, 2, 5], [2, 3, 6], [1, 5, 4], [2, 6, 5], [4, 5, 7],\n             [5, 6, 8], [5, 8, 7], [7, 8, 9]]\ntriang = mtri.Triangulation(x, y, triangles)\n\n# Interpolate to regularly-spaced quad grid.\nz = np.cos(1.5 * x) * np.cos(1.5 * y)\nxi, yi = np.meshgrid(np.linspace(0, 3, 20), np.linspace(0, 3, 20))\n\ninterp_lin = mtri.LinearTriInterpolator(triang, z)\nzi_lin = interp_lin(xi, yi)\n\ninterp_cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom')\nzi_cubic_geom = interp_cubic_geom(xi, yi)\n\ninterp_cubic_min_E = mtri.CubicTriInterpolator(triang, z, kind='min_E')\nzi_cubic_min_E = interp_cubic_min_E(xi, yi)\n\n# Set up the figure\nfig, axs = plt.subplots(nrows=2, ncols=2)\naxs = axs.flatten()\n\n# Plot the triangulation.\naxs[0].tricontourf(triang, z)\naxs[0].triplot(triang, 'ko-')\naxs[0].set_title('Triangular grid')\n\n# Plot linear interpolation to quad grid.\naxs[1].contourf(xi, yi, zi_lin)\naxs[1].plot(xi, yi, 'k-', lw=0.5, alpha=0.5)\naxs[1].plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)\naxs[1].set_title(\"Linear interpolation\")\n\n# Plot cubic interpolation to quad grid, kind=geom\naxs[2].contourf(xi, yi, zi_cubic_geom)\naxs[2].plot(xi, yi, 'k-', lw=0.5, alpha=0.5)\naxs[2].plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)\naxs[2].set_title(\"Cubic interpolation,\\nkind='geom'\")\n\n# Plot cubic interpolation to quad grid, kind=min_E\naxs[3].contourf(xi, yi, zi_cubic_min_E)\naxs[3].plot(xi, yi, 'k-', lw=0.5, alpha=0.5)\naxs[3].plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)\naxs[3].set_title(\"Cubic interpolation,\\nkind='min_E'\")\n\nfig.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tricontourf` / `matplotlib.pyplot.tricontourf`\n#    - `matplotlib.axes.Axes.triplot` / `matplotlib.pyplot.triplot`\n#    - `matplotlib.axes.Axes.contourf` / `matplotlib.pyplot.contourf`\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.LinearTriInterpolator`\n#    - `matplotlib.tri.CubicTriInterpolator`\n#    - `matplotlib.tri.Triangulation`\n"
    },
    {
      "filename": "tripcolor_demo.py",
      "title": "Tripcolor Demo",
      "code": "\"\"\"\n==============\nTripcolor Demo\n==============\n\nPseudocolor plots of unstructured triangular grids.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# %%\n# Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.\n\n# First create the x and y coordinates of the points.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = (np.cos(radii) * np.cos(3 * angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# %%\n# tripcolor plot.\n\nfig1, ax1 = plt.subplots()\nax1.set_aspect('equal')\ntpc = ax1.tripcolor(triang, z, shading='flat')\nfig1.colorbar(tpc)\nax1.set_title('tripcolor of Delaunay triangulation, flat shading')\n\n# %%\n# Illustrate Gouraud shading.\n\nfig2, ax2 = plt.subplots()\nax2.set_aspect('equal')\ntpc = ax2.tripcolor(triang, z, shading='gouraud')\nfig2.colorbar(tpc)\nax2.set_title('tripcolor of Delaunay triangulation, gouraud shading')\n\n\n# %%\n# You can specify your own triangulation rather than perform a Delaunay\n# triangulation of the points, where each triangle is given by the indices of\n# the three points that make up the triangle, ordered in either a clockwise or\n# anticlockwise manner.\n\nxy = np.asarray([\n    [-0.101, 0.872], [-0.080, 0.883], [-0.069, 0.888], [-0.054, 0.890],\n    [-0.045, 0.897], [-0.057, 0.895], [-0.073, 0.900], [-0.087, 0.898],\n    [-0.090, 0.904], [-0.069, 0.907], [-0.069, 0.921], [-0.080, 0.919],\n    [-0.073, 0.928], [-0.052, 0.930], [-0.048, 0.942], [-0.062, 0.949],\n    [-0.054, 0.958], [-0.069, 0.954], [-0.087, 0.952], [-0.087, 0.959],\n    [-0.080, 0.966], [-0.085, 0.973], [-0.087, 0.965], [-0.097, 0.965],\n    [-0.097, 0.975], [-0.092, 0.984], [-0.101, 0.980], [-0.108, 0.980],\n    [-0.104, 0.987], [-0.102, 0.993], [-0.115, 1.001], [-0.099, 0.996],\n    [-0.101, 1.007], [-0.090, 1.010], [-0.087, 1.021], [-0.069, 1.021],\n    [-0.052, 1.022], [-0.052, 1.017], [-0.069, 1.010], [-0.064, 1.005],\n    [-0.048, 1.005], [-0.031, 1.005], [-0.031, 0.996], [-0.040, 0.987],\n    [-0.045, 0.980], [-0.052, 0.975], [-0.040, 0.973], [-0.026, 0.968],\n    [-0.020, 0.954], [-0.006, 0.947], [ 0.003, 0.935], [ 0.006, 0.926],\n    [ 0.005, 0.921], [ 0.022, 0.923], [ 0.033, 0.912], [ 0.029, 0.905],\n    [ 0.017, 0.900], [ 0.012, 0.895], [ 0.027, 0.893], [ 0.019, 0.886],\n    [ 0.001, 0.883], [-0.012, 0.884], [-0.029, 0.883], [-0.038, 0.879],\n    [-0.057, 0.881], [-0.062, 0.876], [-0.078, 0.876], [-0.087, 0.872],\n    [-0.030, 0.907], [-0.007, 0.905], [-0.057, 0.916], [-0.025, 0.933],\n    [-0.077, 0.990], [-0.059, 0.993]])\nx, y = np.rad2deg(xy).T\n\ntriangles = np.asarray([\n    [67, 66,  1], [65,  2, 66], [ 1, 66,  2], [64,  2, 65], [63,  3, 64],\n    [60, 59, 57], [ 2, 64,  3], [ 3, 63,  4], [ 0, 67,  1], [62,  4, 63],\n    [57, 59, 56], [59, 58, 56], [61, 60, 69], [57, 69, 60], [ 4, 62, 68],\n    [ 6,  5,  9], [61, 68, 62], [69, 68, 61], [ 9,  5, 70], [ 6,  8,  7],\n    [ 4, 70,  5], [ 8,  6,  9], [56, 69, 57], [69, 56, 52], [70, 10,  9],\n    [54, 53, 55], [56, 55, 53], [68, 70,  4], [52, 56, 53], [11, 10, 12],\n    [69, 71, 68], [68, 13, 70], [10, 70, 13], [51, 50, 52], [13, 68, 71],\n    [52, 71, 69], [12, 10, 13], [71, 52, 50], [71, 14, 13], [50, 49, 71],\n    [49, 48, 71], [14, 16, 15], [14, 71, 48], [17, 19, 18], [17, 20, 19],\n    [48, 16, 14], [48, 47, 16], [47, 46, 16], [16, 46, 45], [23, 22, 24],\n    [21, 24, 22], [17, 16, 45], [20, 17, 45], [21, 25, 24], [27, 26, 28],\n    [20, 72, 21], [25, 21, 72], [45, 72, 20], [25, 28, 26], [44, 73, 45],\n    [72, 45, 73], [28, 25, 29], [29, 25, 31], [43, 73, 44], [73, 43, 40],\n    [72, 73, 39], [72, 31, 25], [42, 40, 43], [31, 30, 29], [39, 73, 40],\n    [42, 41, 40], [72, 33, 31], [32, 31, 33], [39, 38, 72], [33, 72, 38],\n    [33, 38, 34], [37, 35, 38], [34, 38, 35], [35, 37, 36]])\n\nxmid = x[triangles].mean(axis=1)\nymid = y[triangles].mean(axis=1)\nx0 = -5\ny0 = 52\nzfaces = np.exp(-0.01 * ((xmid - x0) * (xmid - x0) +\n                         (ymid - y0) * (ymid - y0)))\n\n# %%\n# Rather than create a Triangulation object, can simply pass x, y and triangles\n# arrays to tripcolor directly.  It would be better to use a Triangulation\n# object if the same triangulation was to be used more than once to save\n# duplicated calculations.\n# Can specify one color value per face rather than one per point by using the\n# *facecolors* keyword argument.\n\nfig3, ax3 = plt.subplots()\nax3.set_aspect('equal')\ntpc = ax3.tripcolor(x, y, triangles, facecolors=zfaces, edgecolors='k')\nfig3.colorbar(tpc)\nax3.set_title('tripcolor of user-specified triangulation')\nax3.set_xlabel('Longitude (degrees)')\nax3.set_ylabel('Latitude (degrees)')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tripcolor` / `matplotlib.pyplot.tripcolor`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`\n"
    },
    {
      "filename": "triplot_demo.py",
      "title": "Triplot Demo",
      "code": "\"\"\"\n============\nTriplot Demo\n============\n\nCreating and plotting unstructured triangular grids.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# %%\n# Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.\n\n# First create the x and y coordinates of the points.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# %%\n# Plot the triangulation.\n\nfig1, ax1 = plt.subplots()\nax1.set_aspect('equal')\nax1.triplot(triang, 'bo-', lw=1)\nax1.set_title('triplot of Delaunay triangulation')\n\n\n# %%\n# You can specify your own triangulation rather than perform a Delaunay\n# triangulation of the points, where each triangle is given by the indices of\n# the three points that make up the triangle, ordered in either a clockwise or\n# anticlockwise manner.\n\nxy = np.asarray([\n    [-0.101, 0.872], [-0.080, 0.883], [-0.069, 0.888], [-0.054, 0.890],\n    [-0.045, 0.897], [-0.057, 0.895], [-0.073, 0.900], [-0.087, 0.898],\n    [-0.090, 0.904], [-0.069, 0.907], [-0.069, 0.921], [-0.080, 0.919],\n    [-0.073, 0.928], [-0.052, 0.930], [-0.048, 0.942], [-0.062, 0.949],\n    [-0.054, 0.958], [-0.069, 0.954], [-0.087, 0.952], [-0.087, 0.959],\n    [-0.080, 0.966], [-0.085, 0.973], [-0.087, 0.965], [-0.097, 0.965],\n    [-0.097, 0.975], [-0.092, 0.984], [-0.101, 0.980], [-0.108, 0.980],\n    [-0.104, 0.987], [-0.102, 0.993], [-0.115, 1.001], [-0.099, 0.996],\n    [-0.101, 1.007], [-0.090, 1.010], [-0.087, 1.021], [-0.069, 1.021],\n    [-0.052, 1.022], [-0.052, 1.017], [-0.069, 1.010], [-0.064, 1.005],\n    [-0.048, 1.005], [-0.031, 1.005], [-0.031, 0.996], [-0.040, 0.987],\n    [-0.045, 0.980], [-0.052, 0.975], [-0.040, 0.973], [-0.026, 0.968],\n    [-0.020, 0.954], [-0.006, 0.947], [ 0.003, 0.935], [ 0.006, 0.926],\n    [ 0.005, 0.921], [ 0.022, 0.923], [ 0.033, 0.912], [ 0.029, 0.905],\n    [ 0.017, 0.900], [ 0.012, 0.895], [ 0.027, 0.893], [ 0.019, 0.886],\n    [ 0.001, 0.883], [-0.012, 0.884], [-0.029, 0.883], [-0.038, 0.879],\n    [-0.057, 0.881], [-0.062, 0.876], [-0.078, 0.876], [-0.087, 0.872],\n    [-0.030, 0.907], [-0.007, 0.905], [-0.057, 0.916], [-0.025, 0.933],\n    [-0.077, 0.990], [-0.059, 0.993]])\nx = np.degrees(xy[:, 0])\ny = np.degrees(xy[:, 1])\n\ntriangles = np.asarray([\n    [67, 66,  1], [65,  2, 66], [ 1, 66,  2], [64,  2, 65], [63,  3, 64],\n    [60, 59, 57], [ 2, 64,  3], [ 3, 63,  4], [ 0, 67,  1], [62,  4, 63],\n    [57, 59, 56], [59, 58, 56], [61, 60, 69], [57, 69, 60], [ 4, 62, 68],\n    [ 6,  5,  9], [61, 68, 62], [69, 68, 61], [ 9,  5, 70], [ 6,  8,  7],\n    [ 4, 70,  5], [ 8,  6,  9], [56, 69, 57], [69, 56, 52], [70, 10,  9],\n    [54, 53, 55], [56, 55, 53], [68, 70,  4], [52, 56, 53], [11, 10, 12],\n    [69, 71, 68], [68, 13, 70], [10, 70, 13], [51, 50, 52], [13, 68, 71],\n    [52, 71, 69], [12, 10, 13], [71, 52, 50], [71, 14, 13], [50, 49, 71],\n    [49, 48, 71], [14, 16, 15], [14, 71, 48], [17, 19, 18], [17, 20, 19],\n    [48, 16, 14], [48, 47, 16], [47, 46, 16], [16, 46, 45], [23, 22, 24],\n    [21, 24, 22], [17, 16, 45], [20, 17, 45], [21, 25, 24], [27, 26, 28],\n    [20, 72, 21], [25, 21, 72], [45, 72, 20], [25, 28, 26], [44, 73, 45],\n    [72, 45, 73], [28, 25, 29], [29, 25, 31], [43, 73, 44], [73, 43, 40],\n    [72, 73, 39], [72, 31, 25], [42, 40, 43], [31, 30, 29], [39, 73, 40],\n    [42, 41, 40], [72, 33, 31], [32, 31, 33], [39, 38, 72], [33, 72, 38],\n    [33, 38, 34], [37, 35, 38], [34, 38, 35], [35, 37, 36]])\n\n# %%\n# Rather than create a Triangulation object, can simply pass x, y and triangles\n# arrays to triplot directly.  It would be better to use a Triangulation object\n# if the same triangulation was to be used more than once to save duplicated\n# calculations.\n\nfig2, ax2 = plt.subplots()\nax2.set_aspect('equal')\nax2.triplot(x, y, triangles, 'go-', lw=1.0)\nax2.set_title('triplot of user-specified triangulation')\nax2.set_xlabel('Longitude (degrees)')\nax2.set_ylabel('Latitude (degrees)')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.triplot` / `matplotlib.pyplot.triplot`\n#    - `matplotlib.tri`\n#    - `matplotlib.tri.Triangulation`\n"
    },
    {
      "filename": "watermark_image.py",
      "title": "Watermark Image",
      "code": "\"\"\"\n===============\nWatermark image\n===============\n\nOverlay an image on a plot by moving it to the front (``zorder=3``) and making it\nsemi-transparent (``alpha=0.7``).\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\nimport matplotlib.image as image\n\nwith cbook.get_sample_data('logo2.png') as file:\n    im = image.imread(file)\n\nfig, ax = plt.subplots()\n\nnp.random.seed(19680801)\nx = np.arange(30)\ny = x + np.random.randn(30)\nax.bar(x, y, color='#6bbc6b')\nax.grid()\n\nfig.figimage(im, 25, 25, zorder=3, alpha=.7)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.image`\n#    - `matplotlib.image.imread` / `matplotlib.pyplot.imread`\n#    - `matplotlib.figure.Figure.figimage`\n"
    }
  ],
  "lines_bars_and_markers": [
    {
      "filename": "axline.py",
      "title": "Axline",
      "code": "\"\"\"\n==============\nInfinite lines\n==============\n\n`~.axes.Axes.axvline` and `~.axes.Axes.axhline` draw infinite vertical /\nhorizontal lines, at given *x* / *y* positions. They are usually used to mark\nspecial data values, e.g. in this example the center and limit values of the\nsigmoid function.\n\n`~.axes.Axes.axline` draws infinite straight lines in arbitrary directions.\n\n.. redirect-from:: /gallery/pyplot/axline\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(-10, 10, 100)\nsig = 1 / (1 + np.exp(-t))\n\nfig, ax = plt.subplots()\nax.axhline(y=0, color=\"black\", linestyle=\"--\")\nax.axhline(y=0.5, color=\"black\", linestyle=\":\")\nax.axhline(y=1.0, color=\"black\", linestyle=\"--\")\nax.axvline(color=\"grey\")\nax.axline((0, 0.5), slope=0.25, color=\"black\", linestyle=(0, (5, 5)))\nax.plot(t, sig, linewidth=2, label=r\"$\\sigma(t) = \\frac{1}{1 + e^{-t}}$\")\nax.set(xlim=(-10, 10), xlabel=\"t\")\nax.legend(fontsize=14)\nplt.show()\n\n# %%\n# `~.axes.Axes.axline` can also be used with a *transform* parameter, which\n# applies to the point, but not to the slope. This can be useful for drawing\n# diagonal grid lines with a fixed slope, which stay in place when the\n# plot limits are moved.\n\nfig, ax = plt.subplots()\nfor pos in np.linspace(-2, 1, 10):\n    ax.axline((pos, 0), slope=0.5, color='k', transform=ax.transAxes)\n\nax.set(xlim=(0, 1), ylim=(0, 1))\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.axhline` / `matplotlib.pyplot.axhline`\n#    - `matplotlib.axes.Axes.axvline` / `matplotlib.pyplot.axvline`\n#    - `matplotlib.axes.Axes.axline` / `matplotlib.pyplot.axline`\n#\n#\n# .. seealso::\n#\n#    `~.Axes.axhspan`, `~.Axes.axvspan` draw rectangles that span the Axes in one\n#    direction and are bounded in the other direction.\n#\n# .. tags:: component: annotation\n"
    },
    {
      "filename": "bar_colors.py",
      "title": "Bar Colors",
      "code": "\"\"\"\n====================================\nBar chart with individual bar colors\n====================================\n\nThis is an example showing how to control bar color and legend entries\nusing the *color* and *label* parameters of `~matplotlib.pyplot.bar`.\nNote that labels with a preceding underscore won't show up in the legend.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nfruits = ['apple', 'blueberry', 'cherry', 'orange']\ncounts = [40, 100, 30, 55]\nbar_labels = ['red', 'blue', '_red', 'orange']\nbar_colors = ['tab:red', 'tab:blue', 'tab:red', 'tab:orange']\n\nax.bar(fruits, counts, label=bar_labels, color=bar_colors)\n\nax.set_ylabel('fruit supply')\nax.set_title('Fruit supply by kind and color')\nax.legend(title='Fruit color')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    styling: color\n#    plot-style: bar\n#    level: beginner\n"
    },
    {
      "filename": "bar_label_demo.py",
      "title": "Bar Label Demo",
      "code": "\"\"\"\n=====================\nBar chart with labels\n=====================\n\nThis example shows how to use the `~.Axes.bar_label` helper function\nto create bar chart labels.\n\nSee also the :doc:`grouped bar\n</gallery/lines_bars_and_markers/barchart>`,\n:doc:`stacked bar\n</gallery/lines_bars_and_markers/bar_stacked>` and\n:doc:`horizontal bar chart\n</gallery/lines_bars_and_markers/barh>` examples.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n# data from https://allisonhorst.github.io/palmerpenguins/\n\nspecies = ('Adelie', 'Chinstrap', 'Gentoo')\nsex_counts = {\n    'Male': np.array([73, 34, 61]),\n    'Female': np.array([73, 34, 58]),\n}\nwidth = 0.6  # the width of the bars: can also be len(x) sequence\n\n\nfig, ax = plt.subplots()\nbottom = np.zeros(3)\n\nfor sex, sex_count in sex_counts.items():\n    p = ax.bar(species, sex_count, width, label=sex, bottom=bottom)\n    bottom += sex_count\n\n    ax.bar_label(p, label_type='center')\n\nax.set_title('Number of penguins by sex')\nax.legend()\n\nplt.show()\n\n# %%\n# Horizontal bar chart\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Example data\npeople = ('Tom', 'Dick', 'Harry', 'Slim', 'Jim')\ny_pos = np.arange(len(people))\nperformance = 3 + 10 * np.random.rand(len(people))\nerror = np.random.rand(len(people))\n\nfig, ax = plt.subplots()\n\nhbars = ax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\n# Label with specially formatted floats\nax.bar_label(hbars, fmt='%.2f')\nax.set_xlim(right=15)  # adjust xlim to fit labels\n\nplt.show()\n\n# %%\n# Some of the more advanced things that one can do with bar labels\n\nfig, ax = plt.subplots()\n\nhbars = ax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\n# Label with given captions, custom padding and annotate options\nax.bar_label(hbars, labels=[f'\u00b1{e:.2f}' for e in error],\n             padding=8, color='b', fontsize=14)\nax.set_xlim(right=16)\n\nplt.show()\n\n# %%\n# Bar labels using {}-style format string\n\nfruit_names = ['Coffee', 'Salted Caramel', 'Pistachio']\nfruit_counts = [4000, 2000, 7000]\n\nfig, ax = plt.subplots()\nbar_container = ax.bar(fruit_names, fruit_counts)\nax.set(ylabel='pints sold', title='Gelato sales by flavor', ylim=(0, 8000))\nax.bar_label(bar_container, fmt='{:,.0f}')\n\n# %%\n# Bar labels using a callable\n\nanimal_names = ['Lion', 'Gazelle', 'Cheetah']\nmph_speed = [50, 60, 75]\n\nfig, ax = plt.subplots()\nbar_container = ax.bar(animal_names, mph_speed)\nax.set(ylabel='speed in MPH', title='Running speeds', ylim=(0, 80))\nax.bar_label(bar_container, fmt=lambda x: f'{x * 1.61:.1f} km/h')\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.axes.Axes.barh` / `matplotlib.pyplot.barh`\n#    - `matplotlib.axes.Axes.bar_label` / `matplotlib.pyplot.bar_label`\n#\n# .. tags::\n#\n#    component: label\n#    plot-type: bar\n#    level: beginner\n"
    },
    {
      "filename": "bar_stacked.py",
      "title": "Bar Stacked",
      "code": "\"\"\"\n=================\nStacked bar chart\n=================\n\nThis is an example of creating a stacked bar plot\nusing `~matplotlib.pyplot.bar`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# data from https://allisonhorst.github.io/palmerpenguins/\n\nspecies = (\n    \"Adelie\\n $\\\\mu=$3700.66g\",\n    \"Chinstrap\\n $\\\\mu=$3733.09g\",\n    \"Gentoo\\n $\\\\mu=5076.02g$\",\n)\nweight_counts = {\n    \"Below\": np.array([70, 31, 58]),\n    \"Above\": np.array([82, 37, 66]),\n}\nwidth = 0.5\n\nfig, ax = plt.subplots()\nbottom = np.zeros(3)\n\nfor boolean, weight_count in weight_counts.items():\n    p = ax.bar(species, weight_count, width, label=boolean, bottom=bottom)\n    bottom += weight_count\n\nax.set_title(\"Number of penguins with above average body mass\")\nax.legend(loc=\"upper right\")\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: bar\n#    level: beginner\n"
    },
    {
      "filename": "barchart.py",
      "title": "Barchart",
      "code": "\"\"\"\n=============================\nGrouped bar chart with labels\n=============================\n\nThis example shows a how to create a grouped bar chart and how to annotate\nbars with labels.\n\"\"\"\n\n# data from https://allisonhorst.github.io/palmerpenguins/\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nspecies = (\"Adelie\", \"Chinstrap\", \"Gentoo\")\npenguin_means = {\n    'Bill Depth': (18.35, 18.43, 14.98),\n    'Bill Length': (38.79, 48.83, 47.50),\n    'Flipper Length': (189.95, 195.82, 217.19),\n}\n\nx = np.arange(len(species))  # the label locations\nwidth = 0.25  # the width of the bars\nmultiplier = 0\n\nfig, ax = plt.subplots(layout='constrained')\n\nfor attribute, measurement in penguin_means.items():\n    offset = width * multiplier\n    rects = ax.bar(x + offset, measurement, width, label=attribute)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_ylabel('Length (mm)')\nax.set_title('Penguin attributes by species')\nax.set_xticks(x + width, species)\nax.legend(loc='upper left', ncols=3)\nax.set_ylim(0, 250)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.axes.Axes.bar_label` / `matplotlib.pyplot.bar_label`\n#\n# .. tags::\n#\n#    component: label\n#    plot-type: bar\n#    level: beginner\n"
    },
    {
      "filename": "barh.py",
      "title": "Barh",
      "code": "\"\"\"\n====================\nHorizontal bar chart\n====================\n\nThis example showcases a simple horizontal bar chart.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\n# Example data\npeople = ('Tom', 'Dick', 'Harry', 'Slim', 'Jim')\ny_pos = np.arange(len(people))\nperformance = 3 + 10 * np.random.rand(len(people))\nerror = np.random.rand(len(people))\n\nax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: bar\n#    level: beginner\n"
    },
    {
      "filename": "broken_barh.py",
      "title": "Broken Barh",
      "code": "\"\"\"\n======================\nBroken horizontal bars\n======================\n\n`~.Axes.broken_barh` creates sequences of horizontal bars. This example shows\na timing diagram.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# data is a sequence of (start, duration) tuples\ncpu_1 = [(0, 3), (3.5, 1), (5, 5)]\ncpu_2 = np.column_stack([np.linspace(0, 9, 10), np.full(10, 0.5)])\ncpu_3 = np.column_stack([10*np.random.random(61), np.full(61, 0.05)])\ncpu_4 = [(2, 1.7), (7, 1.2)]\ndisk = [(1, 1.5)]\nnetwork = np.column_stack([10*np.random.random(10), np.full(10, 0.05)])\n\nfig, ax = plt.subplots()\n# broken_barh(xranges, (ymin, height))\nax.broken_barh(cpu_1, (-0.2, 0.4))\nax.broken_barh(cpu_2, (0.8, 0.4))\nax.broken_barh(cpu_3, (1.8, 0.4))\nax.broken_barh(cpu_4, (2.8, 0.4))\nax.broken_barh(disk, (3.8, 0.4), color=\"tab:orange\")\nax.broken_barh(network, (4.8, 0.4), color=\"tab:green\")\nax.set_xlim(0, 10)\nax.set_yticks(range(6),\n              labels=[\"CPU 1\", \"CPU 2\", \"CPU 3\", \"CPU 4\", \"disk\", \"network\"])\nax.invert_yaxis()\nax.set_title(\"Resource usage\")\n\nplt.show()\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.broken_barh` / `matplotlib.pyplot.broken_barh`\n#    - `matplotlib.axes.Axes.invert_yaxis`\n#    - `matplotlib.axes.Axes.set_yticks`\n#\n# .. tags::\n#\n#    component: annotation\n#    plot-type: bar\n#    level: beginner\n"
    },
    {
      "filename": "capstyle.py",
      "title": "Capstyle",
      "code": "\"\"\"\n=========\nCapStyle\n=========\n\nThe `matplotlib._enums.CapStyle` controls how Matplotlib draws the two\nendpoints (caps) of an unclosed line. For more details, see the\n`~matplotlib._enums.CapStyle` docs.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib._enums import CapStyle\n\nCapStyle.demo()\nplt.show()\n\n# %%\n# .. tags::\n#\n#    purpose: reference\n"
    },
    {
      "filename": "categorical_variables.py",
      "title": "Categorical Variables",
      "code": "\"\"\"\n==============================\nPlotting categorical variables\n==============================\n\nYou can pass categorical values (i.e. strings) directly as x- or y-values to\nmany plotting functions:\n\"\"\"\nimport matplotlib.pyplot as plt\n\ndata = {'apple': 10, 'orange': 15, 'lemon': 5, 'lime': 20}\nnames = list(data.keys())\nvalues = list(data.values())\n\nfig, axs = plt.subplots(1, 3, figsize=(9, 3), sharey=True)\naxs[0].bar(names, values)\naxs[1].scatter(names, values)\naxs[2].plot(names, values)\nfig.suptitle('Categorical Plotting')\n\n\n# %%\n# Categorical values are a mapping from names to positions. This means that\n# values that occur multiple times are mapped to the same position. See the\n# ``cat`` and ``dog`` values \"happy\" and \"bored\" on the y-axis in the following\n# example.\n\ncat = [\"bored\", \"happy\", \"bored\", \"bored\", \"happy\", \"bored\"]\ndog = [\"happy\", \"happy\", \"happy\", \"happy\", \"bored\", \"bored\"]\nactivity = [\"combing\", \"drinking\", \"feeding\", \"napping\", \"playing\", \"washing\"]\n\nfig, ax = plt.subplots()\nax.plot(activity, dog, label=\"dog\")\nax.plot(activity, cat, label=\"cat\")\nax.legend()\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: specialty\n#    level: beginner\n"
    },
    {
      "filename": "cohere.py",
      "title": "Cohere",
      "code": "\"\"\"\n=====================================\nPlotting the coherence of two signals\n=====================================\n\nAn example showing how to plot the coherence of two signals using `~.Axes.cohere`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.01\nt = np.arange(0, 30, dt)\nnse1 = np.random.randn(len(t))                 # white noise 1\nnse2 = np.random.randn(len(t))                 # white noise 2\n\n# Two signals with a coherent part at 10 Hz and a random part\ns1 = np.sin(2 * np.pi * 10 * t) + nse1\ns2 = np.sin(2 * np.pi * 10 * t) + nse2\n\nfig, axs = plt.subplots(2, 1, layout='constrained')\naxs[0].plot(t, s1, t, s2)\naxs[0].set_xlim(0, 2)\naxs[0].set_xlabel('Time (s)')\naxs[0].set_ylabel('s1 and s2')\naxs[0].grid(True)\n\ncxy, f = axs[1].cohere(s1, s2, NFFT=256, Fs=1. / dt)\naxs[1].set_ylabel('Coherence')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    domain: signal-processing\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "csd_demo.py",
      "title": "Csd Demo",
      "code": "\"\"\"\n============================\nCross spectral density (CSD)\n============================\n\nPlot the cross spectral density (CSD) of two signals using `~.Axes.csd`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, (ax1, ax2) = plt.subplots(2, 1, layout='constrained')\n\ndt = 0.01\nt = np.arange(0, 30, dt)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nnse1 = np.random.randn(len(t))                 # white noise 1\nnse2 = np.random.randn(len(t))                 # white noise 2\nr = np.exp(-t / 0.05)\n\ncnse1 = np.convolve(nse1, r, mode='same') * dt   # colored noise 1\ncnse2 = np.convolve(nse2, r, mode='same') * dt   # colored noise 2\n\n# two signals with a coherent part and a random part\ns1 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse1\ns2 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse2\n\nax1.plot(t, s1, t, s2)\nax1.set_xlim(0, 5)\nax1.set_xlabel('Time (s)')\nax1.set_ylabel('s1 and s2')\nax1.grid(True)\n\ncxy, f = ax2.csd(s1, s2, NFFT=256, Fs=1. / dt)\nax2.set_ylabel('CSD (dB)')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    domain: signal-processing\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "curve_error_band.py",
      "title": "Curve Error Band",
      "code": "\"\"\"\n=====================\nCurve with error band\n=====================\n\nThis example illustrates how to draw an error band around a parametrized curve.\n\nA parametrized curve x(t), y(t) can directly be drawn using `~.Axes.plot`.\n\"\"\"\n# sphinx_gallery_thumbnail_number = 2\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nN = 400\nt = np.linspace(0, 2 * np.pi, N)\nr = 0.5 + np.cos(t)\nx, y = r * np.cos(t), r * np.sin(t)\n\nfig, ax = plt.subplots()\nax.plot(x, y, \"k\")\nax.set(aspect=1)\n\n# %%\n# An error band can be used to indicate the uncertainty of the curve.\n# In this example we assume that the error can be given as a scalar *err*\n# that describes the uncertainty perpendicular to the curve in every point.\n#\n# We visualize this error as a colored band around the path using a\n# `.PathPatch`. The patch is created from two path segments *(xp, yp)*, and\n# *(xn, yn)* that are shifted by +/- *err* perpendicular to the curve *(x, y)*.\n#\n# Note: This method of using a `.PathPatch` is suited to arbitrary curves in\n# 2D. If you just have a standard y-vs.-x plot, you can use the simpler\n# `~.Axes.fill_between` method (see also\n# :doc:`/gallery/lines_bars_and_markers/fill_between_demo`).\n\n\ndef draw_error_band(ax, x, y, err, **kwargs):\n    # Calculate normals via centered finite differences (except the first point\n    # which uses a forward difference and the last point which uses a backward\n    # difference).\n    dx = np.concatenate([[x[1] - x[0]], x[2:] - x[:-2], [x[-1] - x[-2]]])\n    dy = np.concatenate([[y[1] - y[0]], y[2:] - y[:-2], [y[-1] - y[-2]]])\n    l = np.hypot(dx, dy)\n    nx = dy / l\n    ny = -dx / l\n\n    # end points of errors\n    xp = x + nx * err\n    yp = y + ny * err\n    xn = x - nx * err\n    yn = y - ny * err\n\n    vertices = np.block([[xp, xn[::-1]],\n                         [yp, yn[::-1]]]).T\n    codes = np.full(len(vertices), Path.LINETO)\n    codes[0] = codes[len(xp)] = Path.MOVETO\n    path = Path(vertices, codes)\n    ax.add_patch(PathPatch(path, **kwargs))\n\n\n_, axs = plt.subplots(1, 2, layout='constrained', sharex=True, sharey=True)\nerrs = [\n    (axs[0], \"constant error\", 0.05),\n    (axs[1], \"variable error\", 0.05 * np.sin(2 * t) ** 2 + 0.04),\n]\nfor i, (ax, title, err) in enumerate(errs):\n    ax.set(title=title, aspect=1, xticks=[], yticks=[])\n    ax.plot(x, y, \"k\")\n    draw_error_band(ax, x, y, err=err,\n                    facecolor=f\"C{i}\", edgecolor=\"none\", alpha=.3)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.path.Path`\n#\n# .. tags::\n#\n#    component: error\n#    plot-type: line\n#    level: intermediate\n"
    },
    {
      "filename": "errorbar_limits_simple.py",
      "title": "Errorbar Limits Simple",
      "code": "\"\"\"\n========================\nErrorbar limit selection\n========================\n\nIllustration of selectively drawing lower and/or upper limit symbols on\nerrorbars using the parameters ``uplims``, ``lolims`` of `~.pyplot.errorbar`.\n\nAlternatively, you can use 2xN values to draw errorbars in only one direction.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nx = np.arange(10)\ny = 2.5 * np.sin(x / 20 * np.pi)\nyerr = np.linspace(0.05, 0.2, 10)\n\nplt.errorbar(x, y + 3, yerr=yerr, label='both limits (default)')\n\nplt.errorbar(x, y + 2, yerr=yerr, uplims=True, label='uplims=True')\n\nplt.errorbar(x, y + 1, yerr=yerr, uplims=True, lolims=True,\n             label='uplims=True, lolims=True')\n\nupperlimits = [True, False] * 5\nlowerlimits = [False, True] * 5\nplt.errorbar(x, y, yerr=yerr, uplims=upperlimits, lolims=lowerlimits,\n             label='subsets of uplims and lolims')\n\nplt.legend(loc='lower right')\n\n\n# %%\n# Similarly ``xuplims`` and ``xlolims`` can be used on the horizontal ``xerr``\n# errorbars.\n\nfig = plt.figure()\nx = np.arange(10) / 10\ny = (x + 0.1)**2\n\nplt.errorbar(x, y, xerr=0.1, xlolims=True, label='xlolims=True')\ny = (x + 0.1)**3\n\nplt.errorbar(x + 0.6, y, xerr=0.1, xuplims=upperlimits, xlolims=lowerlimits,\n             label='subsets of xuplims and xlolims')\n\ny = (x + 0.1)**4\nplt.errorbar(x + 1.2, y, xerr=0.1, xuplims=True, label='xuplims=True')\n\nplt.legend()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`\n#\n# .. tags::\n#\n#    component: error\n#    plot-type: errorbar\n#    level: beginner\n"
    },
    {
      "filename": "errorbar_subsample.py",
      "title": "Errorbar Subsample",
      "code": "\"\"\"\n====================\nErrorbar subsampling\n====================\n\nThe parameter *errorevery* of `.Axes.errorbar` can be used to draw error bars\nonly on a subset of data points. This is particularly useful if there are many\ndata points with similar errors.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.1)\ny1 = np.exp(-1.0 * x)\ny2 = np.exp(-0.5 * x)\n\n# example variable error bar values\ny1err = 0.1 + 0.1 * np.sqrt(x)\ny2err = 0.1 + 0.1 * np.sqrt(x/2)\n\n\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=1, ncols=3, sharex=True,\n                                    figsize=(12, 6))\n\nax0.set_title('all errorbars')\nax0.errorbar(x, y1, yerr=y1err)\nax0.errorbar(x, y2, yerr=y2err)\n\nax1.set_title('only every 6th errorbar')\nax1.errorbar(x, y1, yerr=y1err, errorevery=6)\nax1.errorbar(x, y2, yerr=y2err, errorevery=6)\n\nax2.set_title('second series shifted by 3')\nax2.errorbar(x, y1, yerr=y1err, errorevery=(0, 6))\nax2.errorbar(x, y2, yerr=y2err, errorevery=(3, 6))\n\nfig.suptitle('Errorbar subsampling')\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: error\n#    plot-type: errorbar\n#    level: beginner\n"
    },
    {
      "filename": "eventcollection_demo.py",
      "title": "Eventcollection Demo",
      "code": "r\"\"\"\n====================\nEventCollection Demo\n====================\n\nPlot two curves, then use `.EventCollection`\\s to mark the locations of the x\nand y data points on the respective Axes for each curve.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import EventCollection\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# create random data\nxdata = np.random.random([2, 10])\n\n# split the data into two parts\nxdata1 = xdata[0, :]\nxdata2 = xdata[1, :]\n\n# sort the data so it makes clean curves\nxdata1.sort()\nxdata2.sort()\n\n# create some y data points\nydata1 = xdata1 ** 2\nydata2 = 1 - xdata2 ** 3\n\n# plot the data\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\nax.plot(xdata1, ydata1, color='tab:blue')\nax.plot(xdata2, ydata2, color='tab:orange')\n\n# create the events marking the x data points\nxevents1 = EventCollection(xdata1, color='tab:blue', linelength=0.05)\nxevents2 = EventCollection(xdata2, color='tab:orange', linelength=0.05)\n\n# create the events marking the y data points\nyevents1 = EventCollection(ydata1, color='tab:blue', linelength=0.05,\n                           orientation='vertical')\nyevents2 = EventCollection(ydata2, color='tab:orange', linelength=0.05,\n                           orientation='vertical')\n\n# add the events to the axis\nax.add_collection(xevents1)\nax.add_collection(xevents2)\nax.add_collection(yevents1)\nax.add_collection(yevents2)\n\n# set the limits\nax.set_xlim([0, 1])\nax.set_ylim([0, 1])\n\nax.set_title('line plot with data points')\n\n# display the plot\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: eventplot\n#    level: intermediate\n"
    },
    {
      "filename": "eventplot_demo.py",
      "title": "Eventplot Demo",
      "code": "\"\"\"\n==============\nEventplot demo\n==============\n\nAn `~.axes.Axes.eventplot` showing sequences of events with various line\nproperties. The plot is shown in both horizontal and vertical orientations.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib\n\nmatplotlib.rcParams['font.size'] = 8.0\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# create random data\ndata1 = np.random.random([6, 50])\n\n# set different colors for each set of positions\ncolors1 = [f'C{i}' for i in range(6)]\n\n# set different line properties for each set of positions\n# note that some overlap\nlineoffsets1 = [-15, -3, 1, 1.5, 6, 10]\nlinelengths1 = [5, 2, 1, 1, 3, 1.5]\n\nfig, axs = plt.subplots(2, 2)\n\n# create a horizontal plot\naxs[0, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,\n                    linelengths=linelengths1)\n\n# create a vertical plot\naxs[1, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,\n                    linelengths=linelengths1, orientation='vertical')\n\n# create another set of random data.\n# the gamma distribution is only used for aesthetic purposes\ndata2 = np.random.gamma(4, size=[60, 50])\n\n# use individual values for the parameters this time\n# these values will be used for all data sets (except lineoffsets2, which\n# sets the increment between each data set in this usage)\ncolors2 = 'black'\nlineoffsets2 = 1\nlinelengths2 = 1\n\n# create a horizontal plot\naxs[0, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,\n                    linelengths=linelengths2)\n\n\n# create a vertical plot\naxs[1, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,\n                    linelengths=linelengths2, orientation='vertical')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: eventplot\n#    level: beginner\n#    purpose: showcase\n"
    },
    {
      "filename": "fill.py",
      "title": "Fill",
      "code": "\"\"\"\n==============\nFilled polygon\n==============\n\n`~.Axes.fill()` draws a filled polygon based on lists of point\ncoordinates *x*, *y*.\n\nThis example uses the `Koch snowflake`_ as an example polygon.\n\n.. _Koch snowflake: https://en.wikipedia.org/wiki/Koch_snowflake\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef koch_snowflake(order, scale=10):\n    \"\"\"\n    Return two lists x, y of point coordinates of the Koch snowflake.\n\n    Parameters\n    ----------\n    order : int\n        The recursion depth.\n    scale : float\n        The extent of the snowflake (edge length of the base triangle).\n    \"\"\"\n    def _koch_snowflake_complex(order):\n        if order == 0:\n            # initial triangle\n            angles = np.array([0, 120, 240]) + 90\n            return scale / np.sqrt(3) * np.exp(np.deg2rad(angles) * 1j)\n        else:\n            ZR = 0.5 - 0.5j * np.sqrt(3) / 3\n\n            p1 = _koch_snowflake_complex(order - 1)  # start points\n            p2 = np.roll(p1, shift=-1)  # end points\n            dp = p2 - p1  # connection vectors\n\n            new_points = np.empty(len(p1) * 4, dtype=np.complex128)\n            new_points[::4] = p1\n            new_points[1::4] = p1 + dp / 3\n            new_points[2::4] = p1 + dp * ZR\n            new_points[3::4] = p1 + dp / 3 * 2\n            return new_points\n\n    points = _koch_snowflake_complex(order)\n    x, y = points.real, points.imag\n    return x, y\n\n\n# %%\n# Basic usage:\n\nx, y = koch_snowflake(order=5)\n\nplt.figure(figsize=(8, 8))\nplt.axis('equal')\nplt.fill(x, y)\nplt.show()\n\n# %%\n# Use keyword arguments *facecolor* and *edgecolor* to modify the colors\n# of the polygon. Since the *linewidth* of the edge is 0 in the default\n# Matplotlib style, we have to set it as well for the edge to become visible.\n\nx, y = koch_snowflake(order=2)\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(9, 3),\n                                    subplot_kw={'aspect': 'equal'})\nax1.fill(x, y)\nax2.fill(x, y, facecolor='lightsalmon', edgecolor='orangered', linewidth=3)\nax3.fill(x, y, facecolor='none', edgecolor='purple', linewidth=3)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.fill` / `matplotlib.pyplot.fill`\n#    - `matplotlib.axes.Axes.axis` / `matplotlib.pyplot.axis`\n#\n# .. tags::\n#\n#    styling: shape\n#    level: beginner\n#    purpose: showcase\n"
    },
    {
      "filename": "fill_between_alpha.py",
      "title": "Fill Between Alpha",
      "code": "\"\"\"\n==================================\n``fill_between`` with transparency\n==================================\n\nThe `~matplotlib.axes.Axes.fill_between` function generates a shaded\nregion between a min and max boundary that is useful for illustrating ranges.\nIt has a very handy ``where`` argument to combine filling with logical ranges,\ne.g., to just fill in a curve over some threshold value.\n\nAt its most basic level, ``fill_between`` can be used to enhance a graph's\nvisual appearance. Let's compare two graphs of financial data with a simple\nline plot on the left and a filled line on the right.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\n# load up some sample financial data\nr = cbook.get_sample_data('goog.npz')['price_data']\n# create two subplots with the shared x and y axes\nfig, (ax1, ax2) = plt.subplots(1, 2, sharex=True, sharey=True)\n\npricemin = r[\"close\"].min()\n\nax1.plot(r[\"date\"], r[\"close\"], lw=2)\nax2.fill_between(r[\"date\"], pricemin, r[\"close\"], alpha=0.7)\n\nfor ax in ax1, ax2:\n    ax.grid(True)\n    ax.label_outer()\n\nax1.set_ylabel('price')\n\nfig.suptitle('Google (GOOG) daily closing price')\nfig.autofmt_xdate()\n\n# %%\n# The alpha channel is not necessary here, but it can be used to soften\n# colors for more visually appealing plots.  In other examples, as we'll\n# see below, the alpha channel is functionally useful as the shaded\n# regions can overlap and alpha allows you to see both.  Note that the\n# postscript format does not support alpha (this is a postscript\n# limitation, not a matplotlib limitation), so when using alpha save\n# your figures in PNG, PDF or SVG.\n#\n# Our next example computes two populations of random walkers with a\n# different mean and standard deviation of the normal distributions from\n# which the steps are drawn.  We use filled regions to plot +/- one\n# standard deviation of the mean position of the population.  Here the\n# alpha channel is useful, not just aesthetic.\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nNsteps, Nwalkers = 100, 250\nt = np.arange(Nsteps)\n\n# an (Nsteps x Nwalkers) array of random walk steps\nS1 = 0.004 + 0.02*np.random.randn(Nsteps, Nwalkers)\nS2 = 0.002 + 0.01*np.random.randn(Nsteps, Nwalkers)\n\n# an (Nsteps x Nwalkers) array of random walker positions\nX1 = S1.cumsum(axis=0)\nX2 = S2.cumsum(axis=0)\n\n\n# Nsteps length arrays empirical means and standard deviations of both\n# populations over time\nmu1 = X1.mean(axis=1)\nsigma1 = X1.std(axis=1)\nmu2 = X2.mean(axis=1)\nsigma2 = X2.std(axis=1)\n\n# plot it!\nfig, ax = plt.subplots(1)\nax.plot(t, mu1, lw=2, label='mean population 1')\nax.plot(t, mu2, lw=2, label='mean population 2')\nax.fill_between(t, mu1+sigma1, mu1-sigma1, facecolor='C0', alpha=0.4)\nax.fill_between(t, mu2+sigma2, mu2-sigma2, facecolor='C1', alpha=0.4)\nax.set_title(r'random walkers empirical $\\mu$ and $\\pm \\sigma$ interval')\nax.legend(loc='upper left')\nax.set_xlabel('num steps')\nax.set_ylabel('position')\nax.grid()\n\n# %%\n# The ``where`` keyword argument is very handy for highlighting certain\n# regions of the graph.  ``where`` takes a boolean mask the same length\n# as the x, ymin and ymax arguments, and only fills in the region where\n# the boolean mask is True.  In the example below, we simulate a single\n# random walker and compute the analytic mean and standard deviation of\n# the population positions.  The population mean is shown as the dashed\n# line, and the plus/minus one sigma deviation from the mean is shown\n# as the filled region.  We use the where mask ``X > upper_bound`` to\n# find the region where the walker is outside the one sigma boundary,\n# and shade that region red.\n\n# Fixing random state for reproducibility\nnp.random.seed(1)\n\nNsteps = 500\nt = np.arange(Nsteps)\n\nmu = 0.002\nsigma = 0.01\n\n# the steps and position\nS = mu + sigma*np.random.randn(Nsteps)\nX = S.cumsum()\n\n# the 1 sigma upper and lower analytic population bounds\nlower_bound = mu*t - sigma*np.sqrt(t)\nupper_bound = mu*t + sigma*np.sqrt(t)\n\nfig, ax = plt.subplots(1)\nax.plot(t, X, lw=2, label='walker position')\nax.plot(t, mu*t, lw=1, label='population mean', color='C0', ls='--')\nax.fill_between(t, lower_bound, upper_bound, facecolor='C0', alpha=0.4,\n                label='1 sigma range')\nax.legend(loc='upper left')\n\n# here we use the where argument to only fill the region where the\n# walker is above the population 1 sigma boundary\nax.fill_between(t, upper_bound, X, where=X > upper_bound, fc='red', alpha=0.4)\nax.fill_between(t, lower_bound, X, where=X < lower_bound, fc='red', alpha=0.4)\nax.set_xlabel('num steps')\nax.set_ylabel('position')\nax.grid()\n\n# %%\n# Another handy use of filled regions is to highlight horizontal or vertical\n# spans of an Axes -- for that Matplotlib has the helper functions\n# `~matplotlib.axes.Axes.axhspan` and `~matplotlib.axes.Axes.axvspan`.  See\n# :doc:`/gallery/subplots_axes_and_figures/axhspan_demo`.\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    styling: alpha\n#    plot-type: fill_between\n#    level: intermediate\n#    purpose: showcase\n"
    },
    {
      "filename": "fill_between_demo.py",
      "title": "Fill Between Demo",
      "code": "\"\"\"\n===============================\nFill the area between two lines\n===============================\n\nThis example shows how to use `~.axes.Axes.fill_between` to color the area\nbetween two lines.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n#\n# Basic usage\n# -----------\n# The parameters *y1* and *y2* can be scalars, indicating a horizontal\n# boundary at the given y-values. If only *y1* is given, *y2* defaults to 0.\n\nx = np.arange(0.0, 2, 0.01)\ny1 = np.sin(2 * np.pi * x)\ny2 = 0.8 * np.sin(4 * np.pi * x)\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True, figsize=(6, 6))\n\nax1.fill_between(x, y1)\nax1.set_title('fill between y1 and 0')\n\nax2.fill_between(x, y1, 1)\nax2.set_title('fill between y1 and 1')\n\nax3.fill_between(x, y1, y2)\nax3.set_title('fill between y1 and y2')\nax3.set_xlabel('x')\nfig.tight_layout()\n\n# %%\n#\n# Example: Confidence bands\n# -------------------------\n# A common application for `~.axes.Axes.fill_between` is the indication of\n# confidence bands.\n#\n# `~.axes.Axes.fill_between` uses the colors of the color cycle as the fill\n# color. These may be a bit strong when applied to fill areas. It is\n# therefore often a good practice to lighten the color by making the area\n# semi-transparent using *alpha*.\n\n# sphinx_gallery_thumbnail_number = 2\n\nN = 21\nx = np.linspace(0, 10, 11)\ny = [3.9, 4.4, 10.8, 10.3, 11.2, 13.1, 14.1,  9.9, 13.9, 15.1, 12.5]\n\n# fit a linear curve and estimate its y-values and their error.\na, b = np.polyfit(x, y, deg=1)\ny_est = a * x + b\ny_err = x.std() * np.sqrt(1/len(x) +\n                          (x - x.mean())**2 / np.sum((x - x.mean())**2))\n\nfig, ax = plt.subplots()\nax.plot(x, y_est, '-')\nax.fill_between(x, y_est - y_err, y_est + y_err, alpha=0.2)\nax.plot(x, y, 'o', color='tab:brown')\n\n# %%\n#\n# Selectively filling horizontal regions\n# --------------------------------------\n# The parameter *where* allows to specify the x-ranges to fill. It's a boolean\n# array with the same size as *x*.\n#\n# Only x-ranges of contiguous *True* sequences are filled. As a result the\n# range between neighboring *True* and *False* values is never filled. This\n# often undesired when the data points should represent a contiguous quantity.\n# It is therefore recommended to set ``interpolate=True`` unless the\n# x-distance of the data points is fine enough so that the above effect is not\n# noticeable. Interpolation approximates the actual x position at which the\n# *where* condition will change and extends the filling up to there.\n\nx = np.array([0, 1, 2, 3])\ny1 = np.array([0.8, 0.8, 0.2, 0.2])\ny2 = np.array([0, 0, 1, 1])\n\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n\nax1.set_title('interpolation=False')\nax1.plot(x, y1, 'o--')\nax1.plot(x, y2, 'o--')\nax1.fill_between(x, y1, y2, where=(y1 > y2), color='C0', alpha=0.3)\nax1.fill_between(x, y1, y2, where=(y1 < y2), color='C1', alpha=0.3)\n\nax2.set_title('interpolation=True')\nax2.plot(x, y1, 'o--')\nax2.plot(x, y2, 'o--')\nax2.fill_between(x, y1, y2, where=(y1 > y2), color='C0', alpha=0.3,\n                 interpolate=True)\nax2.fill_between(x, y1, y2, where=(y1 <= y2), color='C1', alpha=0.3,\n                 interpolate=True)\nfig.tight_layout()\n\n# %%\n#\n# .. note::\n#\n#    Similar gaps will occur if *y1* or *y2* are masked arrays. Since missing\n#    values cannot be approximated, *interpolate* has no effect in this case.\n#    The gaps around masked values can only be reduced by adding more data\n#    points close to the masked values.\n\n# %%\n#\n# Selectively marking horizontal regions across the whole Axes\n# ------------------------------------------------------------\n# The same selection mechanism can be applied to fill the full vertical height\n# of the Axes. To be independent of y-limits, we add a transform that\n# interprets the x-values in data coordinates and the y-values in Axes\n# coordinates.\n#\n# The following example marks the regions in which the y-data are above a\n# given threshold.\n\nfig, ax = plt.subplots()\nx = np.arange(0, 4 * np.pi, 0.01)\ny = np.sin(x)\nax.plot(x, y, color='black')\n\nthreshold = 0.75\nax.axhline(threshold, color='green', lw=2, alpha=0.7)\nax.fill_between(x, 0, 1, where=y > threshold,\n                color='green', alpha=0.5, transform=ax.get_xaxis_transform())\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.fill_between` / `matplotlib.pyplot.fill_between`\n#    - `matplotlib.axes.Axes.get_xaxis_transform`\n#\n# .. tags::\n#\n#    styling: conditional\n#    plot-type: fill_between\n#    level: beginner\n#    purpose: showcase\n"
    },
    {
      "filename": "fill_betweenx_demo.py",
      "title": "Fill Betweenx Demo",
      "code": "\"\"\"\n========================================\nFill the area between two vertical lines\n========================================\n\nUsing `~.Axes.fill_betweenx` to color along the horizontal direction between\ntwo curves.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ny = np.arange(0.0, 2, 0.01)\nx1 = np.sin(2 * np.pi * y)\nx2 = 1.2 * np.sin(4 * np.pi * y)\n\nfig, [ax1, ax2, ax3] = plt.subplots(1, 3, sharey=True, figsize=(6, 6))\n\nax1.fill_betweenx(y, 0, x1)\nax1.set_title('between (x1, 0)')\n\nax2.fill_betweenx(y, x1, 1)\nax2.set_title('between (x1, 1)')\nax2.set_xlabel('x')\n\nax3.fill_betweenx(y, x1, x2)\nax3.set_title('between (x1, x2)')\n\n# %%\n# Now fill between x1 and x2 where a logical condition is met. Note this is\n# different than calling::\n#\n#   fill_between(y[where], x1[where], x2[where])\n#\n# because of edge effects over multiple contiguous regions.\n\nfig, [ax, ax1] = plt.subplots(1, 2, sharey=True, figsize=(6, 6))\nax.plot(x1, y, x2, y, color='black')\nax.fill_betweenx(y, x1, x2, where=x2 >= x1, facecolor='green')\nax.fill_betweenx(y, x1, x2, where=x2 <= x1, facecolor='red')\nax.set_title('fill_betweenx where')\n\n# Test support for masked arrays.\nx2 = np.ma.masked_greater(x2, 1.0)\nax1.plot(x1, y, x2, y, color='black')\nax1.fill_betweenx(y, x1, x2, where=x2 >= x1, facecolor='green')\nax1.fill_betweenx(y, x1, x2, where=x2 <= x1, facecolor='red')\nax1.set_title('regions with x2 > 1 are masked')\n\n# %%\n# This example illustrates a problem; because of the data gridding, there are\n# undesired unfilled triangles at the crossover points. A brute-force solution\n# would be to interpolate all arrays to a very fine grid before plotting.\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: fill_between\n#    level: beginner\n"
    },
    {
      "filename": "gradient_bar.py",
      "title": "Gradient Bar",
      "code": "\"\"\"\n========================\nBar chart with gradients\n========================\n\nMatplotlib does not natively support gradients. However, we can emulate a\ngradient-filled rectangle by an `.AxesImage` of the right size and coloring.\n\nIn particular, we use a colormap to generate the actual colors. It is then\nsufficient to define the underlying values on the corners of the image and\nlet bicubic interpolation fill out the area. We define the gradient direction\nby a unit vector *v*. The values at the corners are then obtained by the\nlengths of the projections of the corner vectors on *v*.\n\nA similar approach can be used to create a gradient background for an Axes.\nIn that case, it is helpful to use Axes coordinates (``extent=(0, 1, 0, 1),\ntransform=ax.transAxes``) to be independent of the data coordinates.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\n\ndef gradient_image(ax, direction=0.3, cmap_range=(0, 1), **kwargs):\n    \"\"\"\n    Draw a gradient image based on a colormap.\n\n    Parameters\n    ----------\n    ax : Axes\n        The Axes to draw on.\n    direction : float\n        The direction of the gradient. This is a number in\n        range 0 (=vertical) to 1 (=horizontal).\n    cmap_range : float, float\n        The fraction (cmin, cmax) of the colormap that should be\n        used for the gradient, where the complete colormap is (0, 1).\n    **kwargs\n        Other parameters are passed on to `.Axes.imshow()`.\n        In particular, *cmap*, *extent*, and *transform* may be useful.\n    \"\"\"\n    phi = direction * np.pi / 2\n    v = np.array([np.cos(phi), np.sin(phi)])\n    X = np.array([[v @ [1, 0], v @ [1, 1]],\n                  [v @ [0, 0], v @ [0, 1]]])\n    a, b = cmap_range\n    X = a + (b - a) / X.max() * X\n    im = ax.imshow(X, interpolation='bicubic', clim=(0, 1),\n                   aspect='auto', **kwargs)\n    return im\n\n\ndef gradient_bar(ax, x, y, width=0.5, bottom=0):\n    for left, top in zip(x, y):\n        right = left + width\n        gradient_image(ax, extent=(left, right, bottom, top),\n                       cmap=plt.cm.Blues_r, cmap_range=(0, 0.8))\n\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 10), ylim=(0, 1))\n\n# background image\ngradient_image(ax, direction=1, extent=(0, 1, 0, 1), transform=ax.transAxes,\n               cmap=plt.cm.RdYlGn, cmap_range=(0.2, 0.8), alpha=0.5)\n\nN = 10\nx = np.arange(N) + 0.15\ny = np.random.rand(N)\ngradient_bar(ax, x, y, width=0.7)\nplt.show()\n\n# %%\n# .. tags::\n#\n#    styling: color\n#    plot-type: imshow\n#    level: intermediate\n#    purpose: showcase\n"
    },
    {
      "filename": "hat_graph.py",
      "title": "Hat Graph",
      "code": "\"\"\"\n=========\nHat graph\n=========\nThis example shows how to create a `hat graph`_ and how to annotate it with\nlabels.\n\n.. _hat graph: https://doi.org/10.1186/s41235-019-0182-3\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef hat_graph(ax, xlabels, values, group_labels):\n    \"\"\"\n    Create a hat graph.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        The Axes to plot into.\n    xlabels : list of str\n        The category names to be displayed on the x-axis.\n    values : (M, N) array-like\n        The data values.\n        Rows are the groups (len(group_labels) == M).\n        Columns are the categories (len(xlabels) == N).\n    group_labels : list of str\n        The group labels displayed in the legend.\n    \"\"\"\n\n    def label_bars(heights, rects):\n        \"\"\"Attach a text label on top of each bar.\"\"\"\n        for height, rect in zip(heights, rects):\n            ax.annotate(f'{height}',\n                        xy=(rect.get_x() + rect.get_width() / 2, height),\n                        xytext=(0, 4),  # 4 points vertical offset.\n                        textcoords='offset points',\n                        ha='center', va='bottom')\n\n    values = np.asarray(values)\n    x = np.arange(values.shape[1])\n    ax.set_xticks(x, labels=xlabels)\n    spacing = 0.3  # spacing between hat groups\n    width = (1 - spacing) / values.shape[0]\n    heights0 = values[0]\n    for i, (heights, group_label) in enumerate(zip(values, group_labels)):\n        style = {'fill': False} if i == 0 else {'edgecolor': 'black'}\n        rects = ax.bar(x - spacing/2 + i * width, heights - heights0,\n                       width, bottom=heights0, label=group_label, **style)\n        label_bars(heights, rects)\n\n\n# initialise labels and a numpy array make sure you have\n# N labels of N number of values in the array\nxlabels = ['I', 'II', 'III', 'IV', 'V']\nplayerA = np.array([5, 15, 22, 20, 25])\nplayerB = np.array([25, 32, 34, 30, 27])\n\nfig, ax = plt.subplots()\nhat_graph(ax, xlabels, [playerA, playerB], ['Player A', 'Player B'])\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel('Games')\nax.set_ylabel('Score')\nax.set_ylim(0, 60)\nax.set_title('Scores by number of game and players')\nax.legend()\n\nfig.tight_layout()\nplt.show()\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.axes.Axes.annotate` / `matplotlib.pyplot.annotate`\n#\n# .. tags::\n#\n#    component: annotate\n#    plot-type: bar\n#    level: beginner\n"
    },
    {
      "filename": "horizontal_barchart_distribution.py",
      "title": "Horizontal Barchart Distribution",
      "code": "\"\"\"\n=============================================\nDiscrete distribution as horizontal bar chart\n=============================================\n\nStacked bar charts can be used to visualize discrete distributions.\n\nThis example visualizes the result of a survey in which people could rate\ntheir agreement to questions on a five-element scale.\n\nThe horizontal stacking is achieved by calling `~.Axes.barh()` for each\ncategory and passing the starting point as the cumulative sum of the\nalready drawn bars via the parameter ``left``.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncategory_names = ['Strongly disagree', 'Disagree',\n                  'Neither agree nor disagree', 'Agree', 'Strongly agree']\nresults = {\n    'Question 1': [10, 15, 17, 32, 26],\n    'Question 2': [26, 22, 29, 10, 13],\n    'Question 3': [35, 37, 7, 2, 19],\n    'Question 4': [32, 11, 9, 15, 33],\n    'Question 5': [21, 29, 5, 5, 40],\n    'Question 6': [8, 19, 5, 30, 38]\n}\n\n\ndef survey(results, category_names):\n    \"\"\"\n    Parameters\n    ----------\n    results : dict\n        A mapping from question labels to a list of answers per category.\n        It is assumed all lists contain the same number of entries and that\n        it matches the length of *category_names*.\n    category_names : list of str\n        The category labels.\n    \"\"\"\n    labels = list(results.keys())\n    data = np.array(list(results.values()))\n    data_cum = data.cumsum(axis=1)\n    category_colors = plt.colormaps['RdYlGn'](\n        np.linspace(0.15, 0.85, data.shape[1]))\n\n    fig, ax = plt.subplots(figsize=(9.2, 5))\n    ax.invert_yaxis()\n    ax.xaxis.set_visible(False)\n    ax.set_xlim(0, np.sum(data, axis=1).max())\n\n    for i, (colname, color) in enumerate(zip(category_names, category_colors)):\n        widths = data[:, i]\n        starts = data_cum[:, i] - widths\n        rects = ax.barh(labels, widths, left=starts, height=0.5,\n                        label=colname, color=color)\n\n        r, g, b, _ = color\n        text_color = 'white' if r * g * b < 0.5 else 'darkgrey'\n        ax.bar_label(rects, label_type='center', color=text_color)\n    ax.legend(ncols=len(category_names), bbox_to_anchor=(0, 1),\n              loc='lower left', fontsize='small')\n\n    return fig, ax\n\n\nsurvey(results, category_names)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.barh` / `matplotlib.pyplot.barh`\n#    - `matplotlib.axes.Axes.bar_label` / `matplotlib.pyplot.bar_label`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#\n# .. tags::\n#\n#    domain: statistics\n#    component: label\n#    plot-type: bar\n#    level: beginner\n"
    },
    {
      "filename": "joinstyle.py",
      "title": "Joinstyle",
      "code": "\"\"\"\n=========\nJoinStyle\n=========\n\nThe `matplotlib._enums.JoinStyle` controls how Matplotlib draws the corners\nwhere two different line segments meet. For more details, see the\n`~matplotlib._enums.JoinStyle` docs.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib._enums import JoinStyle\n\nJoinStyle.demo()\nplt.show()\n\n# %%\n# .. tags:: purpose: reference, styling: linestyle\n"
    },
    {
      "filename": "line_demo_dash_control.py",
      "title": "Line Demo Dash Control",
      "code": "\"\"\"\n===============================\nDashed line style configuration\n===============================\n\nThe dashing of a line is controlled via a dash sequence. It can be modified\nusing `.Line2D.set_dashes`.\n\nThe dash sequence is a series of on/off lengths in points, e.g.\n``[3, 1]`` would be 3pt long lines separated by 1pt spaces.\n\nSome functions like `.Axes.plot` support passing Line properties as keyword\narguments. In such a case, you can already set the dashing when creating the\nline.\n\n*Note*: The dash style can also be configured via a\n:ref:`property_cycle <color_cycle>`\nby passing a list of dash sequences using the keyword *dashes* to the\ncycler. This is not shown within this example.\n\nOther attributes of the dash may also be set either with the relevant method\n(`~.Line2D.set_dash_capstyle`, `~.Line2D.set_dash_joinstyle`,\n`~.Line2D.set_gapcolor`) or by passing the property through a plotting\nfunction.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 500)\ny = np.sin(x)\n\nplt.rc('lines', linewidth=2.5)\nfig, ax = plt.subplots()\n\n# Using set_dashes() and set_capstyle() to modify dashing of an existing line.\nline1, = ax.plot(x, y, label='Using set_dashes() and set_dash_capstyle()')\nline1.set_dashes([2, 2, 10, 2])  # 2pt line, 2pt break, 10pt line, 2pt break.\nline1.set_dash_capstyle('round')\n\n# Using plot(..., dashes=...) to set the dashing when creating a line.\nline2, = ax.plot(x, y - 0.2, dashes=[6, 2], label='Using the dashes parameter')\n\n# Using plot(..., dashes=..., gapcolor=...) to set the dashing and\n# alternating color when creating a line.\nline3, = ax.plot(x, y - 0.4, dashes=[4, 4], gapcolor='tab:pink',\n                 label='Using the dashes and gapcolor parameters')\n\nax.legend(handlelength=4)\nplt.show()\n\n# %%\n# .. tags::\n#\n#    styling: linestyle\n#    plot-style: line\n#    level: beginner\n"
    },
    {
      "filename": "lines_with_ticks_demo.py",
      "title": "Lines With Ticks Demo",
      "code": "\"\"\"\n==============================\nLines with a ticked patheffect\n==============================\n\nTicks can be added along a line to mark one side as a barrier using\n`~matplotlib.patheffects.TickedStroke`.  You can control the angle,\nspacing, and length of the ticks.\n\nThe ticks will also appear appropriately in the legend.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\n# Plot a straight diagonal line with ticked style path\nfig, ax = plt.subplots(figsize=(6, 6))\nax.plot([0, 1], [0, 1], label=\"Line\",\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)])\n\n# Plot a curved line with ticked style path\nnx = 101\nx = np.linspace(0.0, 1.0, nx)\ny = 0.3*np.sin(x*8) + 0.4\nax.plot(x, y, label=\"Curve\", path_effects=[patheffects.withTickedStroke()])\n\nax.legend()\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    styling: linestyle\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "linestyles.py",
      "title": "Linestyles",
      "code": "\"\"\"\n==========\nLinestyles\n==========\n\nSimple linestyles can be defined using the strings \"solid\", \"dotted\", \"dashed\"\nor \"dashdot\". More refined control can be achieved by providing a dash tuple\n``(offset, (on_off_seq))``. For example, ``(0, (3, 10, 1, 15))`` means\n(3pt line, 10pt space, 1pt line, 15pt space) with no offset, while\n``(5, (10, 3))``, means (10pt line, 3pt space), but skip the first 5pt line.\nSee also `.Line2D.set_linestyle`.  The specific on/off sequences of the\n\"dotted\", \"dashed\" and \"dashdot\" styles are configurable:\n\n* :rc:`lines.dotted_pattern`\n* :rc:`lines.dashed_pattern`\n* :rc:`lines.dashdot_pattern`\n\n*Note*: The dash style can also be configured via `.Line2D.set_dashes`\nas shown in :doc:`/gallery/lines_bars_and_markers/line_demo_dash_control`\nand passing a list of dash sequences using the keyword *dashes* to the\ncycler in :ref:`property_cycle <color_cycle>`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nlinestyle_str = [\n     ('solid', 'solid'),      # Same as (0, ()) or '-'\n     ('dotted', 'dotted'),    # Same as ':'\n     ('dashed', 'dashed'),    # Same as '--'\n     ('dashdot', 'dashdot')]  # Same as '-.'\n\nlinestyle_tuple = [\n     ('loosely dotted',        (0, (1, 10))),\n     ('dotted',                (0, (1, 5))),\n     ('densely dotted',        (0, (1, 1))),\n\n     ('long dash with offset', (5, (10, 3))),\n     ('loosely dashed',        (0, (5, 10))),\n     ('dashed',                (0, (5, 5))),\n     ('densely dashed',        (0, (5, 1))),\n\n     ('loosely dashdotted',    (0, (3, 10, 1, 10))),\n     ('dashdotted',            (0, (3, 5, 1, 5))),\n     ('densely dashdotted',    (0, (3, 1, 1, 1))),\n\n     ('dashdotdotted',         (0, (3, 5, 1, 5, 1, 5))),\n     ('loosely dashdotdotted', (0, (3, 10, 1, 10, 1, 10))),\n     ('densely dashdotdotted', (0, (3, 1, 1, 1, 1, 1)))]\n\n\ndef plot_linestyles(ax, linestyles, title):\n    X, Y = np.linspace(0, 100, 10), np.zeros(10)\n    yticklabels = []\n\n    for i, (name, linestyle) in enumerate(linestyles):\n        ax.plot(X, Y+i, linestyle=linestyle, linewidth=1.5, color='black')\n        yticklabels.append(name)\n\n    ax.set_title(title)\n    ax.set(ylim=(-0.5, len(linestyles)-0.5),\n           yticks=np.arange(len(linestyles)),\n           yticklabels=yticklabels)\n    ax.tick_params(left=False, bottom=False, labelbottom=False)\n    ax.spines[:].set_visible(False)\n\n    # For each line style, add a text annotation with a small offset from\n    # the reference point (0 in Axes coords, y tick value in Data coords).\n    for i, (name, linestyle) in enumerate(linestyles):\n        ax.annotate(repr(linestyle),\n                    xy=(0.0, i), xycoords=ax.get_yaxis_transform(),\n                    xytext=(-6, -12), textcoords='offset points',\n                    color=\"blue\", fontsize=8, ha=\"right\", family=\"monospace\")\n\n\nfig, (ax0, ax1) = plt.subplots(2, 1, figsize=(7, 8), height_ratios=[1, 3],\n                               layout='constrained')\n\nplot_linestyles(ax0, linestyle_str[::-1], title='Named linestyles')\nplot_linestyles(ax1, linestyle_tuple[::-1], title='Parametrized linestyles')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    styling: linestyle\n#    purpose: reference\n"
    },
    {
      "filename": "marker_reference.py",
      "title": "Marker Reference",
      "code": "\"\"\"\n================\nMarker reference\n================\n\nMatplotlib supports multiple categories of markers which are selected using\nthe ``marker`` parameter of plot commands:\n\n- `Unfilled markers`_\n- `Filled markers`_\n- `Markers created from TeX symbols`_\n- `Markers created from Paths`_\n\nFor a list of all markers see also the `matplotlib.markers` documentation.\n\nFor example usages see\n:doc:`/gallery/lines_bars_and_markers/scatter_star_poly`.\n\n.. redirect-from:: /gallery/shapes_and_collections/marker_path\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.lines import Line2D\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.transforms import Affine2D\n\ntext_style = dict(horizontalalignment='right', verticalalignment='center',\n                  fontsize=12, fontfamily='monospace')\nmarker_style = dict(linestyle=':', color='0.8', markersize=10,\n                    markerfacecolor=\"tab:blue\", markeredgecolor=\"tab:blue\")\n\n\ndef format_axes(ax):\n    ax.margins(0.2)\n    ax.set_axis_off()\n    ax.invert_yaxis()\n\n\ndef split_list(a_list):\n    i_half = len(a_list) // 2\n    return a_list[:i_half], a_list[i_half:]\n\n\n# %%\n# Unfilled markers\n# ================\n# Unfilled markers are single-colored.\n\nfig, axs = plt.subplots(ncols=2)\nfig.suptitle('Un-filled markers', fontsize=14)\n\n# Filter out filled markers and marker settings that do nothing.\nunfilled_markers = [m for m, func in Line2D.markers.items()\n                    if func != 'nothing' and m not in Line2D.filled_markers]\n\nfor ax, markers in zip(axs, split_list(unfilled_markers)):\n    for y, marker in enumerate(markers):\n        ax.text(-0.5, y, repr(marker), **text_style)\n        ax.plot([y] * 3, marker=marker, **marker_style)\n    format_axes(ax)\n\n# %%\n# Filled markers\n# ==============\n\nfig, axs = plt.subplots(ncols=2)\nfig.suptitle('Filled markers', fontsize=14)\nfor ax, markers in zip(axs, split_list(Line2D.filled_markers)):\n    for y, marker in enumerate(markers):\n        ax.text(-0.5, y, repr(marker), **text_style)\n        ax.plot([y] * 3, marker=marker, **marker_style)\n    format_axes(ax)\n\n# %%\n# .. _marker_fill_styles:\n#\n# Marker fill styles\n# ------------------\n# The edge color and fill color of filled markers can be specified separately.\n# Additionally, the ``fillstyle`` can be configured to be unfilled, fully\n# filled, or half-filled in various directions. The half-filled styles use\n# ``markerfacecoloralt`` as secondary fill color.\n\nfig, ax = plt.subplots()\nfig.suptitle('Marker fillstyle', fontsize=14)\nfig.subplots_adjust(left=0.4)\n\nfilled_marker_style = dict(marker='o', linestyle=':', markersize=15,\n                           color='darkgrey',\n                           markerfacecolor='tab:blue',\n                           markerfacecoloralt='lightsteelblue',\n                           markeredgecolor='brown')\n\nfor y, fill_style in enumerate(Line2D.fillStyles):\n    ax.text(-0.5, y, repr(fill_style), **text_style)\n    ax.plot([y] * 3, fillstyle=fill_style, **filled_marker_style)\nformat_axes(ax)\n\n# %%\n# Markers created from TeX symbols\n# ================================\n#\n# Use :ref:`MathText <mathtext>`, to use custom marker symbols,\n# like e.g. ``\"$\\u266B$\"``. For an overview over the STIX font symbols refer\n# to the `STIX font table <http://www.stixfonts.org/allGlyphs.html>`_.\n# Also see the :doc:`/gallery/text_labels_and_annotations/stix_fonts_demo`.\n\n\nfig, ax = plt.subplots()\nfig.suptitle('Mathtext markers', fontsize=14)\nfig.subplots_adjust(left=0.4)\n\nmarker_style.update(markeredgecolor=\"none\", markersize=15)\nmarkers = [\"$1$\", r\"$\\frac{1}{2}$\", \"$f$\", \"$\\u266B$\", r\"$\\mathcal{A}$\"]\n\nfor y, marker in enumerate(markers):\n    # Escape dollars so that the text is written \"as is\", not as mathtext.\n    ax.text(-0.5, y, repr(marker).replace(\"$\", r\"\\$\"), **text_style)\n    ax.plot([y] * 3, marker=marker, **marker_style)\nformat_axes(ax)\n\n# %%\n# Markers created from Paths\n# ==========================\n#\n# Any `~.path.Path` can be used as a marker. The following example shows two\n# simple paths *star* and *circle*, and a more elaborate path of a circle with\n# a cut-out star.\n\nimport numpy as np\n\nimport matplotlib.path as mpath\n\nstar = mpath.Path.unit_regular_star(6)\ncircle = mpath.Path.unit_circle()\n# concatenate the circle with an internal cutout of the star\ncut_star = mpath.Path(\n    vertices=np.concatenate([circle.vertices, star.vertices[::-1, ...]]),\n    codes=np.concatenate([circle.codes, star.codes]))\n\nfig, ax = plt.subplots()\nfig.suptitle('Path markers', fontsize=14)\nfig.subplots_adjust(left=0.4)\n\nmarkers = {'star': star, 'circle': circle, 'cut_star': cut_star}\n\nfor y, (name, marker) in enumerate(markers.items()):\n    ax.text(-0.5, y, name, **text_style)\n    ax.plot([y] * 3, marker=marker, **marker_style)\nformat_axes(ax)\n\n# %%\n# Advanced marker modifications with transform\n# ============================================\n#\n# Markers can be modified by passing a transform to the MarkerStyle\n# constructor. Following example shows how a supplied rotation is applied to\n# several marker shapes.\n\ncommon_style = {k: v for k, v in filled_marker_style.items() if k != 'marker'}\nangles = [0, 10, 20, 30, 45, 60, 90]\n\nfig, ax = plt.subplots()\nfig.suptitle('Rotated markers', fontsize=14)\n\nax.text(-0.5, 0, 'Filled marker', **text_style)\nfor x, theta in enumerate(angles):\n    t = Affine2D().rotate_deg(theta)\n    ax.plot(x, 0, marker=MarkerStyle('o', 'left', t), **common_style)\n\nax.text(-0.5, 1, 'Un-filled marker', **text_style)\nfor x, theta in enumerate(angles):\n    t = Affine2D().rotate_deg(theta)\n    ax.plot(x, 1, marker=MarkerStyle('1', 'left', t), **common_style)\n\nax.text(-0.5, 2, 'Equation marker', **text_style)\nfor x, theta in enumerate(angles):\n    t = Affine2D().rotate_deg(theta)\n    eq = r'$\\frac{1}{x}$'\n    ax.plot(x, 2, marker=MarkerStyle(eq, 'left', t), **common_style)\n\nfor x, theta in enumerate(angles):\n    ax.text(x, 2.5, f\"{theta}\u00b0\", horizontalalignment=\"center\")\nformat_axes(ax)\n\nfig.tight_layout()\n\n# %%\n# Setting marker cap style and join style\n# =======================================\n#\n# Markers have default cap and join styles, but these can be\n# customized when creating a MarkerStyle.\n\nfrom matplotlib.markers import CapStyle, JoinStyle\n\nmarker_inner = dict(markersize=35,\n                    markerfacecolor='tab:blue',\n                    markerfacecoloralt='lightsteelblue',\n                    markeredgecolor='brown',\n                    markeredgewidth=8,\n                    )\n\nmarker_outer = dict(markersize=35,\n                    markerfacecolor='tab:blue',\n                    markerfacecoloralt='lightsteelblue',\n                    markeredgecolor='white',\n                    markeredgewidth=1,\n                    )\n\nfig, ax = plt.subplots()\nfig.suptitle('Marker CapStyle', fontsize=14)\nfig.subplots_adjust(left=0.1)\n\nfor y, cap_style in enumerate(CapStyle):\n    ax.text(-0.5, y, cap_style.name, **text_style)\n    for x, theta in enumerate(angles):\n        t = Affine2D().rotate_deg(theta)\n        m = MarkerStyle('1', transform=t, capstyle=cap_style)\n        ax.plot(x, y, marker=m, **marker_inner)\n        ax.plot(x, y, marker=m, **marker_outer)\n        ax.text(x, len(CapStyle) - .5, f'{theta}\u00b0', ha='center')\nformat_axes(ax)\n\n# %%\n# Modifying the join style:\n\nfig, ax = plt.subplots()\nfig.suptitle('Marker JoinStyle', fontsize=14)\nfig.subplots_adjust(left=0.05)\n\nfor y, join_style in enumerate(JoinStyle):\n    ax.text(-0.5, y, join_style.name, **text_style)\n    for x, theta in enumerate(angles):\n        t = Affine2D().rotate_deg(theta)\n        m = MarkerStyle('*', transform=t, joinstyle=join_style)\n        ax.plot(x, y, marker=m, **marker_inner)\n        ax.text(x, len(JoinStyle) - .5, f'{theta}\u00b0', ha='center')\nformat_axes(ax)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: marker\n#    purpose: reference\n"
    },
    {
      "filename": "markevery_demo.py",
      "title": "Markevery Demo",
      "code": "\"\"\"\n==============\nMarkevery Demo\n==============\n\nThe ``markevery`` property of `.Line2D` allows drawing markers at a subset of\ndata points.\n\nThe list of possible parameters is specified at `.Line2D.set_markevery`.\nIn short:\n\n- A single integer N draws every N-th marker.\n- A tuple of integers (start, N) draws every N-th marker, starting at data\n  index *start*.\n- A list of integers draws the markers at the specified indices.\n- A slice draws the markers at the sliced indices.\n- A float specifies the distance between markers as a fraction of the Axes\n  diagonal in screen space. This will lead to a visually uniform distribution\n  of the points along the line, irrespective of scales and zooming.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# define a list of markevery cases to plot\ncases = [\n    None,\n    8,\n    (30, 8),\n    [16, 24, 32],\n    [0, -1],\n    slice(100, 200, 3),\n    0.1,\n    0.4,\n    (0.2, 0.4)\n]\n\n# data points\ndelta = 0.11\nx = np.linspace(0, 10 - 2 * delta, 200) + delta\ny = np.sin(x) + 1.0 + delta\n\n# %%\n# markevery with linear scales\n# ----------------------------\n\nfig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained')\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.plot(x, y, 'o', ls='-', ms=4, markevery=markevery)\n\n# %%\n# markevery with log scales\n# -------------------------\n#\n# Note that the log scale causes a visual asymmetry in the marker distance for\n# when subsampling the data using an integer. In contrast, subsampling on\n# fraction of figure size creates even distributions, because it's based on\n# fractions of the Axes diagonal, not on data coordinates or data indices.\n\nfig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained')\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.set_xscale('log')\n    ax.set_yscale('log')\n    ax.plot(x, y, 'o', ls='-', ms=4, markevery=markevery)\n\n# %%\n# markevery on zoomed plots\n# -------------------------\n#\n# Integer-based *markevery* specifications select points from the underlying\n# data and are independent on the view. In contrast, float-based specifications\n# are related to the Axes diagonal. While zooming does not change the Axes\n# diagonal, it changes the displayed data range, and more points will be\n# displayed when zooming.\n\nfig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained')\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.plot(x, y, 'o', ls='-', ms=4, markevery=markevery)\n    ax.set_xlim((6, 6.7))\n    ax.set_ylim((1.1, 1.7))\n\n# %%\n# markevery on polar plots\n# ------------------------\n\nr = np.linspace(0, 3.0, 200)\ntheta = 2 * np.pi * r\n\nfig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained',\n                        subplot_kw={'projection': 'polar'})\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.plot(theta, r, 'o', ls='-', ms=4, markevery=markevery)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: marker\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "masked_demo.py",
      "title": "Masked Demo",
      "code": "\"\"\"\n==============================\nPlotting masked and NaN values\n==============================\n\nSometimes you need to plot data with missing values.\n\nOne possibility is to simply remove undesired data points. The line plotted\nthrough the remaining data will be continuous, and not indicate where the\nmissing data is located.\n\nIf it is useful to have gaps in the line where the data is missing, then the\nundesired points can be indicated using a `masked array`_ or by setting their\nvalues to NaN. No marker will be drawn where either x or y are masked and, if\nplotting with a line, it will be broken there.\n\n.. _masked array:\n   https://numpy.org/doc/stable/reference/maskedarray.generic.html\n\nThe following example illustrates the three cases:\n\n1) Removing points.\n2) Masking points.\n3) Setting to NaN.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-np.pi/2, np.pi/2, 31)\ny = np.cos(x)**3\n\n# 1) remove points where y > 0.7\nx2 = x[y <= 0.7]\ny2 = y[y <= 0.7]\n\n# 2) mask points where y > 0.7\ny3 = np.ma.masked_where(y > 0.7, y)\n\n# 3) set to NaN where y > 0.7\ny4 = y.copy()\ny4[y3 > 0.7] = np.nan\n\nplt.plot(x*0.1, y, 'o-', color='lightgrey', label='No mask')\nplt.plot(x2*0.4, y2, 'o-', label='Points removed')\nplt.plot(x*0.7, y3, 'o-', label='Masked values')\nplt.plot(x*1.0, y4, 'o-', label='NaN values')\nplt.legend()\nplt.title('Masked and NaN data')\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: line\n#    level: intermediate\n"
    },
    {
      "filename": "multicolored_line.py",
      "title": "Multicolored Line",
      "code": "\"\"\"\n==================\nMulticolored lines\n==================\n\nThe example shows two ways to plot a line with the a varying color defined by\na third value. The first example defines the color at each (x, y) point.\nThe second example defines the color between pairs of points, so the length\nof the color value list is one less than the length of the x and y lists.\n\nColor values at points\n----------------------\n\n\"\"\"\n\nimport warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import LineCollection\n\n\ndef colored_line(x, y, c, ax, **lc_kwargs):\n    \"\"\"\n    Plot a line with a color specified along the line by a third value.\n\n    It does this by creating a collection of line segments. Each line segment is\n    made up of two straight lines each connecting the current (x, y) point to the\n    midpoints of the lines connecting the current point with its two neighbors.\n    This creates a smooth line with no gaps between the line segments.\n\n    Parameters\n    ----------\n    x, y : array-like\n        The horizontal and vertical coordinates of the data points.\n    c : array-like\n        The color values, which should be the same size as x and y.\n    ax : Axes\n        Axis object on which to plot the colored line.\n    **lc_kwargs\n        Any additional arguments to pass to matplotlib.collections.LineCollection\n        constructor. This should not include the array keyword argument because\n        that is set to the color argument. If provided, it will be overridden.\n\n    Returns\n    -------\n    matplotlib.collections.LineCollection\n        The generated line collection representing the colored line.\n    \"\"\"\n    if \"array\" in lc_kwargs:\n        warnings.warn('The provided \"array\" keyword argument will be overridden')\n\n    # Default the capstyle to butt so that the line segments smoothly line up\n    default_kwargs = {\"capstyle\": \"butt\"}\n    default_kwargs.update(lc_kwargs)\n\n    # Compute the midpoints of the line segments. Include the first and last points\n    # twice so we don't need any special syntax later to handle them.\n    x = np.asarray(x)\n    y = np.asarray(y)\n    x_midpts = np.hstack((x[0], 0.5 * (x[1:] + x[:-1]), x[-1]))\n    y_midpts = np.hstack((y[0], 0.5 * (y[1:] + y[:-1]), y[-1]))\n\n    # Determine the start, middle, and end coordinate pair of each line segment.\n    # Use the reshape to add an extra dimension so each pair of points is in its\n    # own list. Then concatenate them to create:\n    # [\n    #   [(x1_start, y1_start), (x1_mid, y1_mid), (x1_end, y1_end)],\n    #   [(x2_start, y2_start), (x2_mid, y2_mid), (x2_end, y2_end)],\n    #   ...\n    # ]\n    coord_start = np.column_stack((x_midpts[:-1], y_midpts[:-1]))[:, np.newaxis, :]\n    coord_mid = np.column_stack((x, y))[:, np.newaxis, :]\n    coord_end = np.column_stack((x_midpts[1:], y_midpts[1:]))[:, np.newaxis, :]\n    segments = np.concatenate((coord_start, coord_mid, coord_end), axis=1)\n\n    lc = LineCollection(segments, **default_kwargs)\n    lc.set_array(c)  # set the colors of each segment\n\n    return ax.add_collection(lc)\n\n\n# -------------- Create and show plot --------------\n# Some arbitrary function that gives x, y, and color values\nt = np.linspace(-7.4, -0.5, 200)\nx = 0.9 * np.sin(t)\ny = 0.9 * np.cos(1.6 * t)\ncolor = np.linspace(0, 2, t.size)\n\n# Create a figure and plot the line on it\nfig1, ax1 = plt.subplots()\nlines = colored_line(x, y, color, ax1, linewidth=10, cmap=\"plasma\")\nfig1.colorbar(lines)  # add a color legend\n\n# Set the axis limits and tick positions\nax1.set_xlim(-1, 1)\nax1.set_ylim(-1, 1)\nax1.set_xticks((-1, 0, 1))\nax1.set_yticks((-1, 0, 1))\nax1.set_title(\"Color at each point\")\n\nplt.show()\n\n####################################################################\n# This method is designed to give a smooth impression when distances and color\n# differences between adjacent points are not too large. The following example\n# does not meet this criteria and by that serves to illustrate the segmentation\n# and coloring mechanism.\nx = [0, 1, 2, 3, 4]\ny = [0, 1, 2, 1, 1]\nc = [1, 2, 3, 4, 5]\nfig, ax = plt.subplots()\nax.scatter(x, y, c=c, cmap='rainbow')\ncolored_line(x, y, c=c, ax=ax, cmap='rainbow')\n\nplt.show()\n\n####################################################################\n# Color values between points\n# ---------------------------\n#\n\n\ndef colored_line_between_pts(x, y, c, ax, **lc_kwargs):\n    \"\"\"\n    Plot a line with a color specified between (x, y) points by a third value.\n\n    It does this by creating a collection of line segments between each pair of\n    neighboring points. The color of each segment is determined by the\n    made up of two straight lines each connecting the current (x, y) point to the\n    midpoints of the lines connecting the current point with its two neighbors.\n    This creates a smooth line with no gaps between the line segments.\n\n    Parameters\n    ----------\n    x, y : array-like\n        The horizontal and vertical coordinates of the data points.\n    c : array-like\n        The color values, which should have a size one less than that of x and y.\n    ax : Axes\n        Axis object on which to plot the colored line.\n    **lc_kwargs\n        Any additional arguments to pass to matplotlib.collections.LineCollection\n        constructor. This should not include the array keyword argument because\n        that is set to the color argument. If provided, it will be overridden.\n\n    Returns\n    -------\n    matplotlib.collections.LineCollection\n        The generated line collection representing the colored line.\n    \"\"\"\n    if \"array\" in lc_kwargs:\n        warnings.warn('The provided \"array\" keyword argument will be overridden')\n\n    # Check color array size (LineCollection still works, but values are unused)\n    if len(c) != len(x) - 1:\n        warnings.warn(\n            \"The c argument should have a length one less than the length of x and y. \"\n            \"If it has the same length, use the colored_line function instead.\"\n        )\n\n    # Create a set of line segments so that we can color them individually\n    # This creates the points as an N x 1 x 2 array so that we can stack points\n    # together easily to get the segments. The segments array for line collection\n    # needs to be (numlines) x (points per line) x 2 (for x and y)\n    points = np.array([x, y]).T.reshape(-1, 1, 2)\n    segments = np.concatenate([points[:-1], points[1:]], axis=1)\n    lc = LineCollection(segments, **lc_kwargs)\n\n    # Set the values used for colormapping\n    lc.set_array(c)\n\n    return ax.add_collection(lc)\n\n\n# -------------- Create and show plot --------------\nx = np.linspace(0, 3 * np.pi, 500)\ny = np.sin(x)\ndydx = np.cos(0.5 * (x[:-1] + x[1:]))  # first derivative\n\nfig2, ax2 = plt.subplots()\nline = colored_line_between_pts(x, y, dydx, ax2, linewidth=2, cmap=\"viridis\")\nfig2.colorbar(line, ax=ax2, label=\"dy/dx\")\n\nax2.set_xlim(x.min(), x.max())\nax2.set_ylim(-1.1, 1.1)\nax2.set_title(\"Color between points\")\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    styling: color\n#    styling: linestyle\n#    plot-type: line\n#    level: intermediate\n"
    },
    {
      "filename": "multivariate_marker_plot.py",
      "title": "Multivariate Marker Plot",
      "code": "\"\"\"\n==============================================\nMapping marker properties to multivariate data\n==============================================\n\nThis example shows how to use different properties of markers to plot\nmultivariate datasets. Here we represent a successful baseball throw as a\nsmiley face with marker size mapped to the skill of thrower, marker rotation to\nthe take-off angle, and thrust to the marker color.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import Normalize\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import Affine2D\n\nSUCCESS_SYMBOLS = [\n    TextPath((0, 0), \"\u2639\"),\n    TextPath((0, 0), \"\ud83d\ude12\"),\n    TextPath((0, 0), \"\u263a\"),\n]\n\nN = 25\nnp.random.seed(42)\nskills = np.random.uniform(5, 80, size=N) * 0.1 + 5\ntakeoff_angles = np.random.normal(0, 90, N)\nthrusts = np.random.uniform(size=N)\nsuccessful = np.random.randint(0, 3, size=N)\npositions = np.random.normal(size=(N, 2)) * 5\ndata = zip(skills, takeoff_angles, thrusts, successful, positions)\n\ncmap = plt.colormaps[\"plasma\"]\nfig, ax = plt.subplots()\nfig.suptitle(\"Throwing success\", size=14)\nfor skill, takeoff, thrust, mood, pos in data:\n    t = Affine2D().scale(skill).rotate_deg(takeoff)\n    m = MarkerStyle(SUCCESS_SYMBOLS[mood], transform=t)\n    ax.plot(pos[0], pos[1], marker=m, color=cmap(thrust))\nfig.colorbar(plt.cm.ScalarMappable(norm=Normalize(0, 1), cmap=cmap),\n             ax=ax, label=\"Normalized Thrust [a.u.]\")\nax.set_xlabel(\"X position [m]\")\nax.set_ylabel(\"Y position [m]\")\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: marker\n#    styling: color,\n#    styling: shape\n#    level: beginner\n#    purpose: fun\n"
    },
    {
      "filename": "psd_demo.py",
      "title": "Psd Demo",
      "code": "\"\"\"\n============================\nPower spectral density (PSD)\n============================\n\nPlotting power spectral density (PSD) using `~.Axes.psd`.\n\nThe PSD is a common plot in the field of signal processing. NumPy has\nmany useful libraries for computing a PSD. Below we demo a few examples\nof how this can be accomplished and visualized with Matplotlib.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.mlab as mlab\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.01\nt = np.arange(0, 10, dt)\nnse = np.random.randn(len(t))\nr = np.exp(-t / 0.05)\n\ncnse = np.convolve(nse, r) * dt\ncnse = cnse[:len(t)]\ns = 0.1 * np.sin(2 * np.pi * t) + cnse\n\nfig, (ax0, ax1) = plt.subplots(2, 1, layout='constrained')\nax0.plot(t, s)\nax0.set_xlabel('Time (s)')\nax0.set_ylabel('Signal')\nax1.psd(s, NFFT=512, Fs=1 / dt)\n\nplt.show()\n\n# %%\n# Compare this with the equivalent Matlab code to accomplish the same thing::\n#\n#     dt = 0.01;\n#     t = [0:dt:10];\n#     nse = randn(size(t));\n#     r = exp(-t/0.05);\n#     cnse = conv(nse, r)*dt;\n#     cnse = cnse(1:length(t));\n#     s = 0.1*sin(2*pi*t) + cnse;\n#\n#     subplot(211)\n#     plot(t, s)\n#     subplot(212)\n#     psd(s, 512, 1/dt)\n#\n# Below we'll show a slightly more complex example that demonstrates\n# how padding affects the resulting PSD.\n\ndt = np.pi / 100.\nfs = 1. / dt\nt = np.arange(0, 8, dt)\ny = 10. * np.sin(2 * np.pi * 4 * t) + 5. * np.sin(2 * np.pi * 4.25 * t)\ny = y + np.random.randn(*t.shape)\n\n# Plot the raw time series\nfig, axs = plt.subplot_mosaic([\n    ['signal', 'signal', 'signal'],\n    ['zero padding', 'block size', 'overlap'],\n], layout='constrained')\n\naxs['signal'].plot(t, y)\naxs['signal'].set_xlabel('Time (s)')\naxs['signal'].set_ylabel('Signal')\n\n# Plot the PSD with different amounts of zero padding. This uses the entire\n# time series at once\naxs['zero padding'].psd(y, NFFT=len(t), pad_to=len(t), Fs=fs)\naxs['zero padding'].psd(y, NFFT=len(t), pad_to=len(t) * 2, Fs=fs)\naxs['zero padding'].psd(y, NFFT=len(t), pad_to=len(t) * 4, Fs=fs)\n\n# Plot the PSD with different block sizes, Zero pad to the length of the\n# original data sequence.\naxs['block size'].psd(y, NFFT=len(t), pad_to=len(t), Fs=fs)\naxs['block size'].psd(y, NFFT=len(t) // 2, pad_to=len(t), Fs=fs)\naxs['block size'].psd(y, NFFT=len(t) // 4, pad_to=len(t), Fs=fs)\naxs['block size'].set_ylabel('')\n\n# Plot the PSD with different amounts of overlap between blocks\naxs['overlap'].psd(y, NFFT=len(t) // 2, pad_to=len(t), noverlap=0, Fs=fs)\naxs['overlap'].psd(y, NFFT=len(t) // 2, pad_to=len(t),\n                   noverlap=int(0.025 * len(t)), Fs=fs)\naxs['overlap'].psd(y, NFFT=len(t) // 2, pad_to=len(t),\n                   noverlap=int(0.1 * len(t)), Fs=fs)\naxs['overlap'].set_ylabel('')\naxs['overlap'].set_title('overlap')\n\nfor title, ax in axs.items():\n    if title == 'signal':\n        continue\n\n    ax.set_title(title)\n    ax.sharex(axs['zero padding'])\n    ax.sharey(axs['zero padding'])\n\nplt.show()\n\n\n# %%\n# This is a ported version of a MATLAB example from the signal\n# processing toolbox that showed some difference at one time between\n# Matplotlib's and MATLAB's scaling of the PSD.\n\nfs = 1000\nt = np.linspace(0, 0.3, 301)\nA = np.array([2, 8]).reshape(-1, 1)\nf = np.array([150, 140]).reshape(-1, 1)\nxn = (A * np.sin(2 * np.pi * f * t)).sum(axis=0)\nxn += 5 * np.random.randn(*t.shape)\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, layout='constrained')\n\nyticks = np.arange(-50, 30, 10)\nyrange = (yticks[0], yticks[-1])\nxticks = np.arange(0, 550, 100)\n\nax0.psd(xn, NFFT=301, Fs=fs, window=mlab.window_none, pad_to=1024,\n        scale_by_freq=True)\nax0.set_title('Periodogram')\nax0.set_yticks(yticks)\nax0.set_xticks(xticks)\nax0.grid(True)\nax0.set_ylim(yrange)\n\nax1.psd(xn, NFFT=150, Fs=fs, window=mlab.window_none, pad_to=512, noverlap=75,\n        scale_by_freq=True)\nax1.set_title('Welch')\nax1.set_xticks(xticks)\nax1.set_yticks(yticks)\nax1.set_ylabel('')  # overwrite the y-label added by `psd`\nax1.grid(True)\nax1.set_ylim(yrange)\n\nplt.show()\n\n# %%\n# This is a ported version of a MATLAB example from the signal\n# processing toolbox that showed some difference at one time between\n# Matplotlib's and MATLAB's scaling of the PSD.\n#\n# It uses a complex signal so we can see that complex PSD's work properly.\n\nprng = np.random.RandomState(19680801)  # to ensure reproducibility\n\nfs = 1000\nt = np.linspace(0, 0.3, 301)\nA = np.array([2, 8]).reshape(-1, 1)\nf = np.array([150, 140]).reshape(-1, 1)\nxn = (A * np.exp(2j * np.pi * f * t)).sum(axis=0) + 5 * prng.randn(*t.shape)\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, layout='constrained')\n\nyticks = np.arange(-50, 30, 10)\nyrange = (yticks[0], yticks[-1])\nxticks = np.arange(-500, 550, 200)\n\nax0.psd(xn, NFFT=301, Fs=fs, window=mlab.window_none, pad_to=1024,\n        scale_by_freq=True)\nax0.set_title('Periodogram')\nax0.set_yticks(yticks)\nax0.set_xticks(xticks)\nax0.grid(True)\nax0.set_ylim(yrange)\n\nax1.psd(xn, NFFT=150, Fs=fs, window=mlab.window_none, pad_to=512, noverlap=75,\n        scale_by_freq=True)\nax1.set_title('Welch')\nax1.set_xticks(xticks)\nax1.set_yticks(yticks)\nax1.set_ylabel('')  # overwrite the y-label added by `psd`\nax1.grid(True)\nax1.set_ylim(yrange)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    domain: signal-processing\n#    plot-type: line\n#    level: intermediate\n"
    },
    {
      "filename": "scatter_demo2.py",
      "title": "Scatter Demo2",
      "code": "\"\"\"\n=============\nScatter Demo2\n=============\n\nDemo of scatter plot with varying marker colors and sizes.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\n# Load a numpy record array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit ('D') in\n# the date column.\nprice_data = cbook.get_sample_data('goog.npz')['price_data']\nprice_data = price_data[-250:]  # get the most recent 250 trading days\n\ndelta1 = np.diff(price_data[\"adj_close\"]) / price_data[\"adj_close\"][:-1]\n\n# Marker size in units of points^2\nvolume = (15 * price_data[\"volume\"][:-2] / price_data[\"volume\"][0])**2\nclose = 0.003 * price_data[\"close\"][:-2] / 0.003 * price_data[\"open\"][:-2]\n\nfig, ax = plt.subplots()\nax.scatter(delta1[:-1], delta1[1:], c=close, s=volume, alpha=0.5)\n\nax.set_xlabel(r'$\\Delta_i$', fontsize=15)\nax.set_ylabel(r'$\\Delta_{i+1}$', fontsize=15)\nax.set_title('Volume and percent change')\n\nax.grid(True)\nfig.tight_layout()\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: marker\n#    component: color\n#    plot-style: scatter\n#    level: beginner\n"
    },
    {
      "filename": "scatter_hist.py",
      "title": "Scatter Hist",
      "code": "\"\"\"\n============================\nScatter plot with histograms\n============================\n\nAdd histograms to the x-axes and y-axes margins of a scatter plot.\n\nThis layout features a central scatter plot illustrating the relationship\nbetween x and y, a histogram at the top displaying the distribution of x, and a\nhistogram on the right showing the distribution of y.\n\nFor a nice alignment of the main Axes with the marginals, two options are shown\nbelow:\n\n.. contents::\n   :local:\n\nWhile `.Axes.inset_axes` may be a bit more complex, it allows correct handling\nof main Axes with a fixed aspect ratio.\n\nLet us first define a function that takes x and y data as input, as well as\nthree Axes, the main Axes for the scatter, and two marginal Axes. It will then\ncreate the scatter and histograms inside the provided Axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# some random data\nx = np.random.randn(1000)\ny = np.random.randn(1000)\n\n\ndef scatter_hist(x, y, ax, ax_histx, ax_histy):\n    # no labels\n    ax_histx.tick_params(axis=\"x\", labelbottom=False)\n    ax_histy.tick_params(axis=\"y\", labelleft=False)\n\n    # the scatter plot:\n    ax.scatter(x, y)\n\n    # now determine nice limits by hand:\n    binwidth = 0.25\n    xymax = max(np.max(np.abs(x)), np.max(np.abs(y)))\n    lim = (int(xymax/binwidth) + 1) * binwidth\n\n    bins = np.arange(-lim, lim + binwidth, binwidth)\n    ax_histx.hist(x, bins=bins)\n    ax_histy.hist(y, bins=bins, orientation='horizontal')\n\n\n# %%\n# Defining the Axes positions using subplot_mosaic\n# ------------------------------------------------\n#\n# We use the `~.pyplot.subplot_mosaic` function to define the positions and\n# names of the three axes; the empty axes is specified by ``'.'``.  We manually\n# specify the size of the figure, and can make the different axes have\n# different sizes by specifying the *width_ratios* and *height_ratios*\n# arguments. The *layout* argument is set to ``'constrained'`` to optimize the\n# spacing between the axes.\n\nfig, axs = plt.subplot_mosaic([['histx', '.'],\n                               ['scatter', 'histy']],\n                              figsize=(6, 6),\n                              width_ratios=(4, 1), height_ratios=(1, 4),\n                              layout='constrained')\nscatter_hist(x, y, axs['scatter'], axs['histx'], axs['histy'])\n\n\n# %%\n#\n# Defining the Axes positions using inset_axes\n# --------------------------------------------\n#\n# `~.Axes.inset_axes` can be used to position marginals *outside* the main\n# Axes.  The advantage of doing so is that the aspect ratio of the main Axes\n# can be fixed, and the marginals will always be drawn relative to the position\n# of the Axes.\n\n# Create a Figure, which doesn't have to be square.\nfig = plt.figure(layout='constrained')\n# Create the main Axes.\nax = fig.add_subplot()\n# The main Axes' aspect can be fixed.\nax.set_aspect('equal')\n# Create marginal Axes, which have 25% of the size of the main Axes.  Note that\n# the inset Axes are positioned *outside* (on the right and the top) of the\n# main Axes, by specifying axes coordinates greater than 1.  Axes coordinates\n# less than 0 would likewise specify positions on the left and the bottom of\n# the main Axes.\nax_histx = ax.inset_axes([0, 1.05, 1, 0.25], sharex=ax)\nax_histy = ax.inset_axes([1.05, 0, 0.25, 1], sharey=ax)\n# Draw the scatter plot and marginals.\nscatter_hist(x, y, ax, ax_histx, ax_histy)\n\nplt.show()\n\n\n# %%\n#\n# While we recommend using one of the two methods described above, there are\n# number of other ways to achieve a similar layout:\n#\n# - The Axes can be positioned manually in relative coordinates using\n#   `~matplotlib.figure.Figure.add_axes`.\n# - A gridspec can be used to create the layout\n#   (`~matplotlib.figure.Figure.add_gridspec`) and adding only the three desired\n#   axes (`~matplotlib.figure.Figure.add_subplot`).\n# - Four subplots can be created  using `~.pyplot.subplots`,  and the unused\n#   axes in the upper right can be removed manually.\n# - The ``axes_grid1`` toolkit can be used, as shown in\n#   :doc:`/gallery/axes_grid1/scatter_hist_locatable_axes`.\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure.subplot_mosaic`\n#    - `matplotlib.pyplot.subplot_mosaic`\n#    - `matplotlib.figure.Figure.add_subplot`\n#    - `matplotlib.axes.Axes.inset_axes`\n#    - `matplotlib.axes.Axes.scatter`\n#    - `matplotlib.axes.Axes.hist`\n#\n# .. tags::\n#\n#    component: axes\n#    plot-type: scatter\n#    plot-type: histogram\n#    level: intermediate\n"
    },
    {
      "filename": "scatter_masked.py",
      "title": "Scatter Masked",
      "code": "\"\"\"\n===============================\nScatter plot with masked values\n===============================\n\nMask some data points and add a line demarking\nmasked regions.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nN = 100\nr0 = 0.6\nx = 0.9 * np.random.rand(N)\ny = 0.9 * np.random.rand(N)\narea = (20 * np.random.rand(N))**2  # 0 to 10 point radii\nc = np.sqrt(area)\nr = np.sqrt(x ** 2 + y ** 2)\narea1 = np.ma.masked_where(r < r0, area)\narea2 = np.ma.masked_where(r >= r0, area)\nplt.scatter(x, y, s=area1, marker='^', c=c)\nplt.scatter(x, y, s=area2, marker='o', c=c)\n# Show the boundary between the regions:\ntheta = np.arange(0, np.pi / 2, 0.01)\nplt.plot(r0 * np.cos(theta), r0 * np.sin(theta))\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: marker\n#    plot-type: scatter\n#    level: beginner\n"
    },
    {
      "filename": "scatter_star_poly.py",
      "title": "Scatter Star Poly",
      "code": "\"\"\"\n===============\nMarker examples\n===============\n\nExample with different ways to specify markers.\n\nSee also the `matplotlib.markers` documentation for a list of all markers and\n:doc:`/gallery/lines_bars_and_markers/marker_reference` for more information\non configuring markers.\n\n.. redirect-from:: /gallery/lines_bars_and_markers/scatter_custom_symbol\n.. redirect-from:: /gallery/lines_bars_and_markers/scatter_symbol\n.. redirect-from:: /gallery/lines_bars_and_markers/scatter_piecharts\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.rand(10)\ny = np.random.rand(10)\nz = np.sqrt(x**2 + y**2)\n\nfig, axs = plt.subplots(2, 3, sharex=True, sharey=True, layout=\"constrained\")\n\n# Matplotlib marker symbol\naxs[0, 0].scatter(x, y, s=80, c=z, marker=\">\")\naxs[0, 0].set_title(\"marker='>'\")\n\n# marker from TeX: passing a TeX symbol name enclosed in $-signs\naxs[0, 1].scatter(x, y, s=80, c=z, marker=r\"$\\clubsuit$\")\naxs[0, 1].set_title(r\"marker=r'\\$\\clubsuit\\$'\")\n\n# marker from path: passing a custom path of N vertices as a (N, 2) array-like\nverts = [[-1, -1], [1, -1], [1, 1], [-1, -1]]\naxs[0, 2].scatter(x, y, s=80, c=z, marker=verts)\naxs[0, 2].set_title(\"marker=verts\")\n\n# regular pentagon marker\naxs[1, 0].scatter(x, y, s=80, c=z, marker=(5, 0))\naxs[1, 0].set_title(\"marker=(5, 0)\")\n\n# regular 5-pointed star marker\naxs[1, 1].scatter(x, y, s=80, c=z, marker=(5, 1))\naxs[1, 1].set_title(\"marker=(5, 1)\")\n\n# regular 5-pointed asterisk marker\naxs[1, 2].scatter(x, y, s=80, c=z, marker=(5, 2))\naxs[1, 2].set_title(\"marker=(5, 2)\")\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: marker\n#    level: beginner\n"
    },
    {
      "filename": "scatter_with_legend.py",
      "title": "Scatter With Legend",
      "code": "\"\"\"\n==========================\nScatter plot with a legend\n==========================\n\nTo create a scatter plot with a legend one may use a loop and create one\n`~.Axes.scatter` plot per item to appear in the legend and set the ``label``\naccordingly.\n\nThe following also demonstrates how transparency of the markers\ncan be adjusted by giving ``alpha`` a value between 0 and 1.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nfor color in ['tab:blue', 'tab:orange', 'tab:green']:\n    n = 750\n    x, y = np.random.rand(2, n)\n    scale = 200.0 * np.random.rand(n)\n    ax.scatter(x, y, c=color, s=scale, label=color,\n               alpha=0.3, edgecolors='none')\n\nax.legend()\nax.grid(True)\n\nplt.show()\n\n\n# %%\n# .. _automatedlegendcreation:\n#\n# Automated legend creation\n# -------------------------\n#\n# Another option for creating a legend for a scatter is to use the\n# `.PathCollection.legend_elements` method.  It will automatically try to\n# determine a useful number of legend entries to be shown and return a tuple of\n# handles and labels. Those can be passed to the call to `~.axes.Axes.legend`.\n\n\nN = 45\nx, y = np.random.rand(2, N)\nc = np.random.randint(1, 5, size=N)\ns = np.random.randint(10, 220, size=N)\n\nfig, ax = plt.subplots()\n\nscatter = ax.scatter(x, y, c=c, s=s)\n\n# produce a legend with the unique colors from the scatter\nlegend1 = ax.legend(*scatter.legend_elements(),\n                    loc=\"lower left\", title=\"Classes\")\nax.add_artist(legend1)\n\n# produce a legend with a cross-section of sizes from the scatter\nhandles, labels = scatter.legend_elements(prop=\"sizes\", alpha=0.6)\nlegend2 = ax.legend(handles, labels, loc=\"upper right\", title=\"Sizes\")\n\nplt.show()\n\n\n# %%\n# Further arguments to the `.PathCollection.legend_elements` method\n# can be used to steer how many legend entries are to be created and how they\n# should be labeled. The following shows how to use some of them.\n\nvolume = np.random.rayleigh(27, size=40)\namount = np.random.poisson(10, size=40)\nranking = np.random.normal(size=40)\nprice = np.random.uniform(1, 10, size=40)\n\nfig, ax = plt.subplots()\n\n# Because the price is much too small when being provided as size for ``s``,\n# we normalize it to some useful point sizes, s=0.3*(price*3)**2\nscatter = ax.scatter(volume, amount, c=ranking, s=0.3*(price*3)**2,\n                     vmin=-3, vmax=3, cmap=\"Spectral\")\n\n# Produce a legend for the ranking (colors). Even though there are 40 different\n# rankings, we only want to show 5 of them in the legend.\nlegend1 = ax.legend(*scatter.legend_elements(num=5),\n                    loc=\"upper left\", title=\"Ranking\")\nax.add_artist(legend1)\n\n# Produce a legend for the price (sizes). Because we want to show the prices\n# in dollars, we use the *func* argument to supply the inverse of the function\n# used to calculate the sizes from above. The *fmt* ensures to show the price\n# in dollars. Note how we target at 5 elements here, but obtain only 4 in the\n# created legend due to the automatic round prices that are chosen for us.\nkw = dict(prop=\"sizes\", num=5, color=scatter.cmap(0.7), fmt=\"$ {x:.2f}\",\n          func=lambda s: np.sqrt(s/.3)/3)\nlegend2 = ax.legend(*scatter.legend_elements(**kw),\n                    loc=\"lower right\", title=\"Price\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.scatter` / `matplotlib.pyplot.scatter`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.collections.PathCollection.legend_elements`\n#\n# .. tags::\n#\n#    component: legend\n#    plot-type: scatter\n#    level: intermediate\n"
    },
    {
      "filename": "simple_plot.py",
      "title": "Simple Plot",
      "code": "\"\"\"\n=========\nLine plot\n=========\n\nCreate a basic line plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.set(xlabel='time (s)', ylabel='voltage (mV)',\n       title='About as simple as it gets, folks')\nax.grid()\n\nfig.savefig(\"test.png\")\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.figure.Figure.savefig`\n#\n# .. tags::\n#\n#    plot-style: line\n#    level: beginner\n"
    },
    {
      "filename": "span_regions.py",
      "title": "Span Regions",
      "code": "\"\"\"\n==========================================================\nShade regions defined by a logical mask using fill_between\n==========================================================\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2, 0.01)\ns = np.sin(2*np.pi*t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s, color='black')\nax.axhline(0, color='black')\n\nax.fill_between(t, 1, where=s > 0, facecolor='green', alpha=.5)\nax.fill_between(t, -1, where=s < 0, facecolor='red', alpha=.5)\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.fill_between`\n#\n# .. tags::\n#\n#    styling: conditional\n#    plot-style: fill_between\n#    level: beginner\n"
    },
    {
      "filename": "spectrum_demo.py",
      "title": "Spectrum Demo",
      "code": "\"\"\"\n========================\nSpectrum representations\n========================\n\nThe plots show different spectrum representations of a sine signal with\nadditive noise. A (frequency) spectrum of a discrete-time signal is calculated\nby utilizing the fast Fourier transform (FFT).\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(0)\n\ndt = 0.01  # sampling interval\nFs = 1 / dt  # sampling frequency\nt = np.arange(0, 10, dt)\n\n# generate noise:\nnse = np.random.randn(len(t))\nr = np.exp(-t / 0.05)\ncnse = np.convolve(nse, r) * dt\ncnse = cnse[:len(t)]\n\ns = 0.1 * np.sin(4 * np.pi * t) + cnse  # the signal\n\nfig = plt.figure(figsize=(7, 7), layout='constrained')\naxs = fig.subplot_mosaic([[\"signal\", \"signal\"],\n                          [\"magnitude\", \"log_magnitude\"],\n                          [\"phase\", \"angle\"]])\n\n# plot time signal:\naxs[\"signal\"].set_title(\"Signal\")\naxs[\"signal\"].plot(t, s, color='C0')\naxs[\"signal\"].set_xlabel(\"Time (s)\")\naxs[\"signal\"].set_ylabel(\"Amplitude\")\n\n# plot different spectrum types:\naxs[\"magnitude\"].set_title(\"Magnitude Spectrum\")\naxs[\"magnitude\"].magnitude_spectrum(s, Fs=Fs, color='C1')\n\naxs[\"log_magnitude\"].set_title(\"Log. Magnitude Spectrum\")\naxs[\"log_magnitude\"].magnitude_spectrum(s, Fs=Fs, scale='dB', color='C1')\n\naxs[\"phase\"].set_title(\"Phase Spectrum \")\naxs[\"phase\"].phase_spectrum(s, Fs=Fs, color='C2')\n\naxs[\"angle\"].set_title(\"Angle Spectrum\")\naxs[\"angle\"].angle_spectrum(s, Fs=Fs, color='C2')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    domain: signal-processing\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "stackplot_demo.py",
      "title": "Stackplot Demo",
      "code": "\"\"\"\n===========================\nStackplots and streamgraphs\n===========================\n\"\"\"\n\n# %%\n# Stackplots\n# ----------\n#\n# Stackplots draw multiple datasets as vertically stacked areas. This is\n# useful when the individual data values and additionally their cumulative\n# value are of interest.\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as mticker\n\n# data from United Nations World Population Prospects (Revision 2019)\n# https://population.un.org/wpp/, license: CC BY 3.0 IGO\nyear = [1950, 1960, 1970, 1980, 1990, 2000, 2010, 2018]\npopulation_by_continent = {\n    'Africa': [.228, .284, .365, .477, .631, .814, 1.044, 1.275],\n    'the Americas': [.340, .425, .519, .619, .727, .840, .943, 1.006],\n    'Asia': [1.394, 1.686, 2.120, 2.625, 3.202, 3.714, 4.169, 4.560],\n    'Europe': [.220, .253, .276, .295, .310, .303, .294, .293],\n    'Oceania': [.012, .015, .019, .022, .026, .031, .036, .039],\n}\n\nfig, ax = plt.subplots()\nax.stackplot(year, population_by_continent.values(),\n             labels=population_by_continent.keys(), alpha=0.8)\nax.legend(loc='upper left', reverse=True)\nax.set_title('World population')\nax.set_xlabel('Year')\nax.set_ylabel('Number of people (billions)')\n# add tick at every 200 million people\nax.yaxis.set_minor_locator(mticker.MultipleLocator(.2))\n\nplt.show()\n\n# %%\n# Streamgraphs\n# ------------\n#\n# Using the *baseline* parameter, you can turn an ordinary stacked area plot\n# with baseline 0 into a stream graph.\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef gaussian_mixture(x, n=5):\n    \"\"\"Return a random mixture of *n* Gaussians, evaluated at positions *x*.\"\"\"\n    def add_random_gaussian(a):\n        amplitude = 1 / (.1 + np.random.random())\n        dx = x[-1] - x[0]\n        x0 = (2 * np.random.random() - .5) * dx\n        z = 10 / (.1 + np.random.random()) / dx\n        a += amplitude * np.exp(-(z * (x - x0))**2)\n    a = np.zeros_like(x)\n    for j in range(n):\n        add_random_gaussian(a)\n    return a\n\n\nx = np.linspace(0, 100, 101)\nys = [gaussian_mixture(x) for _ in range(3)]\n\nfig, ax = plt.subplots()\nax.stackplot(x, ys, baseline='wiggle')\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: stackplot\n#    level: intermediate\n"
    },
    {
      "filename": "stairs_demo.py",
      "title": "Stairs Demo",
      "code": "\"\"\"\n===========\nStairs Demo\n===========\n\nThis example demonstrates the use of `~.matplotlib.pyplot.stairs` for stepwise\nconstant functions. A common use case is histogram and histogram-like data\nvisualization.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import StepPatch\n\nnp.random.seed(0)\nh, edges = np.histogram(np.random.normal(5, 3, 5000),\n                        bins=np.linspace(0, 10, 20))\n\nfig, axs = plt.subplots(3, 1, figsize=(7, 15))\naxs[0].stairs(h, edges, label='Simple histogram')\naxs[0].stairs(h, edges + 5, baseline=50, label='Modified baseline')\naxs[0].stairs(h, edges + 10, baseline=None, label='No edges')\naxs[0].set_title(\"Step Histograms\")\n\naxs[1].stairs(np.arange(1, 6, 1), fill=True,\n              label='Filled histogram\\nw/ automatic edges')\naxs[1].stairs(np.arange(1, 6, 1)*0.3, np.arange(2, 8, 1),\n              orientation='horizontal', hatch='//',\n              label='Hatched histogram\\nw/ horizontal orientation')\naxs[1].set_title(\"Filled histogram\")\n\npatch = StepPatch(values=[1, 2, 3, 2, 1],\n                  edges=range(1, 7),\n                  label=('Patch derived underlying object\\n'\n                         'with default edge/facecolor behaviour'))\naxs[2].add_patch(patch)\naxs[2].set_xlim(0, 7)\naxs[2].set_ylim(-1, 5)\naxs[2].set_title(\"StepPatch artist\")\n\nfor ax in axs:\n    ax.legend()\nplt.show()\n\n# %%\n# *baseline* can take an array to allow for stacked histogram plots\nA = [[0, 0, 0],\n     [1, 2, 3],\n     [2, 4, 6],\n     [3, 6, 9]]\n\nfor i in range(len(A) - 1):\n    plt.stairs(A[i+1], baseline=A[i], fill=True)\n\n# %%\n# Comparison of `.pyplot.step` and `.pyplot.stairs`\n# -------------------------------------------------\n#\n# `.pyplot.step` defines the positions of the steps as single values. The steps\n# extend left/right/both ways from these reference values depending on the\n# parameter *where*. The number of *x* and *y* values is the same.\n#\n# In contrast, `.pyplot.stairs` defines the positions of the steps via their\n# bounds *edges*, which is one element longer than the step values.\n\nbins = np.arange(14)\ncenters = bins[:-1] + np.diff(bins) / 2\ny = np.sin(centers / 2)\n\nplt.step(bins[:-1], y, where='post', label='step(where=\"post\")')\nplt.plot(bins[:-1], y, 'o--', color='grey', alpha=0.3)\n\nplt.stairs(y - 1, bins, baseline=None, label='stairs()')\nplt.plot(centers, y - 1, 'o--', color='grey', alpha=0.3)\nplt.plot(np.repeat(bins, 2), np.hstack([y[0], np.repeat(y, 2), y[-1]]) - 1,\n         'o', color='red', alpha=0.2)\n\nplt.legend()\nplt.title('step() vs. stairs()')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.stairs` / `matplotlib.pyplot.stairs`\n#    - `matplotlib.patches.StepPatch`\n#\n# .. tags::\n#\n#    plot-type: stairs\n#    level: intermediate\n"
    },
    {
      "filename": "stem_plot.py",
      "title": "Stem Plot",
      "code": "\"\"\"\n=========\nStem plot\n=========\n\n`~.pyplot.stem` plots vertical lines from a baseline to the y-coordinate and\nplaces a marker at the tip.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0.1, 2 * np.pi, 41)\ny = np.exp(np.sin(x))\n\nplt.stem(x, y)\nplt.show()\n\n# %%\n#\n# The position of the baseline can be adapted using *bottom*.\n# The parameters *linefmt*, *markerfmt*, and *basefmt* control basic format\n# properties of the plot. However, in contrast to `~.pyplot.plot` not all\n# properties are configurable via keyword arguments. For more advanced\n# control adapt the line objects returned by `.pyplot`.\n\nmarkerline, stemlines, baseline = plt.stem(\n    x, y, linefmt='grey', markerfmt='D', bottom=1.1)\nmarkerline.set_markerfacecolor('none')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.stem` / `matplotlib.pyplot.stem`\n#\n# .. tags::\n#\n#    plot-type: stem\n#    level: beginner\n"
    },
    {
      "filename": "step_demo.py",
      "title": "Step Demo",
      "code": "\"\"\"\n=========\nStep Demo\n=========\n\nThis example demonstrates the use of `.pyplot.step` for piece-wise constant\ncurves. In particular, it illustrates the effect of the parameter *where*\non the step position.\n\n.. note::\n\n    For the common case that you know the edge positions, use `.pyplot.stairs`\n    instead.\n\nThe circular markers created with `.pyplot.plot` show the actual data\npositions so that it's easier to see the effect of *where*.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(14)\ny = np.sin(x / 2)\n\nplt.step(x, y + 2, label='pre (default)')\nplt.plot(x, y + 2, 'o--', color='grey', alpha=0.3)\n\nplt.step(x, y + 1, where='mid', label='mid')\nplt.plot(x, y + 1, 'o--', color='grey', alpha=0.3)\n\nplt.step(x, y, where='post', label='post')\nplt.plot(x, y, 'o--', color='grey', alpha=0.3)\n\nplt.grid(axis='x', color='0.95')\nplt.legend(title='Parameter where:')\nplt.title('plt.step(where=...)')\nplt.show()\n\n# %%\n# The same behavior can be achieved by using the ``drawstyle`` parameter of\n# `.pyplot.plot`.\n\nplt.plot(x, y + 2, drawstyle='steps', label='steps (=steps-pre)')\nplt.plot(x, y + 2, 'o--', color='grey', alpha=0.3)\n\nplt.plot(x, y + 1, drawstyle='steps-mid', label='steps-mid')\nplt.plot(x, y + 1, 'o--', color='grey', alpha=0.3)\n\nplt.plot(x, y, drawstyle='steps-post', label='steps-post')\nplt.plot(x, y, 'o--', color='grey', alpha=0.3)\n\nplt.grid(axis='x', color='0.95')\nplt.legend(title='Parameter drawstyle:')\nplt.title('plt.plot(drawstyle=...)')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.step` / `matplotlib.pyplot.step`\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#\n# .. tags::\n#\n#    plot-type: step\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "timeline.py",
      "title": "Timeline",
      "code": "\"\"\"\n====================================\nTimeline with lines, dates, and text\n====================================\n\nHow to create a simple timeline using Matplotlib release dates.\n\nTimelines can be created with a collection of dates and text. In this example,\nwe show how to create a simple timeline using the dates for recent releases\nof Matplotlib. First, we'll pull the data from GitHub.\n\"\"\"\n\nfrom datetime import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\ntry:\n    # Try to fetch a list of Matplotlib releases and their dates\n    # from https://api.github.com/repos/matplotlib/matplotlib/releases\n    import json\n    import urllib.request\n\n    url = 'https://api.github.com/repos/matplotlib/matplotlib/releases'\n    url += '?per_page=100'\n    data = json.loads(urllib.request.urlopen(url, timeout=1).read().decode())\n\n    dates = []\n    releases = []\n    for item in data:\n        if 'rc' not in item['tag_name'] and 'b' not in item['tag_name']:\n            dates.append(item['published_at'].split(\"T\")[0])\n            releases.append(item['tag_name'].lstrip(\"v\"))\n\nexcept Exception:\n    # In case the above fails, e.g. because of missing internet connection\n    # use the following lists as fallback.\n    releases = ['2.2.4', '3.0.3', '3.0.2', '3.0.1', '3.0.0', '2.2.3',\n                '2.2.2', '2.2.1', '2.2.0', '2.1.2', '2.1.1', '2.1.0',\n                '2.0.2', '2.0.1', '2.0.0', '1.5.3', '1.5.2', '1.5.1',\n                '1.5.0', '1.4.3', '1.4.2', '1.4.1', '1.4.0']\n    dates = ['2019-02-26', '2019-02-26', '2018-11-10', '2018-11-10',\n             '2018-09-18', '2018-08-10', '2018-03-17', '2018-03-16',\n             '2018-03-06', '2018-01-18', '2017-12-10', '2017-10-07',\n             '2017-05-10', '2017-05-02', '2017-01-17', '2016-09-09',\n             '2016-07-03', '2016-01-10', '2015-10-29', '2015-02-16',\n             '2014-10-26', '2014-10-18', '2014-08-26']\n\ndates = [datetime.strptime(d, \"%Y-%m-%d\") for d in dates]  # Convert strs to dates.\nreleases = [tuple(release.split('.')) for release in releases]  # Split by component.\ndates, releases = zip(*sorted(zip(dates, releases)))  # Sort by increasing date.\n\n# %%\n# Next, we'll create a stem plot with some variation in levels as to\n# distinguish even close-by events. We add markers on the baseline for visual\n# emphasis on the one-dimensional nature of the timeline.\n#\n# For each event, we add a text label via `~.Axes.annotate`, which is offset\n# in units of points from the tip of the event line.\n#\n# Note that Matplotlib will automatically plot datetime inputs.\n\n# Choose some nice levels: alternate meso releases between top and bottom, and\n# progressively shorten the stems for micro releases.\nlevels = []\nmacro_meso_releases = sorted({release[:2] for release in releases})\nfor release in releases:\n    macro_meso = release[:2]\n    micro = int(release[2])\n    h = 1 + 0.8 * (5 - micro)\n    level = h if macro_meso_releases.index(macro_meso) % 2 == 0 else -h\n    levels.append(level)\n\n\ndef is_feature(release):\n    \"\"\"Return whether a version (split into components) is a feature release.\"\"\"\n    return release[-1] == '0'\n\n\n# The figure and the axes.\nfig, ax = plt.subplots(figsize=(8.8, 4), layout=\"constrained\")\nax.set(title=\"Matplotlib release dates\")\n\n# The vertical stems.\nax.vlines(dates, 0, levels,\n          color=[(\"tab:red\", 1 if is_feature(release) else .5) for release in releases])\n# The baseline.\nax.axhline(0, c=\"black\")\n# The markers on the baseline.\nmeso_dates = [date for date, release in zip(dates, releases) if is_feature(release)]\nmicro_dates = [date for date, release in zip(dates, releases)\n               if not is_feature(release)]\nax.plot(micro_dates, np.zeros_like(micro_dates), \"ko\", mfc=\"white\")\nax.plot(meso_dates, np.zeros_like(meso_dates), \"ko\", mfc=\"tab:red\")\n\n# Annotate the lines.\nfor date, level, release in zip(dates, levels, releases):\n    version_str = '.'.join(release)\n    ax.annotate(version_str, xy=(date, level),\n                xytext=(-3, np.sign(level)*3), textcoords=\"offset points\",\n                verticalalignment=\"bottom\" if level > 0 else \"top\",\n                weight=\"bold\" if is_feature(release) else \"normal\",\n                bbox=dict(boxstyle='square', pad=0, lw=0, fc=(1, 1, 1, 0.7)))\n\nax.xaxis.set(major_locator=mdates.YearLocator(),\n             major_formatter=mdates.DateFormatter(\"%Y\"))\n\n# Remove the y-axis and some spines.\nax.yaxis.set_visible(False)\nax.spines[[\"left\", \"top\", \"right\"]].set_visible(False)\n\nax.margins(y=0.1)\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.annotate`\n#    - `matplotlib.axes.Axes.vlines`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.dates.MonthLocator`\n#    - `matplotlib.dates.DateFormatter`\n#\n# .. tags::\n#\n#    component: annotate\n#    plot-type: line\n#    level: intermediate\n"
    },
    {
      "filename": "vline_hline_demo.py",
      "title": "Vline Hline Demo",
      "code": "\"\"\"\n=================\nhlines and vlines\n=================\n\nThis example showcases the functions hlines and vlines.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nt = np.arange(0.0, 5.0, 0.1)\ns = np.exp(-t) + np.sin(2 * np.pi * t) + 1\nnse = np.random.normal(0.0, 0.3, t.shape) * s\n\nfig, (vax, hax) = plt.subplots(1, 2, figsize=(12, 6))\n\nvax.plot(t, s + nse, '^')\nvax.vlines(t, [0], s)\n# By using ``transform=vax.get_xaxis_transform()`` the y coordinates are scaled\n# such that 0 maps to the bottom of the Axes and 1 to the top.\nvax.vlines([1, 2], 0, 1, transform=vax.get_xaxis_transform(), colors='r')\nvax.set_xlabel('time (s)')\nvax.set_title('Vertical lines demo')\n\nhax.plot(s + nse, t, '^')\nhax.hlines(t, [0], s, lw=2)\nhax.set_xlabel('time (s)')\nhax.set_title('Horizontal lines demo')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "xcorr_acorr_demo.py",
      "title": "Xcorr Acorr Demo",
      "code": "\"\"\"\n===========================\nCross- and auto-correlation\n===========================\n\nExample use of cross-correlation (`~.Axes.xcorr`) and auto-correlation\n(`~.Axes.acorr`) plots.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nx, y = np.random.randn(2, 100)\nfig, [ax1, ax2] = plt.subplots(2, 1, sharex=True)\nax1.xcorr(x, y, usevlines=True, maxlags=50, normed=True, lw=2)\nax1.grid(True)\nax1.set_title('Cross-correlation (xcorr)')\n\nax2.acorr(x, usevlines=True, normed=True, maxlags=50, lw=2)\nax2.grid(True)\nax2.set_title('Auto-correlation (acorr)')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.acorr` / `matplotlib.pyplot.acorr`\n#    - `matplotlib.axes.Axes.xcorr` / `matplotlib.pyplot.xcorr`\n#\n# .. tags::\n#\n#    domain: statistics\n#    level: beginner\n"
    }
  ],
  "misc": [
    {
      "filename": "anchored_artists.py",
      "title": "Anchored Artists",
      "code": "\"\"\"\n================\nAnchored Artists\n================\n\nThis example illustrates the use of the anchored objects without the\nhelper classes found in :mod:`mpl_toolkits.axes_grid1`. This version\nof the figure is similar to the one found in\n:doc:`/gallery/axes_grid1/simple_anchored_artists`, but it is\nimplemented using only the matplotlib namespace, without the help\nof additional toolkits.\n\n.. redirect-from:: /gallery/userdemo/anchored_box01\n.. redirect-from:: /gallery/userdemo/anchored_box02\n.. redirect-from:: /gallery/userdemo/anchored_box03\n\"\"\"\n\nfrom matplotlib import pyplot as plt\nfrom matplotlib.lines import Line2D\nfrom matplotlib.offsetbox import (AnchoredOffsetbox, AuxTransformBox,\n                                  DrawingArea, TextArea, VPacker)\nfrom matplotlib.patches import Circle, Ellipse\n\n\ndef draw_text(ax):\n    \"\"\"Draw a text-box anchored to the upper-left corner of the figure.\"\"\"\n    box = AnchoredOffsetbox(child=TextArea(\"Figure 1a\"),\n                            loc=\"upper left\", frameon=True)\n    box.patch.set_boxstyle(\"round,pad=0.,rounding_size=0.2\")\n    ax.add_artist(box)\n\n\ndef draw_circles(ax):\n    \"\"\"Draw circles in axes coordinates.\"\"\"\n    area = DrawingArea(width=40, height=20)\n    area.add_artist(Circle((10, 10), 10, fc=\"tab:blue\"))\n    area.add_artist(Circle((30, 10), 5, fc=\"tab:red\"))\n    box = AnchoredOffsetbox(\n        child=area, loc=\"upper right\", pad=0, frameon=False)\n    ax.add_artist(box)\n\n\ndef draw_ellipse(ax):\n    \"\"\"Draw an ellipse of width=0.1, height=0.15 in data coordinates.\"\"\"\n    aux_tr_box = AuxTransformBox(ax.transData)\n    aux_tr_box.add_artist(Ellipse((0, 0), width=0.1, height=0.15))\n    box = AnchoredOffsetbox(child=aux_tr_box, loc=\"lower left\", frameon=True)\n    ax.add_artist(box)\n\n\ndef draw_sizebar(ax):\n    \"\"\"\n    Draw a horizontal bar with length of 0.1 in data coordinates,\n    with a fixed label center-aligned underneath.\n    \"\"\"\n    size = 0.1\n    text = r\"1$^{\\prime}$\"\n    sizebar = AuxTransformBox(ax.transData)\n    sizebar.add_artist(Line2D([0, size], [0, 0], color=\"black\"))\n    text = TextArea(text)\n    packer = VPacker(\n        children=[sizebar, text], align=\"center\", sep=5)  # separation in points.\n    ax.add_artist(AnchoredOffsetbox(\n        child=packer, loc=\"lower center\", frameon=False,\n        pad=0.1, borderpad=0.5))  # paddings relative to the legend fontsize.\n\n\nfig, ax = plt.subplots()\nax.set_aspect(1)\n\ndraw_text(ax)\ndraw_circles(ax)\ndraw_ellipse(ax)\ndraw_sizebar(ax)\n\nplt.show()\n"
    },
    {
      "filename": "bbox_intersect.py",
      "title": "Bbox Intersect",
      "code": "\"\"\"\n==================================\nIdentify whether artists intersect\n==================================\n\nThe lines intersecting the rectangle are colored in red, while the others\nare left as blue lines. This example showcases the `.intersects_bbox` function.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Bbox\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nleft, bottom, width, height = (-1, -1, 2, 2)\nrect = plt.Rectangle((left, bottom), width, height,\n                     facecolor=\"black\", alpha=0.1)\n\nfig, ax = plt.subplots()\nax.add_patch(rect)\n\nbbox = Bbox.from_bounds(left, bottom, width, height)\n\nfor i in range(12):\n    vertices = (np.random.random((2, 2)) - 0.5) * 6.0\n    path = Path(vertices)\n    if path.intersects_bbox(bbox):\n        color = 'r'\n    else:\n        color = 'b'\n    ax.plot(vertices[:, 0], vertices[:, 1], color=color)\n\nplt.show()\n"
    },
    {
      "filename": "contour_manual.py",
      "title": "Contour Manual",
      "code": "\"\"\"\n==============\nManual Contour\n==============\n\nExample of displaying your own contour lines and polygons using ContourSet.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.cm as cm\nfrom matplotlib.contour import ContourSet\nfrom matplotlib.path import Path\n\n# %%\n# Contour lines for each level are a list/tuple of polygons.\nlines0 = [[[0, 0], [0, 4]]]\nlines1 = [[[2, 0], [1, 2], [1, 3]]]\nlines2 = [[[3, 0], [3, 2]], [[3, 3], [3, 4]]]  # Note two lines.\n\n# %%\n# Filled contours between two levels are also a list/tuple of polygons.\n# Points can be ordered clockwise or anticlockwise.\nfilled01 = [[[0, 0], [0, 4], [1, 3], [1, 2], [2, 0]]]\nfilled12 = [[[2, 0], [3, 0], [3, 2], [1, 3], [1, 2]],   # Note two polygons.\n            [[1, 4], [3, 4], [3, 3]]]\n\n# %%\n\nfig, ax = plt.subplots()\n\n# Filled contours using filled=True.\ncs = ContourSet(ax, [0, 1, 2], [filled01, filled12], filled=True, cmap=cm.bone)\ncbar = fig.colorbar(cs)\n\n# Contour lines (non-filled).\nlines = ContourSet(\n    ax, [0, 1, 2], [lines0, lines1, lines2], cmap=cm.cool, linewidths=3)\ncbar.add_lines(lines)\n\nax.set(xlim=(-0.5, 3.5), ylim=(-0.5, 4.5),\n       title='User-specified contours')\n\n# %%\n# Multiple filled contour lines can be specified in a single list of polygon\n# vertices along with a list of vertex kinds (code types) as described in the\n# Path class.  This is particularly useful for polygons with holes.\n\nfig, ax = plt.subplots()\nfilled01 = [[[0, 0], [3, 0], [3, 3], [0, 3], [1, 1], [1, 2], [2, 2], [2, 1]]]\nM = Path.MOVETO\nL = Path.LINETO\nkinds01 = [[M, L, L, L, M, L, L, L]]\ncs = ContourSet(ax, [0, 1], [filled01], [kinds01], filled=True)\ncbar = fig.colorbar(cs)\n\nax.set(xlim=(-0.5, 3.5), ylim=(-0.5, 3.5),\n       title='User specified filled contours with holes')\n\nplt.show()\n"
    },
    {
      "filename": "coords_report.py",
      "title": "Coords Report",
      "code": "\"\"\"\n=============\nCoords Report\n=============\n\nOverride the default reporting of coords as the mouse moves over the Axes\nin an interactive backend.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef millions(x):\n    return '$%1.1fM' % (x * 1e-6)\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.rand(20)\ny = 1e7 * np.random.rand(20)\n\nfig, ax = plt.subplots()\nax.fmt_ydata = millions\nplt.plot(x, y, 'o')\n\nplt.show()\n"
    },
    {
      "filename": "custom_projection.py",
      "title": "Custom Projection",
      "code": "\"\"\"\n=================\nCustom projection\n=================\n\nShowcase Hammer projection by alleviating many features of Matplotlib.\n\"\"\"\n\nimport numpy as np\n\nimport matplotlib\nfrom matplotlib.axes import Axes\nimport matplotlib.axis as maxis\nfrom matplotlib.patches import Circle\nfrom matplotlib.path import Path\nfrom matplotlib.projections import register_projection\nimport matplotlib.spines as mspines\nfrom matplotlib.ticker import FixedLocator, Formatter, NullLocator\nfrom matplotlib.transforms import Affine2D, BboxTransformTo, Transform\n\nrcParams = matplotlib.rcParams\n\n# This example projection class is rather long, but it is designed to\n# illustrate many features, not all of which will be used every time.\n# It is also common to factor out a lot of these methods into common\n# code used by a number of projections with similar characteristics\n# (see geo.py).\n\n\nclass GeoAxes(Axes):\n    \"\"\"\n    An abstract base class for geographic projections\n    \"\"\"\n    class ThetaFormatter(Formatter):\n        \"\"\"\n        Used to format the theta tick labels.  Converts the native\n        unit of radians into degrees and adds a degree symbol.\n        \"\"\"\n        def __init__(self, round_to=1.0):\n            self._round_to = round_to\n\n        def __call__(self, x, pos=None):\n            degrees = round(np.rad2deg(x) / self._round_to) * self._round_to\n            return f\"{degrees:0.0f}\\N{DEGREE SIGN}\"\n\n    RESOLUTION = 75\n\n    def _init_axis(self):\n        self.xaxis = maxis.XAxis(self)\n        self.yaxis = maxis.YAxis(self)\n        # Do not register xaxis or yaxis with spines -- as done in\n        # Axes._init_axis() -- until GeoAxes.xaxis.clear() works.\n        # self.spines['geo'].register_axis(self.yaxis)\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n\n        self.set_longitude_grid(30)\n        self.set_latitude_grid(15)\n        self.set_longitude_grid_ends(75)\n        self.xaxis.set_minor_locator(NullLocator())\n        self.yaxis.set_minor_locator(NullLocator())\n        self.xaxis.set_ticks_position('none')\n        self.yaxis.set_ticks_position('none')\n        self.yaxis.set_tick_params(label1On=True)\n        # Why do we need to turn on yaxis tick labels, but\n        # xaxis tick labels are already on?\n\n        self.grid(rcParams['axes.grid'])\n\n        Axes.set_xlim(self, -np.pi, np.pi)\n        Axes.set_ylim(self, -np.pi / 2.0, np.pi / 2.0)\n\n    def _set_lim_and_transforms(self):\n        # A (possibly non-linear) projection on the (already scaled) data\n\n        # There are three important coordinate spaces going on here:\n        #\n        # 1. Data space: The space of the data itself\n        #\n        # 2. Axes space: The unit rectangle (0, 0) to (1, 1)\n        #    covering the entire plot area.\n        #\n        # 3. Display space: The coordinates of the resulting image,\n        #    often in pixels or dpi/inch.\n\n        # This function makes heavy use of the Transform classes in\n        # ``lib/matplotlib/transforms.py.`` For more information, see\n        # the inline documentation there.\n\n        # The goal of the first two transformations is to get from the\n        # data space (in this case longitude and latitude) to Axes\n        # space.  It is separated into a non-affine and affine part so\n        # that the non-affine part does not have to be recomputed when\n        # a simple affine change to the figure has been made (such as\n        # resizing the window or changing the dpi).\n\n        # 1) The core transformation from data space into\n        # rectilinear space defined in the HammerTransform class.\n        self.transProjection = self._get_core_transform(self.RESOLUTION)\n\n        # 2) The above has an output range that is not in the unit\n        # rectangle, so scale and translate it so it fits correctly\n        # within the Axes.  The peculiar calculations of xscale and\n        # yscale are specific to an Aitoff-Hammer projection, so don't\n        # worry about them too much.\n        self.transAffine = self._get_affine_transform()\n\n        # 3) This is the transformation from Axes space to display\n        # space.\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # Now put these 3 transforms together -- from data all the way\n        # to display coordinates.  Using the '+' operator, these\n        # transforms will be applied \"in order\".  The transforms are\n        # automatically simplified, if possible, by the underlying\n        # transformation framework.\n        self.transData = \\\n            self.transProjection + \\\n            self.transAffine + \\\n            self.transAxes\n\n        # The main data transformation is set up.  Now deal with\n        # gridlines and tick labels.\n\n        # Longitude gridlines and ticklabels.  The input to these\n        # transforms are in display space in x and Axes space in y.\n        # Therefore, the input values will be in range (-xmin, 0),\n        # (xmax, 1).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be offset 4\n        # pixels from the equator.\n        self._xaxis_pretransform = \\\n            Affine2D() \\\n            .scale(1.0, self._longitude_cap * 2.0) \\\n            .translate(0.0, -self._longitude_cap)\n        self._xaxis_transform = \\\n            self._xaxis_pretransform + \\\n            self.transData\n        self._xaxis_text1_transform = \\\n            Affine2D().scale(1.0, 0.0) + \\\n            self.transData + \\\n            Affine2D().translate(0.0, 4.0)\n        self._xaxis_text2_transform = \\\n            Affine2D().scale(1.0, 0.0) + \\\n            self.transData + \\\n            Affine2D().translate(0.0, -4.0)\n\n        # Now set up the transforms for the latitude ticks.  The input to\n        # these transforms are in Axes space in x and display space in\n        # y.  Therefore, the input values will be in range (0, -ymin),\n        # (1, ymax).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be offset 4\n        # pixels from the edge of the Axes ellipse.\n        yaxis_stretch = Affine2D().scale(np.pi*2, 1).translate(-np.pi, 0)\n        yaxis_space = Affine2D().scale(1.0, 1.1)\n        self._yaxis_transform = \\\n            yaxis_stretch + \\\n            self.transData\n        yaxis_text_base = \\\n            yaxis_stretch + \\\n            self.transProjection + \\\n            (yaxis_space +\n             self.transAffine +\n             self.transAxes)\n        self._yaxis_text1_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(-8.0, 0.0)\n        self._yaxis_text2_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(8.0, 0.0)\n\n    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\n            .translate(0.5, 0.5)\n\n    def get_xaxis_transform(self, which='grid'):\n        \"\"\"\n        Override this method to provide a transformation for the\n        x-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        \"\"\"\n        if which not in ['tick1', 'tick2', 'grid']:\n            raise ValueError(\n                \"'which' must be one of 'tick1', 'tick2', or 'grid'\")\n        return self._xaxis_transform\n\n    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text1_transform, 'bottom', 'center'\n\n    def get_xaxis_text2_transform(self, pad):\n        \"\"\"\n        Override this method to provide a transformation for the\n        secondary x-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        \"\"\"\n        return self._xaxis_text2_transform, 'top', 'center'\n\n    def get_yaxis_transform(self, which='grid'):\n        \"\"\"\n        Override this method to provide a transformation for the\n        y-axis grid and ticks.\n        \"\"\"\n        if which not in ['tick1', 'tick2', 'grid']:\n            raise ValueError(\n                \"'which' must be one of 'tick1', 'tick2', or 'grid'\")\n        return self._yaxis_transform\n\n    def get_yaxis_text1_transform(self, pad):\n        \"\"\"\n        Override this method to provide a transformation for the\n        y-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        \"\"\"\n        return self._yaxis_text1_transform, 'center', 'right'\n\n    def get_yaxis_text2_transform(self, pad):\n        \"\"\"\n        Override this method to provide a transformation for the\n        secondary y-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        \"\"\"\n        return self._yaxis_text2_transform, 'center', 'left'\n\n    def _gen_axes_patch(self):\n        \"\"\"\n        Override this method to define the shape that is used for the\n        background of the plot.  It should be a subclass of Patch.\n\n        In this case, it is a Circle (that may be warped by the Axes\n        transform into an ellipse).  Any data and gridlines will be\n        clipped to this shape.\n        \"\"\"\n        return Circle((0.5, 0.5), 0.5)\n\n    def _gen_axes_spines(self):\n        return {'geo': mspines.Spine.circular_spine(self, (0.5, 0.5), 0.5)}\n\n    def set_yscale(self, *args, **kwargs):\n        if args[0] != 'linear':\n            raise NotImplementedError\n\n    # Prevent the user from applying scales to one or both of the\n    # axes.  In this particular case, scaling the axes wouldn't make\n    # sense, so we don't allow it.\n    set_xscale = set_yscale\n\n    # Prevent the user from changing the axes limits.  In our case, we\n    # want to display the whole sphere all the time, so we override\n    # set_xlim and set_ylim to ignore any input.  This also applies to\n    # interactive panning and zooming in the GUI interfaces.\n    def set_xlim(self, *args, **kwargs):\n        raise TypeError(\"Changing axes limits of a geographic projection is \"\n                        \"not supported.  Please consider using Cartopy.\")\n\n    set_ylim = set_xlim\n\n    def format_coord(self, lon, lat):\n        \"\"\"\n        Override this method to change how the values are displayed in\n        the status bar.\n\n        In this case, we want them to be displayed in degrees N/S/E/W.\n        \"\"\"\n        lon, lat = np.rad2deg([lon, lat])\n        ns = 'N' if lat >= 0.0 else 'S'\n        ew = 'E' if lon >= 0.0 else 'W'\n        return ('%f\\N{DEGREE SIGN}%s, %f\\N{DEGREE SIGN}%s'\n                % (abs(lat), ns, abs(lon), ew))\n\n    def set_longitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each longitude grid.\n\n        This is an example method that is specific to this projection\n        class -- it provides a more convenient interface to set the\n        ticking than set_xticks would.\n        \"\"\"\n        # Skip -180 and 180, which are the fixed limits.\n        grid = np.arange(-180 + degrees, 180, degrees)\n        self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_latitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each longitude grid.\n\n        This is an example method that is specific to this projection\n        class -- it provides a more convenient interface than\n        set_yticks would.\n        \"\"\"\n        # Skip -90 and 90, which are the fixed limits.\n        grid = np.arange(-90 + degrees, 90, degrees)\n        self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_longitude_grid_ends(self, degrees):\n        \"\"\"\n        Set the latitude(s) at which to stop drawing the longitude grids.\n\n        Often, in geographic projections, you wouldn't want to draw\n        longitude gridlines near the poles.  This allows the user to\n        specify the degree at which to stop drawing longitude grids.\n\n        This is an example method that is specific to this projection\n        class -- it provides an interface to something that has no\n        analogy in the base Axes class.\n        \"\"\"\n        self._longitude_cap = np.deg2rad(degrees)\n        self._xaxis_pretransform \\\n            .clear() \\\n            .scale(1.0, self._longitude_cap * 2.0) \\\n            .translate(0.0, -self._longitude_cap)\n\n    def get_data_ratio(self):\n        \"\"\"\n        Return the aspect ratio of the data itself.\n\n        This method should be overridden by any Axes that have a\n        fixed data ratio.\n        \"\"\"\n        return 1.0\n\n    # Interactive panning and zooming is not supported with this projection,\n    # so we override all of the following methods to disable it.\n    def can_zoom(self):\n        \"\"\"\n        Return whether this Axes supports the zoom box button functionality.\n\n        This Axes object does not support interactive zoom box.\n        \"\"\"\n        return False\n\n    def can_pan(self):\n        \"\"\"\n        Return whether this Axes supports the pan/zoom button functionality.\n\n        This Axes object does not support interactive pan/zoom.\n        \"\"\"\n        return False\n\n    def start_pan(self, x, y, button):\n        pass\n\n    def end_pan(self):\n        pass\n\n    def drag_pan(self, button, key, x, y):\n        pass\n\n\nclass HammerAxes(GeoAxes):\n    \"\"\"\n    A custom class for the Aitoff-Hammer projection, an equal-area map\n    projection.\n\n    https://en.wikipedia.org/wiki/Hammer_projection\n    \"\"\"\n\n    # The projection must specify a name. This will be used by the\n    # user to select the projection,\n    # i.e. ``subplot(projection='custom_hammer')``.\n    name = 'custom_hammer'\n\n    class HammerTransform(Transform):\n        \"\"\"The base Hammer transform.\"\"\"\n        input_dims = output_dims = 2\n\n        def __init__(self, resolution):\n            \"\"\"\n            Create a new Hammer transform.  Resolution is the number of steps\n            to interpolate between each input line segment to approximate its\n            path in curved Hammer space.\n            \"\"\"\n            Transform.__init__(self)\n            self._resolution = resolution\n\n        def transform_non_affine(self, ll):\n            longitude, latitude = ll.T\n\n            # Pre-compute some values\n            half_long = longitude / 2\n            cos_latitude = np.cos(latitude)\n            sqrt2 = np.sqrt(2)\n\n            alpha = np.sqrt(1 + cos_latitude * np.cos(half_long))\n            x = (2 * sqrt2) * (cos_latitude * np.sin(half_long)) / alpha\n            y = (sqrt2 * np.sin(latitude)) / alpha\n            return np.column_stack([x, y])\n\n        def transform_path_non_affine(self, path):\n            # vertices = path.vertices\n            ipath = path.interpolated(self._resolution)\n            return Path(self.transform(ipath.vertices), ipath.codes)\n\n        def inverted(self):\n            return HammerAxes.InvertedHammerTransform(self._resolution)\n\n    class InvertedHammerTransform(Transform):\n        input_dims = output_dims = 2\n\n        def __init__(self, resolution):\n            Transform.__init__(self)\n            self._resolution = resolution\n\n        def transform_non_affine(self, xy):\n            x, y = xy.T\n            z = np.sqrt(1 - (x / 4) ** 2 - (y / 2) ** 2)\n            longitude = 2 * np.arctan((z * x) / (2 * (2 * z ** 2 - 1)))\n            latitude = np.arcsin(y*z)\n            return np.column_stack([longitude, latitude])\n\n        def inverted(self):\n            return HammerAxes.HammerTransform(self._resolution)\n\n    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        super().__init__(*args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.clear()\n\n    def _get_core_transform(self, resolution):\n        return self.HammerTransform(resolution)\n\n\n# Now register the projection with Matplotlib so the user can select it.\nregister_projection(HammerAxes)\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    # Now make a simple example using the custom projection.\n    fig, ax = plt.subplots(subplot_kw={'projection': 'custom_hammer'})\n    ax.plot([-1, 1, 1], [-1, -1, 1], \"o-\")\n    ax.grid()\n\n    plt.show()\n"
    },
    {
      "filename": "customize_rc.py",
      "title": "Customize Rc",
      "code": "\"\"\"\n============\nCustomize Rc\n============\n\nI'm not trying to make a good-looking figure here, but just to show\nsome examples of customizing `.rcParams` on the fly.\n\nIf you like to work interactively, and need to create different sets\nof defaults for figures (e.g., one set of defaults for publication, one\nset for interactive exploration), you may want to define some\nfunctions in a custom module that set the defaults, e.g.,::\n\n    def set_pub():\n        rcParams.update({\n            \"font.weight\": \"bold\",  # bold fonts\n            \"tick.labelsize\": 15,   # large tick labels\n            \"lines.linewidth\": 1,   # thick lines\n            \"lines.color\": \"k\",     # black lines\n            \"grid.color\": \"0.5\",    # gray gridlines\n            \"grid.linestyle\": \"-\",  # solid gridlines\n            \"grid.linewidth\": 0.5,  # thin gridlines\n            \"savefig.dpi\": 300,     # higher resolution output.\n        })\n\nThen as you are working interactively, you just need to do::\n\n    >>> set_pub()\n    >>> plot([1, 2, 3])\n    >>> savefig('myfig')\n    >>> rcdefaults()  # restore the defaults\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nplt.subplot(311)\nplt.plot([1, 2, 3])\n\n# the axes attributes need to be set before the call to subplot\nplt.rcParams.update({\n    \"font.weight\": \"bold\",\n    \"xtick.major.size\": 5,\n    \"xtick.major.pad\": 7,\n    \"xtick.labelsize\": 15,\n    \"grid.color\": \"0.5\",\n    \"grid.linestyle\": \"-\",\n    \"grid.linewidth\": 5,\n    \"lines.linewidth\": 2,\n    \"lines.color\": \"g\",\n})\nplt.subplot(312)\nplt.plot([1, 2, 3])\nplt.grid(True)\n\nplt.rcdefaults()\nplt.subplot(313)\nplt.plot([1, 2, 3])\nplt.grid(True)\nplt.show()\n"
    },
    {
      "filename": "demo_agg_filter.py",
      "title": "Demo Agg Filter",
      "code": "\"\"\"\n==========\nAGG filter\n==========\n\nMost pixel-based backends in Matplotlib use `Anti-Grain Geometry (AGG)`_ for\nrendering. You can modify the rendering of Artists by applying a filter via\n`.Artist.set_agg_filter`.\n\n.. _Anti-Grain Geometry (AGG): http://agg.sourceforge.net/antigrain.com\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.artist import Artist\nimport matplotlib.cm as cm\nfrom matplotlib.colors import LightSource\nimport matplotlib.transforms as mtransforms\n\n\ndef smooth1d(x, window_len):\n    # copied from https://scipy-cookbook.readthedocs.io/items/SignalSmooth.html\n    s = np.r_[2*x[0] - x[window_len:1:-1], x, 2*x[-1] - x[-1:-window_len:-1]]\n    w = np.hanning(window_len)\n    y = np.convolve(w/w.sum(), s, mode='same')\n    return y[window_len-1:-window_len+1]\n\n\ndef smooth2d(A, sigma=3):\n    window_len = max(int(sigma), 3) * 2 + 1\n    A = np.apply_along_axis(smooth1d, 0, A, window_len)\n    A = np.apply_along_axis(smooth1d, 1, A, window_len)\n    return A\n\n\nclass BaseFilter:\n\n    def get_pad(self, dpi):\n        return 0\n\n    def process_image(self, padded_src, dpi):\n        raise NotImplementedError(\"Should be overridden by subclasses\")\n\n    def __call__(self, im, dpi):\n        pad = self.get_pad(dpi)\n        padded_src = np.pad(im, [(pad, pad), (pad, pad), (0, 0)], \"constant\")\n        tgt_image = self.process_image(padded_src, dpi)\n        return tgt_image, -pad, -pad\n\n\nclass OffsetFilter(BaseFilter):\n\n    def __init__(self, offsets=(0, 0)):\n        self.offsets = offsets\n\n    def get_pad(self, dpi):\n        return int(max(self.offsets) / 72 * dpi)\n\n    def process_image(self, padded_src, dpi):\n        ox, oy = self.offsets\n        a1 = np.roll(padded_src, int(ox / 72 * dpi), axis=1)\n        a2 = np.roll(a1, -int(oy / 72 * dpi), axis=0)\n        return a2\n\n\nclass GaussianFilter(BaseFilter):\n    \"\"\"Simple Gaussian filter.\"\"\"\n\n    def __init__(self, sigma, alpha=0.5, color=(0, 0, 0)):\n        self.sigma = sigma\n        self.alpha = alpha\n        self.color = color\n\n    def get_pad(self, dpi):\n        return int(self.sigma*3 / 72 * dpi)\n\n    def process_image(self, padded_src, dpi):\n        tgt_image = np.empty_like(padded_src)\n        tgt_image[:, :, :3] = self.color\n        tgt_image[:, :, 3] = smooth2d(padded_src[:, :, 3] * self.alpha,\n                                      self.sigma / 72 * dpi)\n        return tgt_image\n\n\nclass DropShadowFilter(BaseFilter):\n\n    def __init__(self, sigma, alpha=0.3, color=(0, 0, 0), offsets=(0, 0)):\n        self.gauss_filter = GaussianFilter(sigma, alpha, color)\n        self.offset_filter = OffsetFilter(offsets)\n\n    def get_pad(self, dpi):\n        return max(self.gauss_filter.get_pad(dpi),\n                   self.offset_filter.get_pad(dpi))\n\n    def process_image(self, padded_src, dpi):\n        t1 = self.gauss_filter.process_image(padded_src, dpi)\n        t2 = self.offset_filter.process_image(t1, dpi)\n        return t2\n\n\nclass LightFilter(BaseFilter):\n    \"\"\"Apply LightSource filter\"\"\"\n\n    def __init__(self, sigma, fraction=1):\n        \"\"\"\n        Parameters\n        ----------\n        sigma : float\n            sigma for gaussian filter\n        fraction: number, default: 1\n            Increases or decreases the contrast of the hillshade.\n            See `matplotlib.colors.LightSource`\n\n        \"\"\"\n        self.gauss_filter = GaussianFilter(sigma, alpha=1)\n        self.light_source = LightSource()\n        self.fraction = fraction\n\n    def get_pad(self, dpi):\n        return self.gauss_filter.get_pad(dpi)\n\n    def process_image(self, padded_src, dpi):\n        t1 = self.gauss_filter.process_image(padded_src, dpi)\n        elevation = t1[:, :, 3]\n        rgb = padded_src[:, :, :3]\n        alpha = padded_src[:, :, 3:]\n        rgb2 = self.light_source.shade_rgb(rgb, elevation,\n                                           fraction=self.fraction,\n                                           blend_mode=\"overlay\")\n        return np.concatenate([rgb2, alpha], -1)\n\n\nclass GrowFilter(BaseFilter):\n    \"\"\"Enlarge the area.\"\"\"\n\n    def __init__(self, pixels, color=(1, 1, 1)):\n        self.pixels = pixels\n        self.color = color\n\n    def __call__(self, im, dpi):\n        alpha = np.pad(im[..., 3], self.pixels, \"constant\")\n        alpha2 = np.clip(smooth2d(alpha, self.pixels / 72 * dpi) * 5, 0, 1)\n        new_im = np.empty((*alpha2.shape, 4))\n        new_im[:, :, :3] = self.color\n        new_im[:, :, 3] = alpha2\n        offsetx, offsety = -self.pixels, -self.pixels\n        return new_im, offsetx, offsety\n\n\nclass FilteredArtistList(Artist):\n    \"\"\"A simple container to filter multiple artists at once.\"\"\"\n\n    def __init__(self, artist_list, filter):\n        super().__init__()\n        self._artist_list = artist_list\n        self._filter = filter\n\n    def draw(self, renderer):\n        renderer.start_rasterizing()\n        renderer.start_filter()\n        for a in self._artist_list:\n            a.draw(renderer)\n        renderer.stop_filter(self._filter)\n        renderer.stop_rasterizing()\n\n\ndef filtered_text(ax):\n    # mostly copied from contour_demo.py\n\n    # prepare image\n    delta = 0.025\n    x = np.arange(-3.0, 3.0, delta)\n    y = np.arange(-2.0, 2.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2) * 2\n\n    # draw\n    ax.imshow(Z, interpolation='bilinear', origin='lower',\n              cmap=cm.gray, extent=(-3, 3, -2, 2), aspect='auto')\n    levels = np.arange(-1.2, 1.6, 0.2)\n    CS = ax.contour(Z, levels,\n                    origin='lower',\n                    linewidths=2,\n                    extent=(-3, 3, -2, 2))\n\n    # contour label\n    cl = ax.clabel(CS, levels[1::2],  # label every second level\n                   fmt='%1.1f',\n                   fontsize=11)\n\n    # change clabel color to black\n    from matplotlib.patheffects import Normal\n    for t in cl:\n        t.set_color(\"k\")\n        # to force TextPath (i.e., same font in all backends)\n        t.set_path_effects([Normal()])\n\n    # Add white glows to improve visibility of labels.\n    white_glows = FilteredArtistList(cl, GrowFilter(3))\n    ax.add_artist(white_glows)\n    white_glows.set_zorder(cl[0].get_zorder() - 0.1)\n\n    ax.xaxis.set_visible(False)\n    ax.yaxis.set_visible(False)\n\n\ndef drop_shadow_line(ax):\n    # copied from examples/misc/svg_filter_line.py\n\n    # draw lines\n    l1, = ax.plot([0.1, 0.5, 0.9], [0.1, 0.9, 0.5], \"bo-\")\n    l2, = ax.plot([0.1, 0.5, 0.9], [0.5, 0.2, 0.7], \"ro-\")\n\n    gauss = DropShadowFilter(4)\n\n    for l in [l1, l2]:\n\n        # draw shadows with same lines with slight offset.\n        xx = l.get_xdata()\n        yy = l.get_ydata()\n        shadow, = ax.plot(xx, yy)\n        shadow.update_from(l)\n\n        # offset transform\n        transform = mtransforms.offset_copy(l.get_transform(), ax.figure,\n                                            x=4.0, y=-6.0, units='points')\n        shadow.set_transform(transform)\n\n        # adjust zorder of the shadow lines so that it is drawn below the\n        # original lines\n        shadow.set_zorder(l.get_zorder() - 0.5)\n        shadow.set_agg_filter(gauss)\n        shadow.set_rasterized(True)  # to support mixed-mode renderers\n\n    ax.set_xlim(0., 1.)\n    ax.set_ylim(0., 1.)\n\n    ax.xaxis.set_visible(False)\n    ax.yaxis.set_visible(False)\n\n\ndef drop_shadow_patches(ax):\n    # Copied from barchart_demo.py\n    N = 5\n    group1_means = [20, 35, 30, 35, 27]\n\n    ind = np.arange(N)  # the x locations for the groups\n    width = 0.35  # the width of the bars\n\n    rects1 = ax.bar(ind, group1_means, width, color='r', ec=\"w\", lw=2)\n\n    group2_means = [25, 32, 34, 20, 25]\n    rects2 = ax.bar(ind + width + 0.1, group2_means, width,\n                    color='y', ec=\"w\", lw=2)\n\n    drop = DropShadowFilter(5, offsets=(1, 1))\n    shadow = FilteredArtistList(rects1 + rects2, drop)\n    ax.add_artist(shadow)\n    shadow.set_zorder(rects1[0].get_zorder() - 0.1)\n\n    ax.set_ylim(0, 40)\n\n    ax.xaxis.set_visible(False)\n    ax.yaxis.set_visible(False)\n\n\ndef light_filter_pie(ax):\n    fracs = [15, 30, 45, 10]\n    explode = (0.1, 0.2, 0.1, 0.1)\n    pies = ax.pie(fracs, explode=explode)\n\n    light_filter = LightFilter(9)\n    for p in pies[0]:\n        p.set_agg_filter(light_filter)\n        p.set_rasterized(True)  # to support mixed-mode renderers\n        p.set(ec=\"none\",\n              lw=2)\n\n    gauss = DropShadowFilter(9, offsets=(3, -4), alpha=0.7)\n    shadow = FilteredArtistList(pies[0], gauss)\n    ax.add_artist(shadow)\n    shadow.set_zorder(pies[0][0].get_zorder() - 0.1)\n\n\nif __name__ == \"__main__\":\n\n    fix, axs = plt.subplots(2, 2)\n\n    filtered_text(axs[0, 0])\n    drop_shadow_line(axs[0, 1])\n    drop_shadow_patches(axs[1, 0])\n    light_filter_pie(axs[1, 1])\n    axs[1, 1].set_frame_on(True)\n\n    plt.show()\n"
    },
    {
      "filename": "demo_ribbon_box.py",
      "title": "Demo Ribbon Box",
      "code": "\"\"\"\n==========\nRibbon box\n==========\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom matplotlib import colors as mcolors\nfrom matplotlib.image import AxesImage\nfrom matplotlib.transforms import Bbox, BboxTransformTo, TransformedBbox\n\n\nclass RibbonBox:\n\n    original_image = plt.imread(\n        cbook.get_sample_data(\"Minduka_Present_Blue_Pack.png\"))\n    cut_location = 70\n    b_and_h = original_image[:, :, 2:3]\n    color = original_image[:, :, 2:3] - original_image[:, :, 0:1]\n    alpha = original_image[:, :, 3:4]\n    nx = original_image.shape[1]\n\n    def __init__(self, color):\n        rgb = mcolors.to_rgb(color)\n        self.im = np.dstack(\n            [self.b_and_h - self.color * (1 - np.array(rgb)), self.alpha])\n\n    def get_stretched_image(self, stretch_factor):\n        stretch_factor = max(stretch_factor, 1)\n        ny, nx, nch = self.im.shape\n        ny2 = int(ny*stretch_factor)\n        return np.vstack(\n            [self.im[:self.cut_location],\n             np.broadcast_to(\n                 self.im[self.cut_location], (ny2 - ny, nx, nch)),\n             self.im[self.cut_location:]])\n\n\nclass RibbonBoxImage(AxesImage):\n    zorder = 1\n\n    def __init__(self, ax, bbox, color, *, extent=(0, 1, 0, 1), **kwargs):\n        super().__init__(ax, extent=extent, **kwargs)\n        self._bbox = bbox\n        self._ribbonbox = RibbonBox(color)\n        self.set_transform(BboxTransformTo(bbox))\n\n    def draw(self, renderer):\n        stretch_factor = self._bbox.height / self._bbox.width\n\n        ny = int(stretch_factor*self._ribbonbox.nx)\n        if self.get_array() is None or self.get_array().shape[0] != ny:\n            arr = self._ribbonbox.get_stretched_image(stretch_factor)\n            self.set_array(arr)\n\n        super().draw(renderer)\n\n\ndef main():\n    fig, ax = plt.subplots()\n\n    years = np.arange(2004, 2009)\n    heights = [7900, 8100, 7900, 6900, 2800]\n    box_colors = [\n        (0.8, 0.2, 0.2),\n        (0.2, 0.8, 0.2),\n        (0.2, 0.2, 0.8),\n        (0.7, 0.5, 0.8),\n        (0.3, 0.8, 0.7),\n    ]\n\n    for year, h, bc in zip(years, heights, box_colors):\n        bbox0 = Bbox.from_extents(year - 0.4, 0., year + 0.4, h)\n        bbox = TransformedBbox(bbox0, ax.transData)\n        ax.add_artist(RibbonBoxImage(ax, bbox, bc, interpolation=\"bicubic\"))\n        ax.annotate(str(h), (year, h), va=\"bottom\", ha=\"center\")\n\n    ax.set_xlim(years[0] - 0.5, years[-1] + 0.5)\n    ax.set_ylim(0, 10000)\n\n    background_gradient = np.zeros((2, 2, 4))\n    background_gradient[:, :, :3] = [1, 1, 0]\n    background_gradient[:, :, 3] = [[0.1, 0.3], [0.3, 0.5]]  # alpha channel\n    ax.imshow(background_gradient, interpolation=\"bicubic\", zorder=0.1,\n              extent=(0, 1, 0, 1), transform=ax.transAxes)\n\n    plt.show()\n\n\nmain()\n"
    },
    {
      "filename": "fig_x.py",
      "title": "Fig X",
      "code": "\"\"\"\n==============================\nAdd lines directly to a figure\n==============================\n\nYou can add artists such as a `.Line2D` directly to a figure. This is\ntypically useful for visual structuring.\n\n.. redirect-from:: /gallery/pyplots/fig_x\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.lines as lines\n\nfig, axs = plt.subplots(2, 2, gridspec_kw={'hspace': 0.4, 'wspace': 0.4})\nfig.add_artist(lines.Line2D([0, 1], [0.47, 0.47], linewidth=3))\nfig.add_artist(lines.Line2D([0.5, 0.5], [1, 0], linewidth=3))\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.figure`\n#    - `matplotlib.lines`\n#    - `matplotlib.lines.Line2D`\n"
    },
    {
      "filename": "fill_spiral.py",
      "title": "Fill Spiral",
      "code": "\"\"\"\n===========\nFill spiral\n===========\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ntheta = np.arange(0, 8*np.pi, 0.1)\na = 1\nb = .2\n\nfor dt in np.arange(0, 2*np.pi, np.pi/2.0):\n\n    x = a*np.cos(theta + dt)*np.exp(b*theta)\n    y = a*np.sin(theta + dt)*np.exp(b*theta)\n\n    dt = dt + np.pi/4.0\n\n    x2 = a*np.cos(theta + dt)*np.exp(b*theta)\n    y2 = a*np.sin(theta + dt)*np.exp(b*theta)\n\n    xf = np.concatenate((x, x2[::-1]))\n    yf = np.concatenate((y, y2[::-1]))\n\n    p1 = plt.fill(xf, yf)\n\nplt.show()\n"
    },
    {
      "filename": "findobj_demo.py",
      "title": "Findobj Demo",
      "code": "\"\"\"\n============\nFindobj Demo\n============\n\nRecursively find all objects that match some criteria\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.text as text\n\na = np.arange(0, 3, .02)\nb = np.arange(0, 3, .02)\nc = np.exp(a)\nd = c[::-1]\n\nfig, ax = plt.subplots()\nplt.plot(a, c, 'k--', a, d, 'k:', a, c + d, 'k')\nplt.legend(('Model length', 'Data length', 'Total message length'),\n           loc='upper center', shadow=True)\nplt.ylim([-1, 20])\nplt.grid(False)\nplt.xlabel('Model complexity --->')\nplt.ylabel('Message length --->')\nplt.title('Minimum Message Length')\n\n\n# match on arbitrary function\ndef myfunc(x):\n    return hasattr(x, 'set_color') and not hasattr(x, 'set_facecolor')\n\n\nfor o in fig.findobj(myfunc):\n    o.set_color('blue')\n\n# match on class instances\nfor o in fig.findobj(text.Text):\n    o.set_fontstyle('italic')\n\n\nplt.show()\n"
    },
    {
      "filename": "font_indexing.py",
      "title": "Font Indexing",
      "code": "\"\"\"\n=============\nFont indexing\n=============\n\nThis example shows how the font tables relate to one another.\n\"\"\"\n\nimport os\n\nimport matplotlib\nfrom matplotlib.ft2font import FT2Font, Kerning\n\nfont = FT2Font(\n    os.path.join(matplotlib.get_data_path(), 'fonts/ttf/DejaVuSans.ttf'))\nfont.set_charmap(0)\n\ncodes = font.get_charmap().items()\n\n# make a charname to charcode and glyphind dictionary\ncoded = {}\nglyphd = {}\nfor ccode, glyphind in codes:\n    name = font.get_glyph_name(glyphind)\n    coded[name] = ccode\n    glyphd[name] = glyphind\n    # print(glyphind, ccode, hex(int(ccode)), name)\n\ncode = coded['A']\nglyph = font.load_char(code)\nprint(glyph.bbox)\nprint(glyphd['A'], glyphd['V'], coded['A'], coded['V'])\nprint('AV', font.get_kerning(glyphd['A'], glyphd['V'], Kerning.DEFAULT))\nprint('AV', font.get_kerning(glyphd['A'], glyphd['V'], Kerning.UNFITTED))\nprint('AV', font.get_kerning(glyphd['A'], glyphd['V'], Kerning.UNSCALED))\nprint('AT', font.get_kerning(glyphd['A'], glyphd['T'], Kerning.UNSCALED))\n"
    },
    {
      "filename": "ftface_props.py",
      "title": "Ftface Props",
      "code": "\"\"\"\n===============\nFont properties\n===============\n\nThis example lists the attributes of an `.FT2Font` object, which describe\nglobal font properties.  For individual character metrics, use the `.Glyph`\nobject, as returned by `.load_char`.\n\"\"\"\n\nimport os\n\nimport matplotlib\nimport matplotlib.ft2font as ft\n\nfont = ft.FT2Font(\n    # Use a font shipped with Matplotlib.\n    os.path.join(matplotlib.get_data_path(),\n                 'fonts/ttf/DejaVuSans-Oblique.ttf'))\n\nprint('Num instances:  ', font.num_named_instances)  # number of named instances in file\nprint('Num faces:      ', font.num_faces)            # number of faces in file\nprint('Num glyphs:     ', font.num_glyphs)           # number of glyphs in the face\nprint('Family name:    ', font.family_name)          # face family name\nprint('Style name:     ', font.style_name)           # face style name\nprint('PS name:        ', font.postscript_name)      # the postscript name\nprint('Num fixed:      ', font.num_fixed_sizes)      # number of embedded bitmaps\n\n# the following are only available if face.scalable\nif font.scalable:\n    # the face global bounding box (xmin, ymin, xmax, ymax)\n    print('Bbox:               ', font.bbox)\n    # number of font units covered by the EM\n    print('EM:                 ', font.units_per_EM)\n    # the ascender in 26.6 units\n    print('Ascender:           ', font.ascender)\n    # the descender in 26.6 units\n    print('Descender:          ', font.descender)\n    # the height in 26.6 units\n    print('Height:             ', font.height)\n    # maximum horizontal cursor advance\n    print('Max adv width:      ', font.max_advance_width)\n    # same for vertical layout\n    print('Max adv height:     ', font.max_advance_height)\n    # vertical position of the underline bar\n    print('Underline pos:      ', font.underline_position)\n    # vertical thickness of the underline\n    print('Underline thickness:', font.underline_thickness)\n\nfor flag in ft.StyleFlags:\n    name = flag.name.replace('_', ' ').title() + ':'\n    print(f\"{name:17}\", flag in font.style_flags)\n\nfor flag in ft.FaceFlags:\n    name = flag.name.replace('_', ' ').title() + ':'\n    print(f\"{name:17}\", flag in font.face_flags)\n"
    },
    {
      "filename": "histogram_path.py",
      "title": "Histogram Path",
      "code": "\"\"\"\n========================================================\nBuilding histograms using Rectangles and PolyCollections\n========================================================\n\nUsing a path patch to draw rectangles.\n\nThe technique of using lots of `.Rectangle` instances, or the faster method of\nusing `.PolyCollection`, were implemented before we had proper paths with\nmoveto, lineto, closepoly, etc. in Matplotlib.  Now that we have them, we can\ndraw collections of regularly shaped objects with homogeneous properties more\nefficiently with a PathCollection. This example makes a histogram -- it's more\nwork to set up the vertex arrays at the outset, but it should be much faster\nfor large numbers of objects.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as patches\nimport matplotlib.path as path\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility\n\n# histogram our data with numpy\ndata = np.random.randn(1000)\nn, bins = np.histogram(data, 50)\n\n# get the corners of the rectangles for the histogram\nleft = bins[:-1]\nright = bins[1:]\nbottom = np.zeros(len(left))\ntop = bottom + n\n\n# we need a (numrects x numsides x 2) numpy array for the path helper\n# function to build a compound path\nXY = np.array([[left, left, right, right], [bottom, top, top, bottom]]).T\n\n# get the Path object\nbarpath = path.Path.make_compound_path_from_polys(XY)\n\n# make a patch out of it, don't add a margin at y=0\npatch = patches.PathPatch(barpath)\npatch.sticky_edges.y[:] = [0]\n\nfig, ax = plt.subplots()\nax.add_patch(patch)\nax.autoscale_view()\nplt.show()\n\n# %%\n# Instead of creating a three-dimensional array and using\n# `~.path.Path.make_compound_path_from_polys`, we could as well create the\n# compound path directly using vertices and codes as shown below\n\nnrects = len(left)\nnverts = nrects*(1+3+1)\nverts = np.zeros((nverts, 2))\ncodes = np.ones(nverts, int) * path.Path.LINETO\ncodes[0::5] = path.Path.MOVETO\ncodes[4::5] = path.Path.CLOSEPOLY\nverts[0::5, 0] = left\nverts[0::5, 1] = bottom\nverts[1::5, 0] = left\nverts[1::5, 1] = top\nverts[2::5, 0] = right\nverts[2::5, 1] = top\nverts[3::5, 0] = right\nverts[3::5, 1] = bottom\n\nbarpath = path.Path(verts, codes)\n\n# make a patch out of it, don't add a margin at y=0\npatch = patches.PathPatch(barpath)\npatch.sticky_edges.y[:] = [0]\n\nfig, ax = plt.subplots()\nax.add_patch(patch)\nax.autoscale_view()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.path.Path.make_compound_path_from_polys`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.collections.PathCollection`\n#\n#    This example shows an alternative to\n#\n#    - `matplotlib.collections.PolyCollection`\n#    - `matplotlib.axes.Axes.hist`\n"
    },
    {
      "filename": "hyperlinks_sgskip.py",
      "title": "Hyperlinks Sgskip",
      "code": "\"\"\"\n==========\nHyperlinks\n==========\n\nThis example demonstrates how to set a hyperlinks on various kinds of elements.\n\nThis currently only works with the SVG backend.\n\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\n\n# %%\n\nfig = plt.figure()\ns = plt.scatter([1, 2, 3], [4, 5, 6])\ns.set_urls(['https://www.bbc.com/news', 'https://www.google.com/', None])\nfig.savefig('scatter.svg')\n\n# %%\n\nfig = plt.figure()\ndelta = 0.025\nx = y = np.arange(-3.0, 3.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\nim = plt.imshow(Z, interpolation='bilinear', cmap=cm.gray,\n                origin='lower', extent=(-3, 3, -3, 3))\n\nim.set_url('https://www.google.com/')\nfig.savefig('image.svg')\n"
    },
    {
      "filename": "image_thumbnail_sgskip.py",
      "title": "Image Thumbnail Sgskip",
      "code": "\"\"\"\n===============\nImage thumbnail\n===============\n\nYou can use Matplotlib to generate thumbnails from existing images.\nMatplotlib relies on Pillow_ for reading images, and thus supports all formats\nsupported by Pillow.\n\n.. _Pillow: https://python-pillow.github.io\n\"\"\"\n\nfrom argparse import ArgumentParser\nfrom pathlib import Path\nimport sys\n\nimport matplotlib.image as image\n\nparser = ArgumentParser(\n    description=\"Build thumbnails of all images in a directory.\")\nparser.add_argument(\"imagedir\", type=Path)\nargs = parser.parse_args()\nif not args.imagedir.is_dir():\n    sys.exit(f\"Could not find input directory {args.imagedir}\")\n\noutdir = Path(\"thumbs\")\noutdir.mkdir(parents=True, exist_ok=True)\n\nfor path in args.imagedir.glob(\"*.png\"):\n    outpath = outdir / path.name\n    fig = image.thumbnail(path, outpath, scale=0.15)\n    print(f\"saved thumbnail of {path} to {outpath}\")\n"
    },
    {
      "filename": "keyword_plotting.py",
      "title": "Keyword Plotting",
      "code": "\"\"\"\n======================\nPlotting with keywords\n======================\n\nSome data structures, like dict, `structured numpy array\n<https://numpy.org/doc/stable/user/basics.rec.html#structured-arrays>`_\nor `pandas.DataFrame` provide access to labelled data via string index access\n``data[key]``.\n\nFor these data types, Matplotlib supports passing the whole datastructure via the\n``data`` keyword argument, and using the string names as plot function parameters,\nwhere you'd normally pass in your data.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots()\nax.scatter('a', 'b', c='c', s='d', data=data)\nax.set(xlabel='entry a', ylabel='entry b')\nplt.show()\n"
    },
    {
      "filename": "logos2.py",
      "title": "Logos2",
      "code": "\"\"\"\n===============\nMatplotlib logo\n===============\n\nThis example generates the current matplotlib logo.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\nimport matplotlib.font_manager\nfrom matplotlib.patches import PathPatch, Rectangle\nfrom matplotlib.text import TextPath\nimport matplotlib.transforms as mtrans\n\nMPL_BLUE = '#11557c'\n\n\ndef get_font_properties():\n    # The original font is Calibri, if that is not installed, we fall back\n    # to Carlito, which is metrically equivalent.\n    if 'Calibri' in matplotlib.font_manager.findfont('Calibri:bold'):\n        return matplotlib.font_manager.FontProperties(family='Calibri',\n                                                      weight='bold')\n    if 'Carlito' in matplotlib.font_manager.findfont('Carlito:bold'):\n        print('Original font not found. Falling back to Carlito. '\n              'The logo text will not be in the correct font.')\n        return matplotlib.font_manager.FontProperties(family='Carlito',\n                                                      weight='bold')\n    print('Original font not found. '\n          'The logo text will not be in the correct font.')\n    return None\n\n\ndef create_icon_axes(fig, ax_position, lw_bars, lw_grid, lw_border, rgrid):\n    \"\"\"\n    Create a polar Axes containing the matplotlib radar plot.\n\n    Parameters\n    ----------\n    fig : matplotlib.figure.Figure\n        The figure to draw into.\n    ax_position : (float, float, float, float)\n        The position of the created Axes in figure coordinates as\n        (x, y, width, height).\n    lw_bars : float\n        The linewidth of the bars.\n    lw_grid : float\n        The linewidth of the grid.\n    lw_border : float\n        The linewidth of the Axes border.\n    rgrid : array-like\n        Positions of the radial grid.\n\n    Returns\n    -------\n    ax : matplotlib.axes.Axes\n        The created Axes.\n    \"\"\"\n    with plt.rc_context({'axes.edgecolor': MPL_BLUE,\n                         'axes.linewidth': lw_border}):\n        ax = fig.add_axes(ax_position, projection='polar')\n        ax.set_axisbelow(True)\n\n        N = 7\n        arc = 2. * np.pi\n        theta = np.arange(0.0, arc, arc / N)\n        radii = np.array([2, 6, 8, 7, 4, 5, 8])\n        width = np.pi / 4 * np.array([0.4, 0.4, 0.6, 0.8, 0.2, 0.5, 0.3])\n        bars = ax.bar(theta, radii, width=width, bottom=0.0, align='edge',\n                      edgecolor='0.3', lw=lw_bars)\n        for r, bar in zip(radii, bars):\n            color = *cm.jet(r / 10.)[:3], 0.6  # color from jet with alpha=0.6\n            bar.set_facecolor(color)\n\n        ax.tick_params(labelbottom=False, labeltop=False,\n                       labelleft=False, labelright=False)\n\n        ax.grid(lw=lw_grid, color='0.9')\n        ax.set_rmax(9)\n        ax.set_yticks(rgrid)\n\n        # the actual visible background - extends a bit beyond the axis\n        ax.add_patch(Rectangle((0, 0), arc, 9.58,\n                               facecolor='white', zorder=0,\n                               clip_on=False, in_layout=False))\n        return ax\n\n\ndef create_text_axes(fig, height_px):\n    \"\"\"Create an Axes in *fig* that contains 'matplotlib' as Text.\"\"\"\n    ax = fig.add_axes((0, 0, 1, 1))\n    ax.set_aspect(\"equal\")\n    ax.set_axis_off()\n\n    path = TextPath((0, 0), \"matplotlib\", size=height_px * 0.8,\n                    prop=get_font_properties())\n\n    angle = 4.25  # degrees\n    trans = mtrans.Affine2D().skew_deg(angle, 0)\n\n    patch = PathPatch(path, transform=trans + ax.transData, color=MPL_BLUE,\n                      lw=0)\n    ax.add_patch(patch)\n    ax.autoscale()\n\n\ndef make_logo(height_px, lw_bars, lw_grid, lw_border, rgrid, with_text=False):\n    \"\"\"\n    Create a full figure with the Matplotlib logo.\n\n    Parameters\n    ----------\n    height_px : int\n        Height of the figure in pixel.\n    lw_bars : float\n        The linewidth of the bar border.\n    lw_grid : float\n        The linewidth of the grid.\n    lw_border : float\n        The linewidth of icon border.\n    rgrid : sequence of float\n        The radial grid positions.\n    with_text : bool\n        Whether to draw only the icon or to include 'matplotlib' as text.\n    \"\"\"\n    dpi = 100\n    height = height_px / dpi\n    figsize = (5 * height, height) if with_text else (height, height)\n    fig = plt.figure(figsize=figsize, dpi=dpi)\n    fig.patch.set_alpha(0)\n\n    if with_text:\n        create_text_axes(fig, height_px)\n    ax_pos = (0.535, 0.12, .17, 0.75) if with_text else (0.03, 0.03, .94, .94)\n    ax = create_icon_axes(fig, ax_pos, lw_bars, lw_grid, lw_border, rgrid)\n\n    return fig, ax\n\n# %%\n# A large logo:\n\nmake_logo(height_px=110, lw_bars=0.7, lw_grid=0.5, lw_border=1,\n          rgrid=[1, 3, 5, 7])\n\n# %%\n# A small 32px logo:\n\nmake_logo(height_px=32, lw_bars=0.3, lw_grid=0.3, lw_border=0.3, rgrid=[5])\n\n# %%\n# A large logo including text, as used on the matplotlib website.\n\nmake_logo(height_px=110, lw_bars=0.7, lw_grid=0.5, lw_border=1,\n          rgrid=[1, 3, 5, 7], with_text=True)\nplt.show()\n"
    },
    {
      "filename": "multipage_pdf.py",
      "title": "Multipage Pdf",
      "code": "\"\"\"\n=============\nMultipage PDF\n=============\n\nThis is a demo of creating a pdf file with several pages,\nas well as adding metadata and annotations to pdf files.\n\nIf you want to use a multipage pdf file using LaTeX, you need\nto use ``from matplotlib.backends.backend_pgf import PdfPages``.\nThis version however does not support `.attach_note`.\n\"\"\"\n\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backends.backend_pdf import PdfPages\n\n# Create the PdfPages object to which we will save the pages:\n# The with statement makes sure that the PdfPages object is closed properly at\n# the end of the block, even if an Exception occurs.\nwith PdfPages('multipage_pdf.pdf') as pdf:\n    plt.figure(figsize=(3, 3))\n    plt.plot(range(7), [3, 1, 4, 1, 5, 9, 2], 'r-o')\n    plt.title('Page One')\n    pdf.savefig()  # saves the current figure into a pdf page\n    plt.close()\n\n    # if LaTeX is not installed or error caught, change to `False`\n    plt.rcParams['text.usetex'] = True\n    plt.figure(figsize=(8, 6))\n    x = np.arange(0, 5, 0.1)\n    plt.plot(x, np.sin(x), 'b-')\n    plt.title('Page Two')\n    pdf.attach_note(\"plot of sin(x)\")  # attach metadata (as pdf note) to page\n    pdf.savefig()\n    plt.close()\n\n    plt.rcParams['text.usetex'] = False\n    fig = plt.figure(figsize=(4, 5))\n    plt.plot(x, x ** 2, 'ko')\n    plt.title('Page Three')\n    pdf.savefig(fig)  # or you can pass a Figure object to pdf.savefig\n    plt.close()\n\n    # We can also set the file's metadata via the PdfPages object:\n    d = pdf.infodict()\n    d['Title'] = 'Multipage PDF Example'\n    d['Author'] = 'Jouni K. Sepp\\xe4nen'\n    d['Subject'] = 'How to create a multipage pdf file and set its metadata'\n    d['Keywords'] = 'PdfPages multipage keywords author title subject'\n    d['CreationDate'] = datetime.datetime(2009, 11, 13)\n    d['ModDate'] = datetime.datetime.today()\n"
    },
    {
      "filename": "multiprocess_sgskip.py",
      "title": "Multiprocess Sgskip",
      "code": "\"\"\"\n===============\nMultiprocessing\n===============\n\nDemo of using multiprocessing for generating data in one process and\nplotting in another.\n\nWritten by Robert Cimrman\n\"\"\"\n\nimport multiprocessing as mp\nimport time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# %%\n#\n# Processing Class\n# ================\n#\n# This class plots data it receives from a pipe.\n#\n\n\nclass ProcessPlotter:\n    def __init__(self):\n        self.x = []\n        self.y = []\n\n    def terminate(self):\n        plt.close('all')\n\n    def call_back(self):\n        while self.pipe.poll():\n            command = self.pipe.recv()\n            if command is None:\n                self.terminate()\n                return False\n            else:\n                self.x.append(command[0])\n                self.y.append(command[1])\n                self.ax.plot(self.x, self.y, 'ro')\n        self.fig.canvas.draw()\n        return True\n\n    def __call__(self, pipe):\n        print('starting plotter...')\n\n        self.pipe = pipe\n        self.fig, self.ax = plt.subplots()\n        timer = self.fig.canvas.new_timer(interval=1000)\n        timer.add_callback(self.call_back)\n        timer.start()\n\n        print('...done')\n        plt.show()\n\n# %%\n#\n# Plotting class\n# ==============\n#\n# This class uses multiprocessing to spawn a process to run code from the\n# class above. When initialized, it creates a pipe and an instance of\n# ``ProcessPlotter`` which will be run in a separate process.\n#\n# When run from the command line, the parent process sends data to the spawned\n# process which is then plotted via the callback function specified in\n# ``ProcessPlotter:__call__``.\n#\n\n\nclass NBPlot:\n    def __init__(self):\n        self.plot_pipe, plotter_pipe = mp.Pipe()\n        self.plotter = ProcessPlotter()\n        self.plot_process = mp.Process(\n            target=self.plotter, args=(plotter_pipe,), daemon=True)\n        self.plot_process.start()\n\n    def plot(self, finished=False):\n        send = self.plot_pipe.send\n        if finished:\n            send(None)\n        else:\n            data = np.random.random(2)\n            send(data)\n\n\ndef main():\n    pl = NBPlot()\n    for _ in range(10):\n        pl.plot()\n        time.sleep(0.5)\n    pl.plot(finished=True)\n\n\nif __name__ == '__main__':\n    if plt.get_backend() == \"MacOSX\":\n        mp.set_start_method(\"forkserver\")\n    main()\n"
    },
    {
      "filename": "packed_bubbles.py",
      "title": "Packed Bubbles",
      "code": "\"\"\"\n===================\nPacked-bubble chart\n===================\n\nCreate a packed-bubble chart to represent scalar data.\nThe presented algorithm tries to move all bubbles as close to the center of\nmass as possible while avoiding some collisions by moving around colliding\nobjects. In this example we plot the market share of different desktop\nbrowsers.\n(source: https://gs.statcounter.com/browser-market-share/desktop/worldwidev)\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nbrowser_market_share = {\n    'browsers': ['firefox', 'chrome', 'safari', 'edge', 'ie', 'opera'],\n    'market_share': [8.61, 69.55, 8.36, 4.12, 2.76, 2.43],\n    'color': ['#5A69AF', '#579E65', '#F9C784', '#FC944A', '#F24C00', '#00B825']\n}\n\n\nclass BubbleChart:\n    def __init__(self, area, bubble_spacing=0):\n        \"\"\"\n        Setup for bubble collapse.\n\n        Parameters\n        ----------\n        area : array-like\n            Area of the bubbles.\n        bubble_spacing : float, default: 0\n            Minimal spacing between bubbles after collapsing.\n\n        Notes\n        -----\n        If \"area\" is sorted, the results might look weird.\n        \"\"\"\n        area = np.asarray(area)\n        r = np.sqrt(area / np.pi)\n\n        self.bubble_spacing = bubble_spacing\n        self.bubbles = np.ones((len(area), 4))\n        self.bubbles[:, 2] = r\n        self.bubbles[:, 3] = area\n        self.maxstep = 2 * self.bubbles[:, 2].max() + self.bubble_spacing\n        self.step_dist = self.maxstep / 2\n\n        # calculate initial grid layout for bubbles\n        length = np.ceil(np.sqrt(len(self.bubbles)))\n        grid = np.arange(length) * self.maxstep\n        gx, gy = np.meshgrid(grid, grid)\n        self.bubbles[:, 0] = gx.flatten()[:len(self.bubbles)]\n        self.bubbles[:, 1] = gy.flatten()[:len(self.bubbles)]\n\n        self.com = self.center_of_mass()\n\n    def center_of_mass(self):\n        return np.average(\n            self.bubbles[:, :2], axis=0, weights=self.bubbles[:, 3]\n        )\n\n    def center_distance(self, bubble, bubbles):\n        return np.hypot(bubble[0] - bubbles[:, 0],\n                        bubble[1] - bubbles[:, 1])\n\n    def outline_distance(self, bubble, bubbles):\n        center_distance = self.center_distance(bubble, bubbles)\n        return center_distance - bubble[2] - \\\n            bubbles[:, 2] - self.bubble_spacing\n\n    def check_collisions(self, bubble, bubbles):\n        distance = self.outline_distance(bubble, bubbles)\n        return len(distance[distance < 0])\n\n    def collides_with(self, bubble, bubbles):\n        distance = self.outline_distance(bubble, bubbles)\n        return np.argmin(distance, keepdims=True)\n\n    def collapse(self, n_iterations=50):\n        \"\"\"\n        Move bubbles to the center of mass.\n\n        Parameters\n        ----------\n        n_iterations : int, default: 50\n            Number of moves to perform.\n        \"\"\"\n        for _i in range(n_iterations):\n            moves = 0\n            for i in range(len(self.bubbles)):\n                rest_bub = np.delete(self.bubbles, i, 0)\n                # try to move directly towards the center of mass\n                # direction vector from bubble to the center of mass\n                dir_vec = self.com - self.bubbles[i, :2]\n\n                # shorten direction vector to have length of 1\n                dir_vec = dir_vec / np.sqrt(dir_vec.dot(dir_vec))\n\n                # calculate new bubble position\n                new_point = self.bubbles[i, :2] + dir_vec * self.step_dist\n                new_bubble = np.append(new_point, self.bubbles[i, 2:4])\n\n                # check whether new bubble collides with other bubbles\n                if not self.check_collisions(new_bubble, rest_bub):\n                    self.bubbles[i, :] = new_bubble\n                    self.com = self.center_of_mass()\n                    moves += 1\n                else:\n                    # try to move around a bubble that you collide with\n                    # find colliding bubble\n                    for colliding in self.collides_with(new_bubble, rest_bub):\n                        # calculate direction vector\n                        dir_vec = rest_bub[colliding, :2] - self.bubbles[i, :2]\n                        dir_vec = dir_vec / np.sqrt(dir_vec.dot(dir_vec))\n                        # calculate orthogonal vector\n                        orth = np.array([dir_vec[1], -dir_vec[0]])\n                        # test which direction to go\n                        new_point1 = (self.bubbles[i, :2] + orth *\n                                      self.step_dist)\n                        new_point2 = (self.bubbles[i, :2] - orth *\n                                      self.step_dist)\n                        dist1 = self.center_distance(\n                            self.com, np.array([new_point1]))\n                        dist2 = self.center_distance(\n                            self.com, np.array([new_point2]))\n                        new_point = new_point1 if dist1 < dist2 else new_point2\n                        new_bubble = np.append(new_point, self.bubbles[i, 2:4])\n                        if not self.check_collisions(new_bubble, rest_bub):\n                            self.bubbles[i, :] = new_bubble\n                            self.com = self.center_of_mass()\n\n            if moves / len(self.bubbles) < 0.1:\n                self.step_dist = self.step_dist / 2\n\n    def plot(self, ax, labels, colors):\n        \"\"\"\n        Draw the bubble plot.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes\n        labels : list\n            Labels of the bubbles.\n        colors : list\n            Colors of the bubbles.\n        \"\"\"\n        for i in range(len(self.bubbles)):\n            circ = plt.Circle(\n                self.bubbles[i, :2], self.bubbles[i, 2], color=colors[i])\n            ax.add_patch(circ)\n            ax.text(*self.bubbles[i, :2], labels[i],\n                    horizontalalignment='center', verticalalignment='center')\n\n\nbubble_chart = BubbleChart(area=browser_market_share['market_share'],\n                           bubble_spacing=0.1)\n\nbubble_chart.collapse()\n\nfig, ax = plt.subplots(subplot_kw=dict(aspect=\"equal\"))\nbubble_chart.plot(\n    ax, browser_market_share['browsers'], browser_market_share['color'])\nax.axis(\"off\")\nax.relim()\nax.autoscale_view()\nax.set_title('Browser market share')\n\nplt.show()\n"
    },
    {
      "filename": "patheffect_demo.py",
      "title": "Patheffect Demo",
      "code": "\"\"\"\n===============\nPatheffect Demo\n===============\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 3))\nax1.imshow([[1, 2], [2, 3]])\ntxt = ax1.annotate(\"test\", (1., 1.), (0., 0),\n                   arrowprops=dict(arrowstyle=\"->\",\n                                   connectionstyle=\"angle3\", lw=2),\n                   size=20, ha=\"center\",\n                   path_effects=[patheffects.withStroke(linewidth=3,\n                                                        foreground=\"w\")])\ntxt.arrow_patch.set_path_effects([\n    patheffects.Stroke(linewidth=5, foreground=\"w\"),\n    patheffects.Normal()])\n\npe = [patheffects.withStroke(linewidth=3,\n                             foreground=\"w\")]\nax1.grid(True, linestyle=\"-\", path_effects=pe)\n\narr = np.arange(25).reshape((5, 5))\nax2.imshow(arr)\ncntr = ax2.contour(arr, colors=\"k\")\n\ncntr.set(path_effects=[patheffects.withStroke(linewidth=3, foreground=\"w\")])\n\nclbls = ax2.clabel(cntr, fmt=\"%2.0f\", use_clabeltext=True)\nplt.setp(clbls, path_effects=[\n    patheffects.withStroke(linewidth=3, foreground=\"w\")])\n\n# shadow as a path effect\np1, = ax3.plot([0, 1], [0, 1])\nleg = ax3.legend([p1], [\"Line 1\"], fancybox=True, loc='upper left')\nleg.legendPatch.set_path_effects([patheffects.withSimplePatchShadow()])\n\nplt.show()\n"
    },
    {
      "filename": "print_stdout_sgskip.py",
      "title": "Print Stdout Sgskip",
      "code": "\"\"\"\n=====================\nPrint image to stdout\n=====================\n\nprint png to standard out\n\nusage: python print_stdout.py > somefile.png\n\n\"\"\"\n\nimport sys\n\nimport matplotlib\n\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3])\nplt.savefig(sys.stdout.buffer)\n"
    },
    {
      "filename": "rasterization_demo.py",
      "title": "Rasterization Demo",
      "code": "\"\"\"\n=================================\nRasterization for vector graphics\n=================================\n\nRasterization converts vector graphics into a raster image (pixels). It can\nspeed up rendering and produce smaller files for large data sets, but comes\nat the cost of a fixed resolution.\n\nWhether rasterization should be used can be specified per artist.  This can be\nuseful to reduce the file size of large artists, while maintaining the\nadvantages of vector graphics for other artists such as the Axes\nand text.  For instance a complicated `~.Axes.pcolormesh` or\n`~.Axes.contourf` can be made significantly simpler by rasterizing.\nSetting rasterization only affects vector backends such as PDF, SVG, or PS.\n\nRasterization is disabled by default. There are two ways to enable it, which\ncan also be combined:\n\n- Set `~.Artist.set_rasterized` on individual artists, or use the keyword\n  argument *rasterized* when creating the artist.\n- Set `.Axes.set_rasterization_zorder` to rasterize all artists with a zorder\n  less than the given value.\n\nThe storage size and the resolution of the rasterized artist is determined by\nits physical size and the value of the ``dpi`` parameter passed to\n`~.Figure.savefig`.\n\n.. note::\n\n    The image of this example shown in the HTML documentation is not a vector\n    graphic. Therefore, it cannot illustrate the rasterization effect. Please\n    run this example locally and check the generated graphics files.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nd = np.arange(100).reshape(10, 10)  # the values to be color-mapped\nx, y = np.meshgrid(np.arange(11), np.arange(11))\n\ntheta = 0.25*np.pi\nxx = x*np.cos(theta) - y*np.sin(theta)  # rotate x by -theta\nyy = x*np.sin(theta) + y*np.cos(theta)  # rotate y by -theta\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, layout=\"constrained\")\n\n# pcolormesh without rasterization\nax1.set_aspect(1)\nax1.pcolormesh(xx, yy, d)\nax1.set_title(\"No Rasterization\")\n\n# pcolormesh with rasterization; enabled by keyword argument\nax2.set_aspect(1)\nax2.set_title(\"Rasterization\")\nax2.pcolormesh(xx, yy, d, rasterized=True)\n\n# pcolormesh with an overlaid text without rasterization\nax3.set_aspect(1)\nax3.pcolormesh(xx, yy, d)\nax3.text(0.5, 0.5, \"Text\", alpha=0.2,\n         va=\"center\", ha=\"center\", size=50, transform=ax3.transAxes)\nax3.set_title(\"No Rasterization\")\n\n# pcolormesh with an overlaid text without rasterization; enabled by zorder.\n# Setting the rasterization zorder threshold to 0 and a negative zorder on the\n# pcolormesh rasterizes it. All artists have a non-negative zorder by default,\n# so they (e.g. the text here) are not affected.\nax4.set_aspect(1)\nm = ax4.pcolormesh(xx, yy, d, zorder=-10)\nax4.text(0.5, 0.5, \"Text\", alpha=0.2,\n         va=\"center\", ha=\"center\", size=50, transform=ax4.transAxes)\nax4.set_rasterization_zorder(0)\nax4.set_title(\"Rasterization z$<-10$\")\n\n# Save files in pdf and eps format\nplt.savefig(\"test_rasterization.pdf\", dpi=150)\nplt.savefig(\"test_rasterization.eps\", dpi=150)\n\nif not plt.rcParams[\"text.usetex\"]:\n    plt.savefig(\"test_rasterization.svg\", dpi=150)\n    # svg backend currently ignores the dpi\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.artist.Artist.set_rasterized`\n#    - `matplotlib.axes.Axes.set_rasterization_zorder`\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`\n"
    },
    {
      "filename": "set_and_get.py",
      "title": "Set And Get",
      "code": "\"\"\"\n======================\nSet and get properties\n======================\n\nThe pyplot interface allows you to use ``setp`` and ``getp`` to\nset and get object properties respectively, as well as to do\nintrospection on the object.\n\nSetting with ``setp``\n=====================\n\nTo set the linestyle of a line to be dashed, you use ``setp``::\n\n  >>> line, = plt.plot([1, 2, 3])\n  >>> plt.setp(line, linestyle='--')\n\nIf you want to know the valid types of arguments, you can provide the\nname of the property you want to set without a value::\n\n  >>> plt.setp(line, 'linestyle')\n      linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n\nIf you want to see all the properties that can be set, and their\npossible values, you can do::\n\n    >>> plt.setp(line)\n\n``setp`` operates on a single instance or a list of instances.  If you\nare in query mode introspecting the possible values, only the first\ninstance in the sequence is used.  When actually setting values, all\nthe instances will be set.  For example, suppose you have a list of\ntwo lines, the following will make both lines thicker and red::\n\n    >>> x = np.arange(0, 1, 0.01)\n    >>> y1 = np.sin(2*np.pi*x)\n    >>> y2 = np.sin(4*np.pi*x)\n    >>> lines = plt.plot(x, y1, x, y2)\n    >>> plt.setp(lines, linewidth=2, color='r')\n\n\nGetting with ``getp``\n=====================\n\n``getp`` returns the value of a given attribute.  You can use it to query\nthe value of a single attribute::\n\n    >>> plt.getp(line, 'linewidth')\n        0.5\n\nor all the attribute/value pairs::\n\n    >>> plt.getp(line)\n        aa = True\n        alpha = 1.0\n        antialiased = True\n        c = b\n        clip_on = True\n        color = b\n        ... long listing skipped ...\n\nAliases\n=======\n\nTo reduce keystrokes in interactive mode, a number of properties\nhave short aliases, e.g., 'lw' for 'linewidth' and 'mec' for\n'markeredgecolor'.  When calling set or get in introspection mode,\nthese properties will be listed as 'fullname' or 'aliasname'.\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0, 1.0, 0.01)\ny1 = np.sin(2*np.pi*x)\ny2 = np.sin(4*np.pi*x)\nlines = plt.plot(x, y1, x, y2)\nl1, l2 = lines\nplt.setp(lines, linestyle='--')       # set both to dashed\nplt.setp(l1, linewidth=2, color='r')  # line1 is thick and red\nplt.setp(l2, linewidth=1, color='g')  # line2 is thinner and green\n\n\nprint('Line setters')\nplt.setp(l1)\nprint('Line getters')\nplt.getp(l1)\n\nprint('Rectangle setters')\nplt.setp(plt.gca().patch)\nprint('Rectangle getters')\nplt.getp(plt.gca().patch)\n\nt = plt.title('Hi mom')\nprint('Text setters')\nplt.setp(t)\nprint('Text getters')\nplt.getp(t)\n\nplt.show()\n"
    },
    {
      "filename": "svg_filter_line.py",
      "title": "Svg Filter Line",
      "code": "\"\"\"\n==========================\nApply SVG filter to a line\n==========================\n\nDemonstrate SVG filtering effects which might be used with Matplotlib.\n\nNote that the filtering effects are only effective if your SVG renderer\nsupport it.\n\"\"\"\n\nimport io\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\n\nfig1 = plt.figure()\nax = fig1.add_axes([0.1, 0.1, 0.8, 0.8])\n\n# draw lines\nl1, = ax.plot([0.1, 0.5, 0.9], [0.1, 0.9, 0.5], \"bo-\",\n              mec=\"b\", lw=5, ms=10, label=\"Line 1\")\nl2, = ax.plot([0.1, 0.5, 0.9], [0.5, 0.2, 0.7], \"rs-\",\n              mec=\"r\", lw=5, ms=10, label=\"Line 2\")\n\n\nfor l in [l1, l2]:\n\n    # draw shadows with same lines with slight offset and gray colors.\n\n    xx = l.get_xdata()\n    yy = l.get_ydata()\n    shadow, = ax.plot(xx, yy)\n    shadow.update_from(l)\n\n    # adjust color\n    shadow.set_color(\"0.2\")\n    # adjust zorder of the shadow lines so that it is drawn below the\n    # original lines\n    shadow.set_zorder(l.get_zorder() - 0.5)\n\n    # offset transform\n    transform = mtransforms.offset_copy(l.get_transform(), fig1,\n                                        x=4.0, y=-6.0, units='points')\n    shadow.set_transform(transform)\n\n    # set the id for a later use\n    shadow.set_gid(l.get_label() + \"_shadow\")\n\n\nax.set_xlim(0., 1.)\nax.set_ylim(0., 1.)\n\n# save the figure as a bytes string in the svg format.\nf = io.BytesIO()\nplt.savefig(f, format=\"svg\")\n\n\n# filter definition for a gaussian blur\nfilter_def = \"\"\"\n  <defs xmlns='http://www.w3.org/2000/svg'\n        xmlns:xlink='http://www.w3.org/1999/xlink'>\n    <filter id='dropshadow' height='1.2' width='1.2'>\n      <feGaussianBlur result='blur' stdDeviation='3'/>\n    </filter>\n  </defs>\n\"\"\"\n\n\n# read in the saved svg\ntree, xmlid = ET.XMLID(f.getvalue())\n\n# insert the filter definition in the svg dom tree.\ntree.insert(0, ET.XML(filter_def))\n\nfor l in [l1, l2]:\n    # pick up the svg element with given id\n    shadow = xmlid[l.get_label() + \"_shadow\"]\n    # apply shadow filter\n    shadow.set(\"filter\", 'url(#dropshadow)')\n\nfn = \"svg_filter_line.svg\"\nprint(f\"Saving '{fn}'\")\nET.ElementTree(tree).write(fn)\n"
    },
    {
      "filename": "svg_filter_pie.py",
      "title": "Svg Filter Pie",
      "code": "\"\"\"\n==============\nSVG filter pie\n==============\n\nDemonstrate SVG filtering effects which might be used with Matplotlib.\nThe pie chart drawing code is borrowed from pie_demo.py\n\nNote that the filtering effects are only effective if your SVG renderer\nsupport it.\n\"\"\"\n\nimport io\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.patches import Shadow\n\n# make a square figure and Axes\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n\nlabels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\nfracs = [15, 30, 45, 10]\n\nexplode = (0, 0.05, 0, 0)\n\n# We want to draw the shadow for each pie, but we will not use \"shadow\"\n# option as it doesn't save the references to the shadow patches.\npies = ax.pie(fracs, explode=explode, labels=labels, autopct='%1.1f%%')\n\nfor w in pies[0]:\n    # set the id with the label.\n    w.set_gid(w.get_label())\n\n    # we don't want to draw the edge of the pie\n    w.set_edgecolor(\"none\")\n\nfor w in pies[0]:\n    # create shadow patch\n    s = Shadow(w, -0.01, -0.01)\n    s.set_gid(w.get_gid() + \"_shadow\")\n    s.set_zorder(w.get_zorder() - 0.1)\n    ax.add_patch(s)\n\n\n# save\nf = io.BytesIO()\nplt.savefig(f, format=\"svg\")\n\n\n# Filter definition for shadow using a gaussian blur and lighting effect.\n# The lighting filter is copied from http://www.w3.org/TR/SVG/filters.html\n\n# I tested it with Inkscape and Firefox3. \"Gaussian blur\" is supported\n# in both, but the lighting effect only in Inkscape. Also note\n# that, Inkscape's exporting also may not support it.\n\nfilter_def = \"\"\"\n  <defs xmlns='http://www.w3.org/2000/svg'\n        xmlns:xlink='http://www.w3.org/1999/xlink'>\n    <filter id='dropshadow' height='1.2' width='1.2'>\n      <feGaussianBlur result='blur' stdDeviation='2'/>\n    </filter>\n\n    <filter id='MyFilter' filterUnits='objectBoundingBox'\n            x='0' y='0' width='1' height='1'>\n      <feGaussianBlur in='SourceAlpha' stdDeviation='4%' result='blur'/>\n      <feOffset in='blur' dx='4%' dy='4%' result='offsetBlur'/>\n      <feSpecularLighting in='blur' surfaceScale='5' specularConstant='.75'\n           specularExponent='20' lighting-color='#bbbbbb' result='specOut'>\n        <fePointLight x='-5000%' y='-10000%' z='20000%'/>\n      </feSpecularLighting>\n      <feComposite in='specOut' in2='SourceAlpha'\n                   operator='in' result='specOut'/>\n      <feComposite in='SourceGraphic' in2='specOut' operator='arithmetic'\n    k1='0' k2='1' k3='1' k4='0'/>\n    </filter>\n  </defs>\n\"\"\"\n\n\ntree, xmlid = ET.XMLID(f.getvalue())\n\n# insert the filter definition in the svg dom tree.\ntree.insert(0, ET.XML(filter_def))\n\nfor i, pie_name in enumerate(labels):\n    pie = xmlid[pie_name]\n    pie.set(\"filter\", 'url(#MyFilter)')\n\n    shadow = xmlid[pie_name + \"_shadow\"]\n    shadow.set(\"filter\", 'url(#dropshadow)')\n\nfn = \"svg_filter_pie.svg\"\nprint(f\"Saving '{fn}'\")\nET.ElementTree(tree).write(fn)\n"
    },
    {
      "filename": "table_demo.py",
      "title": "Table Demo",
      "code": "\"\"\"\n==========\nTable Demo\n==========\n\nDemo of table function to display a table within a plot.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndata = [[ 66386, 174296,  75131, 577908,  32015],\n        [ 58230, 381139,  78045,  99308, 160454],\n        [ 89135,  80552, 152558, 497981, 603535],\n        [ 78415,  81858, 150656, 193263,  69638],\n        [139361, 331509, 343164, 781380,  52269]]\n\ncolumns = ('Freeze', 'Wind', 'Flood', 'Quake', 'Hail')\nrows = ['%d year' % x for x in (100, 50, 20, 10, 5)]\n\nvalues = np.arange(0, 2500, 500)\nvalue_increment = 1000\n\n# Get some pastel shades for the colors\ncolors = plt.cm.BuPu(np.linspace(0, 0.5, len(rows)))\nn_rows = len(data)\n\nindex = np.arange(len(columns)) + 0.3\nbar_width = 0.4\n\n# Initialize the vertical-offset for the stacked bar chart.\ny_offset = np.zeros(len(columns))\n\n# Plot bars and create text labels for the table\ncell_text = []\nfor row in range(n_rows):\n    plt.bar(index, data[row], bar_width, bottom=y_offset, color=colors[row])\n    y_offset = y_offset + data[row]\n    cell_text.append(['%1.1f' % (x / 1000.0) for x in y_offset])\n# Reverse colors and text labels to display the last value at the top.\ncolors = colors[::-1]\ncell_text.reverse()\n\n# Add a table at the bottom of the Axes\nthe_table = plt.table(cellText=cell_text,\n                      rowLabels=rows,\n                      rowColours=colors,\n                      colLabels=columns,\n                      loc='bottom')\n\n# Adjust layout to make room for the table:\nplt.subplots_adjust(left=0.2, bottom=0.2)\n\nplt.ylabel(f\"Loss in ${value_increment}'s\")\nplt.yticks(values * value_increment, ['%d' % val for val in values])\nplt.xticks([])\nplt.title('Loss by Disaster')\n\nplt.show()\n"
    },
    {
      "filename": "tickedstroke_demo.py",
      "title": "Tickedstroke Demo",
      "code": "\"\"\"\n=======================\nTickedStroke patheffect\n=======================\n\nMatplotlib's :mod:`.patheffects` can be used to alter the way paths\nare drawn at a low enough level that they can affect almost anything.\n\nThe :ref:`patheffects guide<patheffects_guide>`\ndetails the use of patheffects.\n\nThe `~matplotlib.patheffects.TickedStroke` patheffect illustrated here\ndraws a path with a ticked style.  The spacing, length, and angle of\nticks can be controlled.\n\nSee also the :doc:`/gallery/lines_bars_and_markers/lines_with_ticks_demo` example.\n\nSee also the :doc:`/gallery/images_contours_and_fields/contours_in_optimization_demo`\nexample.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n# Applying TickedStroke to paths\n# ==============================\nimport matplotlib.patches as patches\nfrom matplotlib.path import Path\nimport matplotlib.patheffects as patheffects\n\nfig, ax = plt.subplots(figsize=(6, 6))\npath = Path.unit_circle()\npatch = patches.PathPatch(path, facecolor='none', lw=2, path_effects=[\n    patheffects.withTickedStroke(angle=-90, spacing=10, length=1)])\n\nax.add_patch(patch)\nax.axis('equal')\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\n\nplt.show()\n\n# %%\n# Applying TickedStroke to lines\n# ==============================\nfig, ax = plt.subplots(figsize=(6, 6))\nax.plot([0, 1], [0, 1], label=\"Line\",\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)])\n\nnx = 101\nx = np.linspace(0.0, 1.0, nx)\ny = 0.3*np.sin(x*8) + 0.4\nax.plot(x, y, label=\"Curve\", path_effects=[patheffects.withTickedStroke()])\n\nax.legend()\n\nplt.show()\n\n# %%\n# Applying TickedStroke to contour plots\n# ======================================\n#\n# Contour plot with objective and constraints.\n# Curves generated by contour to represent a typical constraint in an\n# optimization problem should be plotted with angles between zero and\n# 180 degrees.\nfig, ax = plt.subplots(figsize=(6, 6))\n\nnx = 101\nny = 105\n\n# Set up survey vectors\nxvec = np.linspace(0.001, 4.0, nx)\nyvec = np.linspace(0.001, 4.0, ny)\n\n# Set up survey matrices.  Design disk loading and gear ratio.\nx1, x2 = np.meshgrid(xvec, yvec)\n\n# Evaluate some stuff to plot\nobj = x1**2 + x2**2 - 2*x1 - 2*x2 + 2\ng1 = -(3*x1 + x2 - 5.5)\ng2 = -(x1 + 2*x2 - 4.5)\ng3 = 0.8 + x1**-3 - x2\n\ncntr = ax.contour(x1, x2, obj, [0.01, 0.1, 0.5, 1, 2, 4, 8, 16],\n                  colors='black')\nax.clabel(cntr, fmt=\"%2.1f\", use_clabeltext=True)\n\ncg1 = ax.contour(x1, x2, g1, [0], colors='sandybrown')\ncg1.set(path_effects=[patheffects.withTickedStroke(angle=135)])\n\ncg2 = ax.contour(x1, x2, g2, [0], colors='orangered')\ncg2.set(path_effects=[patheffects.withTickedStroke(angle=60, length=2)])\n\ncg3 = ax.contour(x1, x2, g3, [0], colors='mediumblue')\ncg3.set(path_effects=[patheffects.withTickedStroke(spacing=7)])\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nplt.show()\n\n# %%\n# Direction/side of the ticks\n# ===========================\n#\n# To change which side of the line the ticks are drawn, change the sign of the angle.\n\nfig, ax = plt.subplots(figsize=(6, 6))\nline_x = line_y = [0, 1]\nax.plot(line_x, line_y, label=\"Line\",\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)])\n\nax.plot(line_x, line_y, label=\"Opposite side\",\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=-135)])\n\nax.legend()\nplt.show()\n"
    },
    {
      "filename": "transoffset.py",
      "title": "Transoffset",
      "code": "\"\"\"\n======================\ntransforms.offset_copy\n======================\n\nThis illustrates the use of `.transforms.offset_copy` to\nmake a transform that positions a drawing element such as\na text string at a specified offset in screen coordinates\n(dots or inches) relative to a location given in any\ncoordinates.\n\nEvery Artist (Text, Line2D, etc.) has a transform that can be\nset when the Artist is created, such as by the corresponding\npyplot function.  By default, this is usually the Axes.transData\ntransform, going from data units to screen pixels.  We can\nuse the `.offset_copy` function to make a modified copy of\nthis transform, where the modification consists of an\noffset.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.transforms as mtransforms\n\nxs = np.arange(7)\nys = xs**2\n\nfig = plt.figure(figsize=(5, 10))\nax = plt.subplot(2, 1, 1)\n\n# If we want the same offset for each text instance,\n# we only need to make one transform.  To get the\n# transform argument to offset_copy, we need to make the Axes\n# first; the subplot function above is one way to do this.\ntrans_offset = mtransforms.offset_copy(ax.transData, fig=fig,\n                                       x=0.05, y=0.10, units='inches')\n\nfor x, y in zip(xs, ys):\n    plt.plot(x, y, 'ro')\n    plt.text(x, y, '%d, %d' % (int(x), int(y)), transform=trans_offset)\n\n\n# offset_copy works for polar plots also.\nax = plt.subplot(2, 1, 2, projection='polar')\n\ntrans_offset = mtransforms.offset_copy(ax.transData, fig=fig,\n                                       y=6, units='dots')\n\nfor x, y in zip(xs, ys):\n    plt.polar(x, y, 'ro')\n    plt.text(x, y, '%d, %d' % (int(x), int(y)),\n             transform=trans_offset,\n             horizontalalignment='center',\n             verticalalignment='bottom')\n\nplt.show()\n"
    },
    {
      "filename": "zorder_demo.py",
      "title": "Zorder Demo",
      "code": "\"\"\"\n===========\nZorder Demo\n===========\n\nThe drawing order of artists is determined by their ``zorder`` attribute, which\nis a floating point number. Artists with higher ``zorder`` are drawn on top.\nYou can change the order for individual artists by setting their ``zorder``.\nThe default value depends on the type of the Artist:\n\n================================================================    =======\nArtist                                                              Z-order\n================================================================    =======\nImages (`.AxesImage`, `.FigureImage`, `.BboxImage`)                 0\n`.Patch`, `.PatchCollection`                                        1\n`.Line2D`, `.LineCollection` (including minor ticks, grid lines)    2\nMajor ticks                                                         2.01\n`.Text` (including Axes labels and titles)                          3\n`.Legend`                                                           5\n================================================================    =======\n\nAny call to a plotting method can set a value for the zorder of that particular\nitem explicitly.\n\n.. note::\n\n   `~.axes.Axes.set_axisbelow` and :rc:`axes.axisbelow` are convenient helpers\n   for setting the zorder of ticks and grid lines.\n\nDrawing is done per `~.axes.Axes` at a time. If you have overlapping Axes, all\nelements of the second Axes are drawn on top of the first Axes, irrespective of\ntheir relative zorder.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nr = np.linspace(0.3, 1, 30)\ntheta = np.linspace(0, 4*np.pi, 30)\nx = r * np.sin(theta)\ny = r * np.cos(theta)\n\n# %%\n# The following example contains a `.Line2D` created by `~.axes.Axes.plot()`\n# and the dots (a `.PatchCollection`) created by `~.axes.Axes.scatter()`.\n# Hence, by default the dots are below the line (first subplot).\n# In the second subplot, the ``zorder`` is set explicitly to move the dots\n# on top of the line.\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6, 3.2))\n\nax1.plot(x, y, 'C3', lw=3)\nax1.scatter(x, y, s=120)\nax1.set_title('Lines on top of dots')\n\nax2.plot(x, y, 'C3', lw=3)\nax2.scatter(x, y, s=120, zorder=2.5)  # move dots on top of line\nax2.set_title('Dots on top of lines')\n\nplt.tight_layout()\n\n# %%\n# Many functions that create a visible object accepts a ``zorder`` parameter.\n# Alternatively, you can call ``set_zorder()`` on the created object later.\n\nx = np.linspace(0, 7.5, 100)\nplt.rcParams['lines.linewidth'] = 5\nplt.figure()\nplt.plot(x, np.sin(x), label='zorder=2', zorder=2)  # bottom\nplt.plot(x, np.sin(x+0.5), label='zorder=3',  zorder=3)\nplt.axhline(0, label='zorder=2.5', color='lightgrey', zorder=2.5)\nplt.title('Custom order of elements')\nl = plt.legend(loc='upper right')\nl.set_zorder(2.5)  # legend between blue and orange line\nplt.show()\n"
    }
  ],
  "mplot3d": [
    {
      "filename": "2dcollections3d.py",
      "title": "2Dcollections3D",
      "code": "\"\"\"\n=======================\nPlot 2D data on 3D plot\n=======================\n\nDemonstrates using ax.plot's *zdir* keyword to plot 2D data on\nselective axes of a 3D plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Plot a sin curve using the x and y axes.\nx = np.linspace(0, 1, 100)\ny = np.sin(x * 2 * np.pi) / 2 + 0.5\nax.plot(x, y, zs=0, zdir='z', label='curve in (x, y)')\n\n# Plot scatterplot data (20 2D points per colour) on the x and z axes.\ncolors = ('r', 'g', 'b', 'k')\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.sample(20 * len(colors))\ny = np.random.sample(20 * len(colors))\nc_list = []\nfor c in colors:\n    c_list.extend([c] * 20)\n# By using zdir='y', the y value of these points is fixed to the zs value 0\n# and the (x, y) points are plotted on the x and z axes.\nax.scatter(x, y, zs=0, zdir='y', c=c_list, label='points in (x, z)')\n\n# Make legend, set axes limits and labels\nax.legend()\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_zlim(0, 1)\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\n\n# Customize the view angle so it's easier to see that the scatter points lie\n# on the plane y=0\nax.view_init(elev=20., azim=-35, roll=0)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: scatter, plot-type: line,\n#    component: axes,\n#    level: intermediate\n"
    },
    {
      "filename": "3d_bars.py",
      "title": "3D Bars",
      "code": "\"\"\"\n=====================\nDemo of 3D bar charts\n=====================\n\nA basic demo of how to plot 3D bars with and without shading.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# set up the figure and Axes\nfig = plt.figure(figsize=(8, 3))\nax1 = fig.add_subplot(121, projection='3d')\nax2 = fig.add_subplot(122, projection='3d')\n\n# fake data\n_x = np.arange(4)\n_y = np.arange(5)\n_xx, _yy = np.meshgrid(_x, _y)\nx, y = _xx.ravel(), _yy.ravel()\n\ntop = x + y\nbottom = np.zeros_like(top)\nwidth = depth = 1\n\nax1.bar3d(x, y, bottom, width, depth, top, shade=True)\nax1.set_title('Shaded')\n\nax2.bar3d(x, y, bottom, width, depth, top, shade=False)\nax2.set_title('Not Shaded')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    styling: texture,\n#    plot-type: bar,\n#    level: beginner\n"
    },
    {
      "filename": "axlim_clip.py",
      "title": "Axlim Clip",
      "code": "\"\"\"\n=====================================\nClip the data to the axes view limits\n=====================================\n\nDemonstrate clipping of line and marker data to the axes view limits. The\n``axlim_clip`` keyword argument can be used in any of the 3D plotting\nfunctions.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n\n# Make the data\nx = np.arange(-5, 5, 0.5)\ny = np.arange(-5, 5, 0.5)\nX, Y = np.meshgrid(x, y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Default behavior is axlim_clip=False\nax.plot_wireframe(X, Y, Z, color='C0')\n\n# When axlim_clip=True, note that when a line segment has one vertex outside\n# the view limits, the entire line is hidden. The same is true for 3D patches\n# if one of their vertices is outside the limits (not shown).\nax.plot_wireframe(X, Y, Z, color='C1', axlim_clip=True)\n\n# In this example, data where x < 0 or z > 0.5 is clipped\nax.set(xlim=(0, 10), ylim=(-5, 5), zlim=(-1, 0.5))\nax.legend(['axlim_clip=False (default)', 'axlim_clip=True'])\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner\n"
    },
    {
      "filename": "bars3d.py",
      "title": "Bars3D",
      "code": "\"\"\"\n========================================\nCreate 2D bar graphs in different planes\n========================================\n\nDemonstrates making a 3D plot which has 2D bar graphs projected onto\nplanes y=0, y=1, etc.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\ncolors = ['r', 'g', 'b', 'y']\nyticks = [3, 2, 1, 0]\nfor c, k in zip(colors, yticks):\n    # Generate the random data for the y=k 'layer'.\n    xs = np.arange(20)\n    ys = np.random.rand(20)\n\n    # You can provide either a single color or an array with the same length as\n    # xs and ys. To demonstrate this, we color the first bar of each set cyan.\n    cs = [c] * len(xs)\n    cs[0] = 'c'\n\n    # Plot the bar graph given by xs and ys on the plane y=k with 80% opacity.\n    ax.bar(xs, ys, zs=k, zdir='y', color=cs, alpha=0.8)\n\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\n\n# On the y-axis let's only label the discrete values that we have data for.\nax.set_yticks(yticks)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: bar,\n#    styling: color,\n#    level: beginner\n"
    },
    {
      "filename": "box3d.py",
      "title": "Box3D",
      "code": "\"\"\"\n===================\n3D box surface plot\n===================\n\nGiven data on a gridded volume ``X``, ``Y``, ``Z``, this example plots the\ndata values on the volume surfaces.\n\nThe strategy is to select the data from each surface and plot\ncontours separately using `.axes3d.Axes3D.contourf` with appropriate\nparameters *zdir* and *offset*.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Define dimensions\nNx, Ny, Nz = 100, 300, 500\nX, Y, Z = np.meshgrid(np.arange(Nx), np.arange(Ny), -np.arange(Nz))\n\n# Create fake data\ndata = (((X+100)**2 + (Y-20)**2 + 2*Z)/1000+1)\n\nkw = {\n    'vmin': data.min(),\n    'vmax': data.max(),\n    'levels': np.linspace(data.min(), data.max(), 10),\n}\n\n# Create a figure with 3D ax\nfig = plt.figure(figsize=(5, 4))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot contour surfaces\n_ = ax.contourf(\n    X[:, :, 0], Y[:, :, 0], data[:, :, 0],\n    zdir='z', offset=0, **kw\n)\n_ = ax.contourf(\n    X[0, :, :], data[0, :, :], Z[0, :, :],\n    zdir='y', offset=0, **kw\n)\nC = ax.contourf(\n    data[:, -1, :], Y[:, -1, :], Z[:, -1, :],\n    zdir='x', offset=X.max(), **kw\n)\n# --\n\n\n# Set limits of the plot from coord limits\nxmin, xmax = X.min(), X.max()\nymin, ymax = Y.min(), Y.max()\nzmin, zmax = Z.min(), Z.max()\nax.set(xlim=[xmin, xmax], ylim=[ymin, ymax], zlim=[zmin, zmax])\n\n# Plot edges\nedges_kw = dict(color='0.4', linewidth=1, zorder=1e3)\nax.plot([xmax, xmax], [ymin, ymax], 0, **edges_kw)\nax.plot([xmin, xmax], [ymin, ymin], 0, **edges_kw)\nax.plot([xmax, xmax], [ymin, ymin], [zmin, zmax], **edges_kw)\n\n# Set labels and zticks\nax.set(\n    xlabel='X [km]',\n    ylabel='Y [km]',\n    zlabel='Z [m]',\n    zticks=[0, -150, -300, -450],\n)\n\n# Set zoom and angle view\nax.view_init(40, -30, 0)\nax.set_box_aspect(None, zoom=0.9)\n\n# Colorbar\nfig.colorbar(C, ax=ax, fraction=0.02, pad=0.1, label='Name [units]')\n\n# Show Figure\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: intermediate\n"
    },
    {
      "filename": "contour3d.py",
      "title": "Contour3D",
      "code": "\"\"\"\n=================================\nPlot contour (level) curves in 3D\n=================================\n\nThis is like a contour plot in 2D except that the ``f(x, y)=c`` curve is\nplotted on the plane ``z=c``.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\nax.contour(X, Y, Z, cmap=cm.coolwarm)  # Plot contour curves\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner\n"
    },
    {
      "filename": "contour3d_2.py",
      "title": "Contour3D 2",
      "code": "\"\"\"\n===========================================================\nPlot contour (level) curves in 3D using the extend3d option\n===========================================================\n\nThis modification of the :doc:`contour3d` example uses ``extend3d=True`` to\nextend the curves vertically into 'ribbons'.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\nax.contour(X, Y, Z, extend3d=True, cmap=cm.coolwarm)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner\n"
    },
    {
      "filename": "contour3d_3.py",
      "title": "Contour3D 3",
      "code": "\"\"\"\n=====================================\nProject contour profiles onto a graph\n=====================================\nDemonstrates displaying a 3D surface while also projecting contour 'profiles'\nonto the 'walls' of the graph.\nSee :doc:`contourf3d_2` for the filled version.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the 3D surface\nax.plot_surface(X, Y, Z, edgecolor='royalblue', lw=0.5, rstride=8, cstride=8,\n                alpha=0.3)\n\n# Plot projections of the contours for each dimension.  By choosing offsets\n# that match the appropriate axes limits, the projected contours will sit on\n# the 'walls' of the graph.\nax.contour(X, Y, Z, zdir='z', offset=-100, cmap='coolwarm')\nax.contour(X, Y, Z, zdir='x', offset=-40, cmap='coolwarm')\nax.contour(X, Y, Z, zdir='y', offset=40, cmap='coolwarm')\n\nax.set(xlim=(-40, 40), ylim=(-40, 40), zlim=(-100, 100),\n       xlabel='X', ylabel='Y', zlabel='Z')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: axes,\n#    level: intermediate\n"
    },
    {
      "filename": "contourf3d.py",
      "title": "Contourf3D",
      "code": "\"\"\"\n===============\nFilled contours\n===============\n\n`.Axes3D.contourf` differs from `.Axes3D.contour` in that it creates filled\ncontours, i.e. a discrete number of colours are used to shade the domain.\n\nThis is like a `.Axes.contourf` plot in 2D except that the shaded region\ncorresponding to the level c is graphed on the plane ``z=c``.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\nax.contourf(X, Y, Z, cmap=cm.coolwarm)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner\n"
    },
    {
      "filename": "contourf3d_2.py",
      "title": "Contourf3D 2",
      "code": "\"\"\"\n===================================\nProject filled contour onto a graph\n===================================\nDemonstrates displaying a 3D surface while also projecting filled contour\n'profiles' onto the 'walls' of the graph.\nSee :doc:`contour3d_3` for the unfilled version.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the 3D surface\nax.plot_surface(X, Y, Z, edgecolor='royalblue', lw=0.5, rstride=8, cstride=8,\n                alpha=0.3)\n\n# Plot projections of the contours for each dimension.  By choosing offsets\n# that match the appropriate axes limits, the projected contours will sit on\n# the 'walls' of the graph\nax.contourf(X, Y, Z, zdir='z', offset=-100, cmap='coolwarm')\nax.contourf(X, Y, Z, zdir='x', offset=-40, cmap='coolwarm')\nax.contourf(X, Y, Z, zdir='y', offset=40, cmap='coolwarm')\n\nax.set(xlim=(-40, 40), ylim=(-40, 40), zlim=(-100, 100),\n       xlabel='X', ylabel='Y', zlabel='Z')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: axes,\n#    level: intermediate\n"
    },
    {
      "filename": "custom_shaded_3d_surface.py",
      "title": "Custom Shaded 3D Surface",
      "code": "\"\"\"\n=======================================\nCustom hillshading in a 3D surface plot\n=======================================\n\nDemonstrates using custom hillshading in a 3D surface plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook, cm\nfrom matplotlib.colors import LightSource\n\n# Load and format data\ndem = cbook.get_sample_data('jacksboro_fault_dem.npz')\nz = dem['elevation']\nnrows, ncols = z.shape\nx = np.linspace(dem['xmin'], dem['xmax'], ncols)\ny = np.linspace(dem['ymin'], dem['ymax'], nrows)\nx, y = np.meshgrid(x, y)\n\nregion = np.s_[5:50, 5:50]\nx, y, z = x[region], y[region], z[region]\n\n# Set up plot\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\n\nls = LightSource(270, 45)\n# To use a custom hillshading mode, override the built-in shading and pass\n# in the rgb colors of the shaded surface calculated from \"shade\".\nrgb = ls.shade(z, cmap=cm.gist_earth, vert_exag=0.1, blend_mode='soft')\nsurf = ax.plot_surface(x, y, z, rstride=1, cstride=1, facecolors=rgb,\n                       linewidth=0, antialiased=False, shade=False)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: intermediate,\n#    domain: cartography\n"
    },
    {
      "filename": "errorbar3d.py",
      "title": "Errorbar3D",
      "code": "\"\"\"\n============\n3D errorbars\n============\n\nAn example of using errorbars with upper and lower limits in mplot3d.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# setting up a parametric curve\nt = np.arange(0, 2*np.pi+.1, 0.01)\nx, y, z = np.sin(t), np.cos(3*t), np.sin(5*t)\n\nestep = 15\ni = np.arange(t.size)\nzuplims = (i % estep == 0) & (i // estep % 3 == 0)\nzlolims = (i % estep == 0) & (i // estep % 3 == 2)\n\nax.errorbar(x, y, z, 0.2, zuplims=zuplims, zlolims=zlolims, errorevery=estep)\n\nax.set_xlabel(\"X label\")\nax.set_ylabel(\"Y label\")\nax.set_zlabel(\"Z label\")\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: error,\n#    level: beginner\n"
    },
    {
      "filename": "fillbetween3d.py",
      "title": "Fillbetween3D",
      "code": "\"\"\"\n=====================\nFill between 3D lines\n=====================\n\nDemonstrate how to fill the space between 3D lines with surfaces. Here we\ncreate a sort of \"lampshade\" shape.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nN = 50\ntheta = np.linspace(0, 2*np.pi, N)\n\nx1 = np.cos(theta)\ny1 = np.sin(theta)\nz1 = 0.1 * np.sin(6 * theta)\n\nx2 = 0.6 * np.cos(theta)\ny2 = 0.6 * np.sin(theta)\nz2 = 2  # Note that scalar values work in addition to length N arrays\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\nax.fill_between(x1, y1, z1, x2, y2, z2, alpha=0.5, edgecolor='k')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    plot-type: fill_between,\n#    level: beginner\n"
    },
    {
      "filename": "fillunder3d.py",
      "title": "Fillunder3D",
      "code": "\"\"\"\n=========================\nFill under 3D line graphs\n=========================\n\nDemonstrate how to create polygons which fill the space under a line\ngraph. In this example polygons are semi-transparent, creating a sort\nof 'jagged stained glass' effect.\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ngamma = np.vectorize(math.gamma)\nN = 31\nx = np.linspace(0., 10., N)\nlambdas = range(1, 9)\n\nax = plt.figure().add_subplot(projection='3d')\n\nfacecolors = plt.colormaps['viridis_r'](np.linspace(0, 1, len(lambdas)))\n\nfor i, l in enumerate(lambdas):\n    # Note fill_between can take coordinates as length N vectors, or scalars\n    ax.fill_between(x, l, l**x * np.exp(-l) / gamma(x + 1),\n                    x, l, 0,\n                    facecolors=facecolors[i], alpha=.7)\n\nax.set(xlim=(0, 10), ylim=(1, 9), zlim=(0, 0.35),\n       xlabel='x', ylabel=r'$\\lambda$', zlabel='probability')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    plot-type: fill_between,\n#    level: beginner\n"
    },
    {
      "filename": "hist3d.py",
      "title": "Hist3D",
      "code": "\"\"\"\n==============================\nCreate 3D histogram of 2D data\n==============================\n\nDemo of a histogram for 2D data as a bar graph in 3D.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\nx, y = np.random.rand(2, 100) * 4\nhist, xedges, yedges = np.histogram2d(x, y, bins=4, range=[[0, 4], [0, 4]])\n\n# Construct arrays for the anchor positions of the 16 bars.\nxpos, ypos = np.meshgrid(xedges[:-1] + 0.25, yedges[:-1] + 0.25, indexing=\"ij\")\nxpos = xpos.ravel()\nypos = ypos.ravel()\nzpos = 0\n\n# Construct arrays with the dimensions for the 16 bars.\ndx = dy = 0.5 * np.ones_like(zpos)\ndz = hist.ravel()\n\nax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average')\n\nplt.show()\n\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: histogram,\n#    level: beginner\n"
    },
    {
      "filename": "imshow3d.py",
      "title": "Imshow3D",
      "code": "\"\"\"\n===============\n2D images in 3D\n===============\n\nThis example demonstrates how to plot 2D color coded images (similar to\n`.Axes.imshow`) as a plane in 3D.\n\nMatplotlib does not have a native function for this. Below we build one by relying\non `.Axes3D.plot_surface`. For simplicity, there are some differences to\n`.Axes.imshow`: This function does not set the aspect of the Axes, hence pixels are\nnot necessarily square. Also, pixel edges are on integer values rather than pixel\ncenters. Furthermore, many optional parameters of `.Axes.imshow` are not implemented.\n\nMultiple calls of ``imshow3d`` use independent norms and thus different color scales\nby default. If you want to have a single common color scale, you need to construct\na suitable norm beforehand and pass it to all ``imshow3d`` calls.\n\nA fundamental limitation of the 3D plotting engine is that intersecting objects cannot\nbe drawn correctly. One object will always be drawn after the other. Therefore,\nmultiple image planes can well be used in the background as shown in this example.\nBut this approach is not suitable if the planes intersect.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import Normalize\n\n\ndef imshow3d(ax, array, value_direction='z', pos=0, norm=None, cmap=None):\n    \"\"\"\n    Display a 2D array as a  color-coded 2D image embedded in 3d.\n\n    The image will be in a plane perpendicular to the coordinate axis *value_direction*.\n\n    Parameters\n    ----------\n    ax : Axes3D\n        The 3D Axes to plot into.\n    array : 2D numpy array\n        The image values.\n    value_direction : {'x', 'y', 'z'}\n        The axis normal to the image plane.\n    pos : float\n        The numeric value on the *value_direction* axis at which the image plane is\n        located.\n    norm : `~matplotlib.colors.Normalize`, default: Normalize\n        The normalization method used to scale scalar data. See `imshow()`.\n    cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n        The Colormap instance or registered colormap name used to map scalar data\n        to colors.\n    \"\"\"\n    if norm is None:\n        norm = Normalize()\n    colors = plt.get_cmap(cmap)(norm(array))\n\n    if value_direction == 'x':\n        nz, ny = array.shape\n        zi, yi = np.mgrid[0:nz + 1, 0:ny + 1]\n        xi = np.full_like(yi, pos)\n    elif value_direction == 'y':\n        nx, nz = array.shape\n        xi, zi = np.mgrid[0:nx + 1, 0:nz + 1]\n        yi = np.full_like(zi, pos)\n    elif value_direction == 'z':\n        ny, nx = array.shape\n        yi, xi = np.mgrid[0:ny + 1, 0:nx + 1]\n        zi = np.full_like(xi, pos)\n    else:\n        raise ValueError(f\"Invalid value_direction: {value_direction!r}\")\n    ax.plot_surface(xi, yi, zi, rstride=1, cstride=1, facecolors=colors, shade=False)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\nax.set(xlabel=\"x\", ylabel=\"y\", zlabel=\"z\")\n\nnx, ny, nz = 8, 10, 5\ndata_xy = np.arange(ny * nx).reshape(ny, nx) + 15 * np.random.random((ny, nx))\ndata_yz = np.arange(nz * ny).reshape(nz, ny) + 10 * np.random.random((nz, ny))\ndata_zx = np.arange(nx * nz).reshape(nx, nz) + 8 * np.random.random((nx, nz))\n\nimshow3d(ax, data_xy)\nimshow3d(ax, data_yz, value_direction='x', cmap='magma')\nimshow3d(ax, data_zx, value_direction='y', pos=ny, cmap='plasma')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    styling: colormap,\n#    level: advanced\n"
    },
    {
      "filename": "intersecting_planes.py",
      "title": "Intersecting Planes",
      "code": "\"\"\"\n===================\nIntersecting planes\n===================\n\nThis examples demonstrates drawing intersecting planes in 3D. It is a generalization\nof :doc:`/gallery/mplot3d/imshow3d`.\n\nDrawing intersecting planes in `.mplot3d` is complicated, because `.mplot3d` is not a\nreal 3D renderer, but only projects the Artists into 3D and draws them in the right\norder. This does not work correctly if Artists overlap each other mutually. In this\nexample, we lift the problem of mutual overlap by segmenting the planes at their\nintersections, making four parts out of each plane.\n\nThis examples only works correctly for planes that cut each other in haves. This\nlimitation is intentional to keep the code more readable. Cutting at arbitrary\npositions would of course be possible but makes the code even more complex.\nThus, this example is more a demonstration of the concept how to work around\nlimitations of the 3D visualization, it's not a refined solution for drawing\narbitrary intersecting planes, which you can copy-and-paste as is.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef plot_quadrants(ax, array, fixed_coord, cmap):\n    \"\"\"For a given 3d *array* plot a plane with *fixed_coord*, using four quadrants.\"\"\"\n    nx, ny, nz = array.shape\n    index = {\n        'x': (nx // 2, slice(None), slice(None)),\n        'y': (slice(None), ny // 2, slice(None)),\n        'z': (slice(None), slice(None), nz // 2),\n    }[fixed_coord]\n    plane_data = array[index]\n\n    n0, n1 = plane_data.shape\n    quadrants = [\n        plane_data[:n0 // 2, :n1 // 2],\n        plane_data[:n0 // 2, n1 // 2:],\n        plane_data[n0 // 2:, :n1 // 2],\n        plane_data[n0 // 2:, n1 // 2:]\n    ]\n\n    min_val = array.min()\n    max_val = array.max()\n\n    cmap = plt.get_cmap(cmap)\n\n    for i, quadrant in enumerate(quadrants):\n        facecolors = cmap((quadrant - min_val) / (max_val - min_val))\n        if fixed_coord == 'x':\n            Y, Z = np.mgrid[0:ny // 2, 0:nz // 2]\n            X = nx // 2 * np.ones_like(Y)\n            Y_offset = (i // 2) * ny // 2\n            Z_offset = (i % 2) * nz // 2\n            ax.plot_surface(X, Y + Y_offset, Z + Z_offset, rstride=1, cstride=1,\n                            facecolors=facecolors, shade=False)\n        elif fixed_coord == 'y':\n            X, Z = np.mgrid[0:nx // 2, 0:nz // 2]\n            Y = ny // 2 * np.ones_like(X)\n            X_offset = (i // 2) * nx // 2\n            Z_offset = (i % 2) * nz // 2\n            ax.plot_surface(X + X_offset, Y, Z + Z_offset, rstride=1, cstride=1,\n                            facecolors=facecolors, shade=False)\n        elif fixed_coord == 'z':\n            X, Y = np.mgrid[0:nx // 2, 0:ny // 2]\n            Z = nz // 2 * np.ones_like(X)\n            X_offset = (i // 2) * nx // 2\n            Y_offset = (i % 2) * ny // 2\n            ax.plot_surface(X + X_offset, Y + Y_offset, Z, rstride=1, cstride=1,\n                            facecolors=facecolors, shade=False)\n\n\ndef figure_3D_array_slices(array, cmap=None):\n    \"\"\"Plot a 3d array using three intersecting centered planes.\"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(projection='3d')\n    ax.set_box_aspect(array.shape)\n    plot_quadrants(ax, array, 'x', cmap=cmap)\n    plot_quadrants(ax, array, 'y', cmap=cmap)\n    plot_quadrants(ax, array, 'z', cmap=cmap)\n    return fig, ax\n\n\nnx, ny, nz = 70, 100, 50\nr_square = (np.mgrid[-1:1:1j * nx, -1:1:1j * ny, -1:1:1j * nz] ** 2).sum(0)\n\nfigure_3D_array_slices(r_square, cmap='viridis_r')\nplt.show()\n\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: advanced\n"
    },
    {
      "filename": "lines3d.py",
      "title": "Lines3D",
      "code": "\"\"\"\n================\nParametric curve\n================\n\nThis example demonstrates plotting a parametric curve in 3D.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Prepare arrays x, y, z\ntheta = np.linspace(-4 * np.pi, 4 * np.pi, 100)\nz = np.linspace(-2, 2, 100)\nr = z**2 + 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\n\nax.plot(x, y, z, label='parametric curve')\nax.legend()\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner\n"
    },
    {
      "filename": "lorenz_attractor.py",
      "title": "Lorenz Attractor",
      "code": "\"\"\"\n================\nLorenz attractor\n================\n\nThis is an example of plotting Edward Lorenz's 1963 `\"Deterministic Nonperiodic\nFlow\"`_ in a 3-dimensional space using mplot3d.\n\n.. _\"Deterministic Nonperiodic Flow\":\n   https://journals.ametsoc.org/view/journals/atsc/20/2/1520-0469_1963_020_0130_dnf_2_0_co_2.xml\n\n.. note::\n   Because this is a simple non-linear ODE, it would be more easily done using\n   SciPy's ODE solver, but this approach depends only upon NumPy.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef lorenz(xyz, *, s=10, r=28, b=2.667):\n    \"\"\"\n    Parameters\n    ----------\n    xyz : array-like, shape (3,)\n       Point of interest in three-dimensional space.\n    s, r, b : float\n       Parameters defining the Lorenz attractor.\n\n    Returns\n    -------\n    xyz_dot : array, shape (3,)\n       Values of the Lorenz attractor's partial derivatives at *xyz*.\n    \"\"\"\n    x, y, z = xyz\n    x_dot = s*(y - x)\n    y_dot = r*x - y - x*z\n    z_dot = x*y - b*z\n    return np.array([x_dot, y_dot, z_dot])\n\n\ndt = 0.01\nnum_steps = 10000\n\nxyzs = np.empty((num_steps + 1, 3))  # Need one more for the initial values\nxyzs[0] = (0., 1., 1.05)  # Set initial values\n# Step through \"time\", calculating the partial derivatives at the current point\n# and using them to estimate the next point\nfor i in range(num_steps):\n    xyzs[i + 1] = xyzs[i] + lorenz(xyzs[i]) * dt\n\n# Plot\nax = plt.figure().add_subplot(projection='3d')\n\nax.plot(*xyzs.T, lw=0.5)\nax.set_xlabel(\"X Axis\")\nax.set_ylabel(\"Y Axis\")\nax.set_zlabel(\"Z Axis\")\nax.set_title(\"Lorenz Attractor\")\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: intermediate\n"
    },
    {
      "filename": "mixed_subplots.py",
      "title": "Mixed Subplots",
      "code": "\"\"\"\n=============================\n2D and 3D Axes in same figure\n=============================\n\nThis example shows a how to plot a 2D and a 3D plot on the same figure.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef f(t):\n    return np.cos(2*np.pi*t) * np.exp(-t)\n\n\n# Set up a figure twice as tall as it is wide\nfig = plt.figure(figsize=plt.figaspect(2.))\nfig.suptitle('A tale of 2 subplots')\n\n# First subplot\nax = fig.add_subplot(2, 1, 1)\n\nt1 = np.arange(0.0, 5.0, 0.1)\nt2 = np.arange(0.0, 5.0, 0.02)\nt3 = np.arange(0.0, 2.0, 0.01)\n\nax.plot(t1, f(t1), 'bo',\n        t2, f(t2), 'k--', markerfacecolor='green')\nax.grid(True)\nax.set_ylabel('Damped oscillation')\n\n# Second subplot\nax = fig.add_subplot(2, 1, 2, projection='3d')\n\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\nsurf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1,\n                       linewidth=0, antialiased=False)\nax.set_zlim(-1, 1)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: subplot,\n#    level: beginner\n"
    },
    {
      "filename": "offset.py",
      "title": "Offset",
      "code": "\"\"\"\n=========================\nAutomatic text offsetting\n=========================\n\nThis example demonstrates mplot3d's offset text display.\nAs one rotates the 3D figure, the offsets should remain oriented the\nsame way as the axis label, and should also be located \"away\"\nfrom the center of the plot.\n\nThis demo triggers the display of the offset text for the x- and\ny-axis by adding 1e5 to X and Y. Anything less would not\nautomatically trigger it.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\nX, Y = np.mgrid[0:6*np.pi:0.25, 0:4*np.pi:0.25]\nZ = np.sqrt(np.abs(np.cos(X) + np.cos(Y)))\n\nax.plot_surface(X + 1e5, Y + 1e5, Z, cmap='autumn', cstride=2, rstride=2)\n\nax.set_xlabel(\"X label\")\nax.set_ylabel(\"Y label\")\nax.set_zlabel(\"Z label\")\nax.set_zlim(0, 2)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: label,\n#    interactivity: pan,\n#    level: beginner\n"
    },
    {
      "filename": "pathpatch3d.py",
      "title": "Pathpatch3D",
      "code": "\"\"\"\n============================\nDraw flat objects in 3D plot\n============================\n\nDemonstrate using `.pathpatch_2d_to_3d` to 'draw' shapes and text on a 3D plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle, PathPatch\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.mplot3d.art3d as art3d\n\n\ndef text3d(ax, xyz, s, zdir=\"z\", size=None, angle=0, usetex=False, **kwargs):\n    \"\"\"\n    Plots the string *s* on the Axes *ax*, with position *xyz*, size *size*,\n    and rotation angle *angle*. *zdir* gives the axis which is to be treated as\n    the third dimension. *usetex* is a boolean indicating whether the string\n    should be run through a LaTeX subprocess or not.  Any additional keyword\n    arguments are forwarded to `.transform_path`.\n\n    Note: zdir affects the interpretation of xyz.\n    \"\"\"\n    x, y, z = xyz\n    if zdir == \"y\":\n        xy1, z1 = (x, z), y\n    elif zdir == \"x\":\n        xy1, z1 = (y, z), x\n    else:\n        xy1, z1 = (x, y), z\n\n    text_path = TextPath((0, 0), s, size=size, usetex=usetex)\n    trans = Affine2D().rotate(angle).translate(xy1[0], xy1[1])\n\n    p1 = PathPatch(trans.transform_path(text_path), **kwargs)\n    ax.add_patch(p1)\n    art3d.pathpatch_2d_to_3d(p1, z=z1, zdir=zdir)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Draw a circle on the x=0 'wall'\np = Circle((5, 5), 3)\nax.add_patch(p)\nart3d.pathpatch_2d_to_3d(p, z=0, zdir=\"x\")\n\n# Manually label the axes\ntext3d(ax, (4, -2, 0), \"X-axis\", zdir=\"z\", size=.5, usetex=False,\n       ec=\"none\", fc=\"k\")\ntext3d(ax, (12, 4, 0), \"Y-axis\", zdir=\"z\", size=.5, usetex=False,\n       angle=np.pi / 2, ec=\"none\", fc=\"k\")\ntext3d(ax, (12, 10, 4), \"Z-axis\", zdir=\"y\", size=.5, usetex=False,\n       angle=np.pi / 2, ec=\"none\", fc=\"k\")\n\n# Write a Latex formula on the z=0 'floor'\ntext3d(ax, (1, 5, 0),\n       r\"$\\displaystyle G_{\\mu\\nu} + \\Lambda g_{\\mu\\nu} = \"\n       r\"\\frac{8\\pi G}{c^4} T_{\\mu\\nu}  $\",\n       zdir=\"z\", size=1, usetex=True,\n       ec=\"none\", fc=\"k\")\n\nax.set_xlim(0, 10)\nax.set_ylim(0, 10)\nax.set_zlim(0, 10)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: label,\n#    level: advanced\n"
    },
    {
      "filename": "polys3d.py",
      "title": "Polys3D",
      "code": "\"\"\"\n====================\nGenerate 3D polygons\n====================\n\nDemonstrate how to create polygons in 3D. Here we stack 3 hexagons.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Coordinates of a hexagon\nangles = np.linspace(0, 2 * np.pi, 6, endpoint=False)\nx = np.cos(angles)\ny = np.sin(angles)\nzs = [-3, -2, -1]\n\n# Close the hexagon by repeating the first vertex\nx = np.append(x, x[0])\ny = np.append(y, y[0])\n\nverts = []\nfor z in zs:\n    verts.append(list(zip(x*z, y*z, np.full_like(x, z))))\nverts = np.array(verts)\n\nax = plt.figure().add_subplot(projection='3d')\n\npoly = Poly3DCollection(verts, alpha=.7)\nax.add_collection3d(poly)\nax.set_aspect('equalxy')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    styling: colormap,\n#    level: intermediate\n"
    },
    {
      "filename": "projections.py",
      "title": "Projections",
      "code": "\"\"\"\n========================\n3D plot projection types\n========================\n\nDemonstrates the different camera projections for 3D plots, and the effects of\nchanging the focal length for a perspective projection. Note that Matplotlib\ncorrects for the 'zoom' effect of changing the focal length.\n\nThe default focal length of 1 corresponds to a Field of View (FOV) of 90 deg.\nAn increased focal length between 1 and infinity \"flattens\" the image, while a\ndecreased focal length between 1 and 0 exaggerates the perspective and gives\nthe image more apparent depth. In the limiting case, a focal length of\ninfinity corresponds to an orthographic projection after correction of the\nzoom effect.\n\nYou can calculate focal length from a FOV via the equation:\n\n.. math::\n\n    1 / \\\\tan (\\\\mathrm{FOV} / 2)\n\nOr vice versa:\n\n.. math::\n\n    \\\\mathrm{FOV} = 2 \\\\arctan (1 / \\\\mathrm{focal length})\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig, axs = plt.subplots(1, 3, subplot_kw={'projection': '3d'})\n\n# Get the test data\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the data\nfor ax in axs:\n    ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n# Set the orthographic projection.\naxs[0].set_proj_type('ortho')  # FOV = 0 deg\naxs[0].set_title(\"'ortho'\\nfocal_length = \u221e\", fontsize=10)\n\n# Set the perspective projections\naxs[1].set_proj_type('persp')  # FOV = 90 deg\naxs[1].set_title(\"'persp'\\nfocal_length = 1 (default)\", fontsize=10)\n\naxs[2].set_proj_type('persp', focal_length=0.2)  # FOV = 157.4 deg\naxs[2].set_title(\"'persp'\\nfocal_length = 0.2\", fontsize=10)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    styling: small-multiples,\n#    component: subplot,\n#    level: intermediate\n"
    },
    {
      "filename": "quiver3d.py",
      "title": "Quiver3D",
      "code": "\"\"\"\n==============\n3D quiver plot\n==============\n\nDemonstrates plotting directional arrows at points on a 3D meshgrid.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Make the grid\nx, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.8))\n\n# Make the direction data for the arrows\nu = np.sin(np.pi * x) * np.cos(np.pi * y) * np.cos(np.pi * z)\nv = -np.cos(np.pi * x) * np.sin(np.pi * y) * np.cos(np.pi * z)\nw = (np.sqrt(2.0 / 3.0) * np.cos(np.pi * x) * np.cos(np.pi * y) *\n     np.sin(np.pi * z))\n\nax.quiver(x, y, z, u, v, w, length=0.1, normalize=True)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner\n"
    },
    {
      "filename": "rotate_axes3d_sgskip.py",
      "title": "Rotate Axes3D Sgskip",
      "code": "\"\"\"\n==================\nRotating a 3D plot\n==================\n\nA very simple animation of a rotating 3D plot about all three axes.\n\nSee :doc:`wire3d_animation_sgskip` for another example of animating a 3D plot.\n\n(This example is skipped when building the documentation gallery because it\nintentionally takes a long time to run)\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Grab some example data and plot a basic wireframe.\nX, Y, Z = axes3d.get_test_data(0.05)\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n# Set the axis labels\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\n\n# Rotate the axes and update\nfor angle in range(0, 360*4 + 1):\n    # Normalize the angle to the range [-180, 180] for display\n    angle_norm = (angle + 180) % 360 - 180\n\n    # Cycle through a full rotation of elevation, then azimuth, roll, and all\n    elev = azim = roll = 0\n    if angle <= 360:\n        elev = angle_norm\n    elif angle <= 360*2:\n        azim = angle_norm\n    elif angle <= 360*3:\n        roll = angle_norm\n    else:\n        elev = azim = roll = angle_norm\n\n    # Update the axis view and title\n    ax.view_init(elev, azim, roll)\n    plt.title('Elevation: %d\u00b0, Azimuth: %d\u00b0, Roll: %d\u00b0' % (elev, azim, roll))\n\n    plt.draw()\n    plt.pause(.001)\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: animation,\n#    level: advanced,\n#    internal: high-bandwidth\n"
    },
    {
      "filename": "scatter3d.py",
      "title": "Scatter3D",
      "code": "\"\"\"\n==============\n3D scatterplot\n==============\n\nDemonstration of a basic scatterplot in 3D.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef randrange(n, vmin, vmax):\n    \"\"\"\n    Helper function to make an array of random numbers having shape (n, )\n    with each number distributed Uniform(vmin, vmax).\n    \"\"\"\n    return (vmax - vmin)*np.random.rand(n) + vmin\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\nn = 100\n\n# For each set of style and range settings, plot n random points in the box\n# defined by x in [23, 32], y in [0, 100], z in [zlow, zhigh].\nfor m, zlow, zhigh in [('o', -50, -25), ('^', -30, -5)]:\n    xs = randrange(n, 23, 32)\n    ys = randrange(n, 0, 100)\n    zs = randrange(n, zlow, zhigh)\n    ax.scatter(xs, ys, zs, marker=m)\n\nax.set_xlabel('X Label')\nax.set_ylabel('Y Label')\nax.set_zlabel('Z Label')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: scatter,\n#    level: beginner\n"
    },
    {
      "filename": "stem3d_demo.py",
      "title": "Stem3D Demo",
      "code": "\"\"\"\n=======\n3D stem\n=======\n\nDemonstration of a stem plot in 3D, which plots vertical lines from a baseline\nto the *z*-coordinate and places a marker at the tip.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ntheta = np.linspace(0, 2*np.pi)\nx = np.cos(theta - np.pi/2)\ny = np.sin(theta - np.pi/2)\nz = theta\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nax.stem(x, y, z)\n\nplt.show()\n\n# %%\n#\n# The position of the baseline can be adapted using *bottom*. The parameters\n# *linefmt*, *markerfmt*, and *basefmt* control basic format properties of the\n# plot. However, in contrast to `~.axes3d.Axes3D.plot` not all properties are\n# configurable via keyword arguments. For more advanced control adapt the line\n# objects returned by `~mpl_toolkits.mplot3d.axes3d.Axes3D.stem`.\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nmarkerline, stemlines, baseline = ax.stem(\n    x, y, z, linefmt='grey', markerfmt='D', bottom=np.pi)\nmarkerline.set_markerfacecolor('none')\n\nplt.show()\n\n# %%\n#\n# The orientation of the stems and baseline can be changed using *orientation*.\n# This determines in which direction the stems are projected from the head\n# points, towards the *bottom* baseline.\n#\n# For examples, by setting ``orientation='x'``, the stems are projected along\n# the *x*-direction, and the baseline is in the *yz*-plane.\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nmarkerline, stemlines, baseline = ax.stem(x, y, z, bottom=-1, orientation='x')\nax.set(xlabel='x', ylabel='y', zlabel='z')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: speciality,\n#    level: beginner\n"
    },
    {
      "filename": "subplot3d.py",
      "title": "Subplot3D",
      "code": "\"\"\"\n====================\n3D plots as subplots\n====================\n\nDemonstrate including 3D plots as subplots.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d.axes3d import get_test_data\n\n# set up a figure twice as wide as it is tall\nfig = plt.figure(figsize=plt.figaspect(0.5))\n\n# =============\n# First subplot\n# =============\n# set up the Axes for the first plot\nax = fig.add_subplot(1, 2, 1, projection='3d')\n\n# plot a 3D surface like in the example mplot3d/surface3d_demo\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\nsurf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\nax.set_zlim(-1.01, 1.01)\nfig.colorbar(surf, shrink=0.5, aspect=10)\n\n# ==============\n# Second subplot\n# ==============\n# set up the Axes for the second plot\nax = fig.add_subplot(1, 2, 2, projection='3d')\n\n# plot a 3D wireframe like in the example mplot3d/wire3d_demo\nX, Y, Z = get_test_data(0.05)\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: subplot,\n#    level: advanced\n"
    },
    {
      "filename": "surface3d.py",
      "title": "Surface3D",
      "code": "\"\"\"\n=====================\n3D surface (colormap)\n=====================\n\nDemonstrates plotting a 3D surface colored with the coolwarm colormap.\nThe surface is made opaque by using ``antialiased=False``.\n\nAlso demonstrates using the `.LinearLocator` and custom formatting for the\nz axis tick labels.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom matplotlib.ticker import LinearLocator\n\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Plot the surface.\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\n\n# Customize the z axis.\nax.set_zlim(-1.01, 1.01)\nax.zaxis.set_major_locator(LinearLocator(10))\n# A StrMethodFormatter is used automatically\nax.zaxis.set_major_formatter('{x:.02f}')\n\n# Add a color bar which maps values to colors.\nfig.colorbar(surf, shrink=0.5, aspect=5)\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.ticker.LinearLocator`\n#    - `matplotlib.ticker.StrMethodFormatter`\n#\n# .. tags::\n#    plot-type: 3D,\n#    styling: colormap,\n#    level: advanced\n"
    },
    {
      "filename": "surface3d_2.py",
      "title": "Surface3D 2",
      "code": "\"\"\"\n========================\n3D surface (solid color)\n========================\n\nDemonstrates a very basic plot of a 3D surface using a solid color.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Make data\nu = np.linspace(0, 2 * np.pi, 100)\nv = np.linspace(0, np.pi, 100)\nx = 10 * np.outer(np.cos(u), np.sin(v))\ny = 10 * np.outer(np.sin(u), np.sin(v))\nz = 10 * np.outer(np.ones(np.size(u)), np.cos(v))\n\n# Plot the surface\nax.plot_surface(x, y, z)\n\n# Set an equal aspect ratio\nax.set_aspect('equal')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner\n"
    },
    {
      "filename": "surface3d_3.py",
      "title": "Surface3D 3",
      "code": "\"\"\"\n=========================\n3D surface (checkerboard)\n=========================\n\nDemonstrates plotting a 3D surface colored in a checkerboard pattern.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import LinearLocator\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nxlen = len(X)\nY = np.arange(-5, 5, 0.25)\nylen = len(Y)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Create an empty array of strings with the same shape as the meshgrid, and\n# populate it with two colors in a checkerboard pattern.\ncolortuple = ('y', 'b')\ncolors = np.empty(X.shape, dtype=str)\nfor y in range(ylen):\n    for x in range(xlen):\n        colors[y, x] = colortuple[(x + y) % len(colortuple)]\n\n# Plot the surface with face colors taken from the array we made.\nsurf = ax.plot_surface(X, Y, Z, facecolors=colors, linewidth=0)\n\n# Customize the z axis.\nax.set_zlim(-1, 1)\nax.zaxis.set_major_locator(LinearLocator(6))\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    styling: color, styling: texture,\n#    level: intermediate\n"
    },
    {
      "filename": "surface3d_radial.py",
      "title": "Surface3D Radial",
      "code": "\"\"\"\n=================================\n3D surface with polar coordinates\n=================================\n\nDemonstrates plotting a surface defined in polar coordinates.\nUses the reversed version of the YlGnBu colormap.\nAlso demonstrates writing axis labels with latex math mode.\n\nExample contributed by Armin Moser.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Create the mesh in polar coordinates and compute corresponding Z.\nr = np.linspace(0, 1.25, 50)\np = np.linspace(0, 2*np.pi, 50)\nR, P = np.meshgrid(r, p)\nZ = ((R**2 - 1)**2)\n\n# Express the mesh in the cartesian system.\nX, Y = R*np.cos(P), R*np.sin(P)\n\n# Plot the surface.\nax.plot_surface(X, Y, Z, cmap=plt.cm.YlGnBu_r)\n\n# Tweak the limits and add latex math labels.\nax.set_zlim(0, 1)\nax.set_xlabel(r'$\\phi_\\mathrm{real}$')\nax.set_ylabel(r'$\\phi_\\mathrm{im}$')\nax.set_zlabel(r'$V(\\phi)$')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: polar,\n#    level: beginner\n"
    },
    {
      "filename": "text3d.py",
      "title": "Text3D",
      "code": "\"\"\"\n======================\nText annotations in 3D\n======================\n\nDemonstrates the placement of text annotations on a 3D plot.\n\nFunctionality shown:\n\n- Using the `~.Axes3D.text` function with three types of *zdir* values: None,\n  an axis name (ex. 'x'), or a direction tuple (ex. (1, 1, 0)).\n- Using the `~.Axes3D.text` function with the color keyword.\n- Using the `.text2D` function to place text on a fixed position on the ax\n  object.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Demo 1: zdir\nzdirs = (None, 'x', 'y', 'z', (1, 1, 0), (1, 1, 1))\nxs = (1, 4, 4, 9, 4, 1)\nys = (2, 5, 8, 10, 1, 2)\nzs = (10, 3, 8, 9, 1, 8)\n\nfor zdir, x, y, z in zip(zdirs, xs, ys, zs):\n    label = '(%d, %d, %d), dir=%s' % (x, y, z, zdir)\n    ax.text(x, y, z, label, zdir)\n\n# Demo 2: color\nax.text(9, 0, 0, \"red\", color='red')\n\n# Demo 3: text2D\n# Placement 0, 0 would be the bottom left, 1, 1 would be the top right.\nax.text2D(0.05, 0.95, \"2D Text\", transform=ax.transAxes)\n\n# Tweaking display region and labels\nax.set_xlim(0, 10)\nax.set_ylim(0, 10)\nax.set_zlim(0, 10)\nax.set_xlabel('X axis')\nax.set_ylabel('Y axis')\nax.set_zlabel('Z axis')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: annotation,\n#    level: beginner\n"
    },
    {
      "filename": "tricontour3d.py",
      "title": "Tricontour3D",
      "code": "\"\"\"\n==========================\nTriangular 3D contour plot\n==========================\n\nContour plots of unstructured triangular grids.\n\nThe data used is the same as in the second plot of :doc:`trisurf3d_2`.\n:doc:`tricontourf3d` shows the filled version of this example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\n\n# Create the mesh in polar coordinates and compute x, y, z.\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create a custom triangulation.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\nax = plt.figure().add_subplot(projection='3d')\nax.tricontour(triang, z, cmap=plt.cm.CMRmap)\n\n# Customize the view angle so it's easier to understand the plot.\nax.view_init(elev=45.)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: specialty,\n#    level: intermediate\n"
    },
    {
      "filename": "tricontourf3d.py",
      "title": "Tricontourf3D",
      "code": "\"\"\"\n=================================\nTriangular 3D filled contour plot\n=================================\n\nFilled contour plots of unstructured triangular grids.\n\nThe data used is the same as in the second plot of :doc:`trisurf3d_2`.\n:doc:`tricontour3d` shows the unfilled version of this example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# First create the x, y, z coordinates of the points.\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\n\n# Create the mesh in polar coordinates and compute x, y, z.\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create a custom triangulation.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\nax = plt.figure().add_subplot(projection='3d')\nax.tricontourf(triang, z, cmap=plt.cm.CMRmap)\n\n# Customize the view angle so it's easier to understand the plot.\nax.view_init(elev=45.)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: specialty,\n#    level: intermediate\n"
    },
    {
      "filename": "trisurf3d.py",
      "title": "Trisurf3D",
      "code": "\"\"\"\n======================\nTriangular 3D surfaces\n======================\n\nPlot a 3D surface with a triangular mesh.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nn_radii = 8\nn_angles = 36\n\n# Make radii and angles spaces (radius r=0 omitted to eliminate duplication).\nradii = np.linspace(0.125, 1.0, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)[..., np.newaxis]\n\n# Convert polar (radii, angles) coords to cartesian (x, y) coords.\n# (0, 0) is manually added at this stage,  so there will be no duplicate\n# points in the (x, y) plane.\nx = np.append(0, (radii*np.cos(angles)).flatten())\ny = np.append(0, (radii*np.sin(angles)).flatten())\n\n# Compute z to make the pringle surface.\nz = np.sin(-x*y)\n\nax = plt.figure().add_subplot(projection='3d')\n\nax.plot_trisurf(x, y, z, linewidth=0.2, antialiased=True)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: intermediate\n"
    },
    {
      "filename": "trisurf3d_2.py",
      "title": "Trisurf3D 2",
      "code": "\"\"\"\n===========================\nMore triangular 3D surfaces\n===========================\n\nTwo additional examples of plotting surfaces with triangular mesh.\n\nThe first demonstrates use of plot_trisurf's triangles argument, and the\nsecond sets a `.Triangulation` object's mask and passes the object directly\nto plot_trisurf.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as mtri\n\nfig = plt.figure(figsize=plt.figaspect(0.5))\n\n# ==========\n# First plot\n# ==========\n\n# Make a mesh in the space of parameterisation variables u and v\nu = np.linspace(0, 2.0 * np.pi, endpoint=True, num=50)\nv = np.linspace(-0.5, 0.5, endpoint=True, num=10)\nu, v = np.meshgrid(u, v)\nu, v = u.flatten(), v.flatten()\n\n# This is the Mobius mapping, taking a u, v pair and returning an x, y, z\n# triple\nx = (1 + 0.5 * v * np.cos(u / 2.0)) * np.cos(u)\ny = (1 + 0.5 * v * np.cos(u / 2.0)) * np.sin(u)\nz = 0.5 * v * np.sin(u / 2.0)\n\n# Triangulate parameter space to determine the triangles\ntri = mtri.Triangulation(u, v)\n\n# Plot the surface.  The triangles in parameter space determine which x, y, z\n# points are connected by an edge.\nax = fig.add_subplot(1, 2, 1, projection='3d')\nax.plot_trisurf(x, y, z, triangles=tri.triangles, cmap=plt.cm.Spectral)\nax.set_zlim(-1, 1)\n\n\n# ===========\n# Second plot\n# ===========\n\n# Make parameter spaces radii and angles.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\n# Map radius, angle pairs to x, y, z points.\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = mtri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\nxmid = x[triang.triangles].mean(axis=1)\nymid = y[triang.triangles].mean(axis=1)\nmask = xmid**2 + ymid**2 < min_radius**2\ntriang.set_mask(mask)\n\n# Plot the surface.\nax = fig.add_subplot(1, 2, 2, projection='3d')\nax.plot_trisurf(triang, z, cmap=plt.cm.CMRmap)\n\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D, plot-type: specialty,\n#    level: intermediate\n"
    },
    {
      "filename": "view_planes_3d.py",
      "title": "View Planes 3D",
      "code": "\"\"\"\n======================\nPrimary 3D view planes\n======================\n\nThis example generates an \"unfolded\" 3D plot that shows each of the primary 3D\nview planes. The elevation, azimuth, and roll angles required for each view are\nlabeled. You could print out this image and fold it into a box where each plane\nforms a side of the box.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef annotate_axes(ax, text, fontsize=18):\n    ax.text(x=0.5, y=0.5, z=0.5, s=text,\n            va=\"center\", ha=\"center\", fontsize=fontsize, color=\"black\")\n\n# (plane, (elev, azim, roll))\nviews = [('XY',   (90, -90, 0)),\n         ('XZ',    (0, -90, 0)),\n         ('YZ',    (0,   0, 0)),\n         ('-XY', (-90,  90, 0)),\n         ('-XZ',   (0,  90, 0)),\n         ('-YZ',   (0, 180, 0))]\n\nlayout = [['XY',  '.',   'L',   '.'],\n          ['XZ', 'YZ', '-XZ', '-YZ'],\n          ['.',   '.', '-XY',   '.']]\nfig, axd = plt.subplot_mosaic(layout, subplot_kw={'projection': '3d'},\n                              figsize=(12, 8.5))\nfor plane, angles in views:\n    axd[plane].set_xlabel('x')\n    axd[plane].set_ylabel('y')\n    axd[plane].set_zlabel('z')\n    axd[plane].set_proj_type('ortho')\n    axd[plane].view_init(elev=angles[0], azim=angles[1], roll=angles[2])\n    axd[plane].set_box_aspect(None, zoom=1.25)\n\n    label = f'{plane}\\n{angles}'\n    annotate_axes(axd[plane], label, fontsize=14)\n\nfor plane in ('XY', '-XY'):\n    axd[plane].set_zticklabels([])\n    axd[plane].set_zlabel('')\nfor plane in ('XZ', '-XZ'):\n    axd[plane].set_yticklabels([])\n    axd[plane].set_ylabel('')\nfor plane in ('YZ', '-YZ'):\n    axd[plane].set_xticklabels([])\n    axd[plane].set_xlabel('')\n\nlabel = 'mplot3d primary view planes\\n' + 'ax.view_init(elev, azim, roll)'\nannotate_axes(axd['L'], label, fontsize=18)\naxd['L'].set_axis_off()\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: axes, component: subplot,\n#    level: beginner\n"
    },
    {
      "filename": "voxels.py",
      "title": "Voxels",
      "code": "\"\"\"\n==========================\n3D voxel / volumetric plot\n==========================\n\nDemonstrates plotting 3D volumetric objects with `.Axes3D.voxels`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# prepare some coordinates\nx, y, z = np.indices((8, 8, 8))\n\n# draw cuboids in the top left and bottom right corners, and a link between\n# them\ncube1 = (x < 3) & (y < 3) & (z < 3)\ncube2 = (x >= 5) & (y >= 5) & (z >= 5)\nlink = abs(x - y) + abs(y - z) + abs(z - x) <= 2\n\n# combine the objects into a single boolean array\nvoxelarray = cube1 | cube2 | link\n\n# set the colors of each object\ncolors = np.empty(voxelarray.shape, dtype=object)\ncolors[link] = 'red'\ncolors[cube1] = 'blue'\ncolors[cube2] = 'green'\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(voxelarray, facecolors=colors, edgecolor='k')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner\n"
    },
    {
      "filename": "voxels_numpy_logo.py",
      "title": "Voxels Numpy Logo",
      "code": "\"\"\"\n===============================\n3D voxel plot of the NumPy logo\n===============================\n\nDemonstrates using `.Axes3D.voxels` with uneven coordinates.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef explode(data):\n    size = np.array(data.shape)*2\n    data_e = np.zeros(size - 1, dtype=data.dtype)\n    data_e[::2, ::2, ::2] = data\n    return data_e\n\n# build up the numpy logo\nn_voxels = np.zeros((4, 3, 4), dtype=bool)\nn_voxels[0, 0, :] = True\nn_voxels[-1, 0, :] = True\nn_voxels[1, 0, 2] = True\nn_voxels[2, 0, 1] = True\nfacecolors = np.where(n_voxels, '#FFD65DC0', '#7A88CCC0')\nedgecolors = np.where(n_voxels, '#BFAB6E', '#7D84A6')\nfilled = np.ones(n_voxels.shape)\n\n# upscale the above voxel image, leaving gaps\nfilled_2 = explode(filled)\nfcolors_2 = explode(facecolors)\necolors_2 = explode(edgecolors)\n\n# Shrink the gaps\nx, y, z = np.indices(np.array(filled_2.shape) + 1).astype(float) // 2\nx[0::2, :, :] += 0.05\ny[:, 0::2, :] += 0.05\nz[:, :, 0::2] += 0.05\nx[1::2, :, :] += 0.95\ny[:, 1::2, :] += 0.95\nz[:, :, 1::2] += 0.95\n\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(x, y, z, filled_2, facecolors=fcolors_2, edgecolors=ecolors_2)\nax.set_aspect('equal')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner,\n#    purpose: fun\n"
    },
    {
      "filename": "voxels_rgb.py",
      "title": "Voxels Rgb",
      "code": "\"\"\"\n==========================================\n3D voxel / volumetric plot with RGB colors\n==========================================\n\nDemonstrates using `.Axes3D.voxels` to visualize parts of a color space.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef midpoints(x):\n    sl = ()\n    for _ in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, g, b = np.indices((17, 17, 17)) / 16.0\nrc = midpoints(r)\ngc = midpoints(g)\nbc = midpoints(b)\n\n# define a sphere about [0.5, 0.5, 0.5]\nsphere = (rc - 0.5)**2 + (gc - 0.5)**2 + (bc - 0.5)**2 < 0.5**2\n\n# combine the color components\ncolors = np.zeros(sphere.shape + (3,))\ncolors[..., 0] = rc\ncolors[..., 1] = gc\ncolors[..., 2] = bc\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(r, g, b, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter\n          linewidth=0.5)\nax.set(xlabel='r', ylabel='g', zlabel='b')\nax.set_aspect('equal')\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    styling: color\n"
    },
    {
      "filename": "voxels_torus.py",
      "title": "Voxels Torus",
      "code": "\"\"\"\n=======================================================\n3D voxel / volumetric plot with cylindrical coordinates\n=======================================================\n\nDemonstrates using the *x*, *y*, *z* parameters of `.Axes3D.voxels`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors\n\n\ndef midpoints(x):\n    sl = ()\n    for i in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, theta, z = np.mgrid[0:1:11j, 0:np.pi*2:25j, -0.5:0.5:11j]\nx = r*np.cos(theta)\ny = r*np.sin(theta)\n\nrc, thetac, zc = midpoints(r), midpoints(theta), midpoints(z)\n\n# define a wobbly torus about [0.7, *, 0]\nsphere = (rc - 0.7)**2 + (zc + 0.2*np.cos(thetac*2))**2 < 0.2**2\n\n# combine the color components\nhsv = np.zeros(sphere.shape + (3,))\nhsv[..., 0] = thetac / (np.pi*2)\nhsv[..., 1] = rc\nhsv[..., 2] = zc + 0.5\ncolors = matplotlib.colors.hsv_to_rgb(hsv)\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(x, y, z, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter\n          linewidth=0.5)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    styling: color,\n#    level: intermediate\n"
    },
    {
      "filename": "wire3d.py",
      "title": "Wire3D",
      "code": "\"\"\"\n=================\n3D wireframe plot\n=================\n\nA very basic demonstration of a wireframe plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Grab some test data.\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot a basic wireframe.\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: beginner\n"
    },
    {
      "filename": "wire3d_animation_sgskip.py",
      "title": "Wire3D Animation Sgskip",
      "code": "\"\"\"\n===========================\nAnimate a 3D wireframe plot\n===========================\n\nA very simple \"animation\" of a 3D plot.  See also :doc:`rotate_axes3d_sgskip`.\n\n(This example is skipped when building the documentation gallery because it\nintentionally takes a long time to run.)\n\"\"\"\n\nimport time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Make the X, Y meshgrid.\nxs = np.linspace(-1, 1, 50)\nys = np.linspace(-1, 1, 50)\nX, Y = np.meshgrid(xs, ys)\n\n# Set the z axis limits, so they aren't recalculated each frame.\nax.set_zlim(-1, 1)\n\n# Begin plotting.\nwframe = None\ntstart = time.time()\nfor phi in np.linspace(0, 180. / np.pi, 100):\n    # If a line collection is already remove it before drawing.\n    if wframe:\n        wframe.remove()\n    # Generate data.\n    Z = np.cos(2 * np.pi * X + phi) * (1 - np.hypot(X, Y))\n    # Plot the new wireframe and pause briefly before continuing.\n    wframe = ax.plot_wireframe(X, Y, Z, rstride=2, cstride=2)\n    plt.pause(.001)\n\nprint('Average FPS: %f' % (100 / (time.time() - tstart)))\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    component: animation,\n#    level: beginner\n"
    },
    {
      "filename": "wire3d_zero_stride.py",
      "title": "Wire3D Zero Stride",
      "code": "\"\"\"\n===================================\n3D wireframe plots in one direction\n===================================\n\nDemonstrates that setting *rstride* or *cstride* to 0 causes wires to not be\ngenerated in the corresponding direction.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig, (ax1, ax2) = plt.subplots(\n    2, 1, figsize=(8, 12), subplot_kw={'projection': '3d'})\n\n# Get the test data\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Give the first plot only wireframes of the type y = c\nax1.plot_wireframe(X, Y, Z, rstride=10, cstride=0)\nax1.set_title(\"Column (x) stride set to 0\")\n\n# Give the second plot only wireframes of the type x = c\nax2.plot_wireframe(X, Y, Z, rstride=0, cstride=10)\nax2.set_title(\"Row (y) stride set to 0\")\n\nplt.tight_layout()\nplt.show()\n\n# %%\n# .. tags::\n#    plot-type: 3D,\n#    level: intermediate\n"
    }
  ],
  "pie_and_polar_charts": [
    {
      "filename": "bar_of_pie.py",
      "title": "Bar Of Pie",
      "code": "\"\"\"\n==========\nBar of pie\n==========\n\nMake a \"bar of pie\" chart where the first slice of the pie is\n\"exploded\" into a bar chart with a further breakdown of said slice's\ncharacteristics. The example demonstrates using a figure with multiple\nsets of Axes and using the Axes patches list to add two ConnectionPatches\nto link the subplot charts.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import ConnectionPatch\n\n# make figure and assign axis objects\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 5))\nfig.subplots_adjust(wspace=0)\n\n# pie chart parameters\noverall_ratios = [.27, .56, .17]\nlabels = ['Approve', 'Disapprove', 'Undecided']\nexplode = [0.1, 0, 0]\n# rotate so that first wedge is split by the x-axis\nangle = -180 * overall_ratios[0]\nwedges, *_ = ax1.pie(overall_ratios, autopct='%1.1f%%', startangle=angle,\n                     labels=labels, explode=explode)\n\n# bar chart parameters\nage_ratios = [.33, .54, .07, .06]\nage_labels = ['Under 35', '35-49', '50-65', 'Over 65']\nbottom = 1\nwidth = .2\n\n# Adding from the top matches the legend.\nfor j, (height, label) in enumerate(reversed([*zip(age_ratios, age_labels)])):\n    bottom -= height\n    bc = ax2.bar(0, height, width, bottom=bottom, color='C0', label=label,\n                 alpha=0.1 + 0.25 * j)\n    ax2.bar_label(bc, labels=[f\"{height:.0%}\"], label_type='center')\n\nax2.set_title('Age of approvers')\nax2.legend()\nax2.axis('off')\nax2.set_xlim(- 2.5 * width, 2.5 * width)\n\n# use ConnectionPatch to draw lines between the two plots\ntheta1, theta2 = wedges[0].theta1, wedges[0].theta2\ncenter, r = wedges[0].center, wedges[0].r\nbar_height = sum(age_ratios)\n\n# draw top connecting line\nx = r * np.cos(np.pi / 180 * theta2) + center[0]\ny = r * np.sin(np.pi / 180 * theta2) + center[1]\ncon = ConnectionPatch(xyA=(-width / 2, bar_height), coordsA=ax2.transData,\n                      xyB=(x, y), coordsB=ax1.transData)\ncon.set_color([0, 0, 0])\ncon.set_linewidth(4)\nax2.add_artist(con)\n\n# draw bottom connecting line\nx = r * np.cos(np.pi / 180 * theta1) + center[0]\ny = r * np.sin(np.pi / 180 * theta1) + center[1]\ncon = ConnectionPatch(xyA=(-width / 2, 0), coordsA=ax2.transData,\n                      xyB=(x, y), coordsB=ax1.transData)\ncon.set_color([0, 0, 0])\nax2.add_artist(con)\ncon.set_linewidth(4)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.axes.Axes.pie` / `matplotlib.pyplot.pie`\n#    - `matplotlib.patches.ConnectionPatch`\n#\n# .. tags::\n#\n#    component: subplot\n#    plot-type: pie\n#    plot-type: bar\n#    level: intermediate\n#    purpose: showcase\n"
    },
    {
      "filename": "nested_pie.py",
      "title": "Nested Pie",
      "code": "\"\"\"\n=================\nNested pie charts\n=================\n\nThe following examples show two ways to build a nested pie chart\nin Matplotlib. Such charts are often referred to as donut charts.\n\nSee also the :doc:`/gallery/specialty_plots/leftventricle_bullseye` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n# The most straightforward way to build a pie chart is to use the\n# `~matplotlib.axes.Axes.pie` method.\n#\n# In this case, pie takes values corresponding to counts in a group.\n# We'll first generate some fake data, corresponding to three groups.\n# In the inner circle, we'll treat each number as belonging to its\n# own group. In the outer circle, we'll plot them as members of their\n# original 3 groups.\n#\n# The effect of the donut shape is achieved by setting a ``width`` to\n# the pie's wedges through the *wedgeprops* argument.\n\n\nfig, ax = plt.subplots()\n\nsize = 0.3\nvals = np.array([[60., 32.], [37., 40.], [29., 10.]])\n\ntab20c = plt.color_sequences[\"tab20c\"]\nouter_colors = [tab20c[i] for i in [0, 4, 8]]\ninner_colors = [tab20c[i] for i in [1, 2, 5, 6, 9, 10]]\n\nax.pie(vals.sum(axis=1), radius=1, colors=outer_colors,\n       wedgeprops=dict(width=size, edgecolor='w'))\n\nax.pie(vals.flatten(), radius=1-size, colors=inner_colors,\n       wedgeprops=dict(width=size, edgecolor='w'))\n\nax.set(aspect=\"equal\", title='Pie plot with `ax.pie`')\nplt.show()\n\n# %%\n# However, you can accomplish the same output by using a bar plot on\n# Axes with a polar coordinate system. This may give more flexibility on\n# the exact design of the plot.\n#\n# In this case, we need to map x-values of the bar chart onto radians of\n# a circle. The cumulative sum of the values are used as the edges\n# of the bars.\n\nfig, ax = plt.subplots(subplot_kw=dict(projection=\"polar\"))\n\nsize = 0.3\nvals = np.array([[60., 32.], [37., 40.], [29., 10.]])\n# Normalize vals to 2 pi\nvalsnorm = vals/np.sum(vals)*2*np.pi\n# Obtain the ordinates of the bar edges\nvalsleft = np.cumsum(np.append(0, valsnorm.flatten()[:-1])).reshape(vals.shape)\n\ncmap = plt.colormaps[\"tab20c\"]\nouter_colors = cmap(np.arange(3)*4)\ninner_colors = cmap([1, 2, 5, 6, 9, 10])\n\nax.bar(x=valsleft[:, 0],\n       width=valsnorm.sum(axis=1), bottom=1-size, height=size,\n       color=outer_colors, edgecolor='w', linewidth=1, align=\"edge\")\n\nax.bar(x=valsleft.flatten(),\n       width=valsnorm.flatten(), bottom=1-2*size, height=size,\n       color=inner_colors, edgecolor='w', linewidth=1, align=\"edge\")\n\nax.set(title=\"Pie plot with `ax.bar` and polar coordinates\")\nax.set_axis_off()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pie` / `matplotlib.pyplot.pie`\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.projections.polar`\n#    - ``Axes.set`` (`matplotlib.artist.Artist.set`)\n#    - `matplotlib.axes.Axes.set_axis_off`\n#\n# .. tags::\n#\n#    plot-type: pie\n#    level: beginner\n#    purpose: showcase\n"
    },
    {
      "filename": "pie_and_donut_labels.py",
      "title": "Pie And Donut Labels",
      "code": "\"\"\"\n=============================\nA pie and a donut with labels\n=============================\n\nWelcome to the Matplotlib bakery. We will create a pie and a donut\nchart through the `pie method <matplotlib.axes.Axes.pie>` and\nshow how to label them with a `legend <matplotlib.axes.Axes.legend>`\nas well as with `annotations <matplotlib.axes.Axes.annotate>`.\n\"\"\"\n\n# %%\n# As usual we would start by defining the imports and create a figure with\n# subplots.\n# Now it's time for the pie. Starting with a pie recipe, we create the data\n# and a list of labels from it.\n#\n# We can provide a function to the ``autopct`` argument, which will expand\n# automatic percentage labeling by showing absolute values; we calculate\n# the latter back from relative data and the known sum of all values.\n#\n# We then create the pie and store the returned objects for later.  The first\n# returned element of the returned tuple is a list of the wedges.  Those are\n# `matplotlib.patches.Wedge` patches, which can directly be used as the handles\n# for a legend. We can use the legend's ``bbox_to_anchor`` argument to position\n# the legend outside of the pie. Here we use the axes coordinates ``(1, 0, 0.5,\n# 1)`` together with the location ``\"center left\"``; i.e. the left central\n# point of the legend will be at the left central point of the bounding box,\n# spanning from ``(1, 0)`` to ``(1.5, 1)`` in axes coordinates.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(figsize=(6, 3), subplot_kw=dict(aspect=\"equal\"))\n\nrecipe = [\"375 g flour\",\n          \"75 g sugar\",\n          \"250 g butter\",\n          \"300 g berries\"]\n\ndata = [float(x.split()[0]) for x in recipe]\ningredients = [x.split()[-1] for x in recipe]\n\n\ndef func(pct, allvals):\n    absolute = int(np.round(pct/100.*np.sum(allvals)))\n    return f\"{pct:.1f}%\\n({absolute:d} g)\"\n\n\nwedges, texts, autotexts = ax.pie(data, autopct=lambda pct: func(pct, data),\n                                  textprops=dict(color=\"w\"))\n\nax.legend(wedges, ingredients,\n          title=\"Ingredients\",\n          loc=\"center left\",\n          bbox_to_anchor=(1, 0, 0.5, 1))\n\nplt.setp(autotexts, size=8, weight=\"bold\")\n\nax.set_title(\"Matplotlib bakery: A pie\")\n\nplt.show()\n\n\n# %%\n# Now it's time for the donut. Starting with a donut recipe, we transcribe\n# the data to numbers (converting 1 egg to 50 g), and directly plot the pie.\n# The pie? Wait... it's going to be donut, is it not?\n# Well, as we see here, the donut is a pie, having a certain ``width`` set to\n# the wedges, which is different from its radius. It's as easy as it gets.\n# This is done via the ``wedgeprops`` argument.\n#\n# We then want to label the wedges via\n# `annotations <matplotlib.axes.Axes.annotate>`. We first create some\n# dictionaries of common properties, which we can later pass as keyword\n# argument. We then iterate over all wedges and for each\n#\n# * calculate the angle of the wedge's center,\n# * from that obtain the coordinates of the point at that angle on the\n#   circumference,\n# * determine the horizontal alignment of the text, depending on which side\n#   of the circle the point lies,\n# * update the connection style with the obtained angle to have the annotation\n#   arrow point outwards from the donut,\n# * finally, create the annotation with all the previously\n#   determined parameters.\n\n\nfig, ax = plt.subplots(figsize=(6, 3), subplot_kw=dict(aspect=\"equal\"))\n\nrecipe = [\"225 g flour\",\n          \"90 g sugar\",\n          \"1 egg\",\n          \"60 g butter\",\n          \"100 ml milk\",\n          \"1/2 package of yeast\"]\n\ndata = [225, 90, 50, 60, 100, 5]\n\nwedges, texts = ax.pie(data, wedgeprops=dict(width=0.5), startangle=-40)\n\nbbox_props = dict(boxstyle=\"square,pad=0.3\", fc=\"w\", ec=\"k\", lw=0.72)\nkw = dict(arrowprops=dict(arrowstyle=\"-\"),\n          bbox=bbox_props, zorder=0, va=\"center\")\n\nfor i, p in enumerate(wedges):\n    ang = (p.theta2 - p.theta1)/2. + p.theta1\n    y = np.sin(np.deg2rad(ang))\n    x = np.cos(np.deg2rad(ang))\n    horizontalalignment = {-1: \"right\", 1: \"left\"}[int(np.sign(x))]\n    connectionstyle = f\"angle,angleA=0,angleB={ang}\"\n    kw[\"arrowprops\"].update({\"connectionstyle\": connectionstyle})\n    ax.annotate(recipe[i], xy=(x, y), xytext=(1.35*np.sign(x), 1.4*y),\n                horizontalalignment=horizontalalignment, **kw)\n\nax.set_title(\"Matplotlib bakery: A donut\")\n\nplt.show()\n\n# %%\n# And here it is, the donut. Note however, that if we were to use this recipe,\n# the ingredients would suffice for around 6 donuts - producing one huge\n# donut is untested and might result in kitchen errors.\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pie` / `matplotlib.pyplot.pie`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#\n# .. tags::\n#\n#    component: label\n#    component: annotation\n#    plot-type: pie\n#    level: beginner\n"
    },
    {
      "filename": "pie_features.py",
      "title": "Pie Features",
      "code": "\"\"\"\n.. redirect-from:: gallery/pie_and_polar_charts/pie_demo2\n\n==========\nPie charts\n==========\n\nDemo of plotting a pie chart.\n\nThis example illustrates various parameters of `~matplotlib.axes.Axes.pie`.\n\"\"\"\n\n# %%\n# Label slices\n# ------------\n#\n# Plot a pie chart of animals and label the slices. To add\n# labels, pass a list of labels to the *labels* parameter\n\nimport matplotlib.pyplot as plt\n\nlabels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\nsizes = [15, 30, 45, 10]\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels)\n\n# %%\n# Each slice of the pie chart is a `.patches.Wedge` object; therefore in\n# addition to the customizations shown here, each wedge can be customized using\n# the *wedgeprops* argument, as demonstrated in\n# :doc:`/gallery/pie_and_polar_charts/nested_pie`.\n#\n# Auto-label slices\n# -----------------\n#\n# Pass a function or format string to *autopct* to label slices.\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%1.1f%%')\n\n# %%\n# By default, the label values are obtained from the percent size of the slice.\n#\n# Color slices\n# ------------\n#\n# Pass a list of colors to *colors* to set the color of each slice.\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels,\n       colors=['olivedrab', 'rosybrown', 'gray', 'saddlebrown'])\n\n# %%\n# Hatch slices\n# ------------\n#\n# Pass a list of hatch patterns to *hatch* to set the pattern of each slice.\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, hatch=['**O', 'oO', 'O.O', '.||.'])\n\n# %%\n# Swap label and autopct text positions\n# -------------------------------------\n# Use the *labeldistance* and *pctdistance* parameters to position the *labels*\n# and *autopct* text respectively.\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%1.1f%%',\n       pctdistance=1.25, labeldistance=.6)\n\n# %%\n# *labeldistance* and *pctdistance* are ratios of the radius; therefore they\n# vary between ``0`` for the center of the pie and ``1`` for the edge of the\n# pie, and can be set to greater than ``1`` to place text outside the pie.\n#\n# Explode, shade, and rotate slices\n# ---------------------------------\n#\n# In addition to the basic pie chart, this demo shows a few optional features:\n#\n# * offsetting a slice using *explode*\n# * add a drop-shadow using *shadow*\n# * custom start angle using *startangle*\n#\n# This example orders the slices, separates (explodes) them, and rotates them.\n\nexplode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\nfig, ax = plt.subplots()\nax.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n       shadow=True, startangle=90)\nplt.show()\n\n# %%\n# The default *startangle* is 0, which would start the first slice (\"Frogs\") on\n# the positive x-axis. This example sets ``startangle = 90`` such that all the\n# slices are rotated counter-clockwise by 90 degrees, and the frog slice starts\n# on the positive y-axis.\n#\n# Controlling the size\n# --------------------\n#\n# By changing the *radius* parameter, and often the text size for better visual\n# appearance, the pie chart can be scaled.\n\nfig, ax = plt.subplots()\n\nax.pie(sizes, labels=labels, autopct='%.0f%%',\n       textprops={'size': 'smaller'}, radius=0.5)\nplt.show()\n\n# %%\n# Modifying the shadow\n# --------------------\n#\n# The *shadow* parameter may optionally take a dictionary with arguments to\n# the `.Shadow` patch. This can be used to modify the default shadow.\n\nfig, ax = plt.subplots()\nax.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n       shadow={'ox': -0.04, 'edgecolor': 'none', 'shade': 0.9}, startangle=90)\nplt.show()\n\n# %%\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pie` / `matplotlib.pyplot.pie`\n#\n# .. tags::\n#\n#    plot-type: pie\n#    level: beginner\n"
    },
    {
      "filename": "polar_bar.py",
      "title": "Polar Bar",
      "code": "\"\"\"\n=======================\nBar chart on polar axis\n=======================\n\nDemo of bar plot on a polar axis.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Compute pie slices\nN = 20\ntheta = np.linspace(0.0, 2 * np.pi, N, endpoint=False)\nradii = 10 * np.random.rand(N)\nwidth = np.pi / 4 * np.random.rand(N)\ncolors = plt.cm.viridis(radii / 10.)\n\nax = plt.subplot(projection='polar')\nax.bar(theta, radii, width=width, bottom=0.0, color=colors, alpha=0.5)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n#    - `matplotlib.projections.polar`\n#\n# .. tags::\n#\n#    plot-type: pie\n#    plot-type: bar\n#    level: beginner\n#    purpose: showcase\n"
    },
    {
      "filename": "polar_demo.py",
      "title": "Polar Demo",
      "code": "\"\"\"\n==========\nPolar plot\n==========\n\nDemo of a line plot on a polar axis.\n\nThe second plot shows the same data, but with the radial axis starting at r=1\nand the angular axis starting at 0 degrees and ending at 225 degrees. Setting\nthe origin of the radial axis to 0 allows the radial ticks to be placed at the\nsame location as the first plot.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\nfig, axs = plt.subplots(2, 1, figsize=(5, 8), subplot_kw={'projection': 'polar'},\n                        layout='constrained')\nax = axs[0]\nax.plot(theta, r)\nax.set_rmax(2)\nax.set_rticks([0.5, 1, 1.5, 2])  # Fewer radial ticks\nax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line\nax.grid(True)\n\nax.set_title(\"A line plot on a polar axis\", va='bottom')\n\nax = axs[1]\nax.plot(theta, r)\nax.set_rmax(2)\nax.set_rmin(1)  # Change the radial axis to only go from 1 to 2\nax.set_rorigin(0)  # Set the origin of the radial axis to 0\nax.set_thetamin(0)\nax.set_thetamax(225)\nax.set_rticks([1, 1.5, 2])  # Fewer radial ticks\nax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line\n\nax.grid(True)\nax.set_title(\"Same plot, but with reduced axis limits\", va='bottom')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.projections.polar`\n#    - `matplotlib.projections.polar.PolarAxes`\n#    - `matplotlib.projections.polar.PolarAxes.set_rticks`\n#    - `matplotlib.projections.polar.PolarAxes.set_rmin`\n#    - `matplotlib.projections.polar.PolarAxes.set_rorigin`\n#    - `matplotlib.projections.polar.PolarAxes.set_rmax`\n#    - `matplotlib.projections.polar.PolarAxes.set_rlabel_position`\n#\n# .. tags::\n#\n#    plot-type: polar\n#    level: beginner\n"
    },
    {
      "filename": "polar_error_caps.py",
      "title": "Polar Error Caps",
      "code": "\"\"\"\n=================================\nError bar rendering on polar axis\n=================================\n\nDemo of error bar plot in polar coordinates.\nTheta error bars are curved lines ended with caps oriented towards the\ncenter.\nRadius error bars are straight lines oriented towards center with\nperpendicular caps.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ntheta = np.arange(0, 2 * np.pi, np.pi / 4)\nr = theta / np.pi / 2 + 0.5\n\nfig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(projection='polar')\nax.errorbar(theta, r, xerr=0.25, yerr=0.1, capsize=7, fmt=\"o\", c=\"seagreen\")\nax.set_title(\"Pretty polar error bars\")\nplt.show()\n\n# %%\n# Please acknowledge that large theta error bars will be overlapping.\n# This may reduce readability of the output plot. See example figure below:\n\nfig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(projection='polar')\nax.errorbar(theta, r, xerr=5.25, yerr=0.1, capsize=7, fmt=\"o\", c=\"darkred\")\nax.set_title(\"Overlapping theta error bars\")\nplt.show()\n\n# %%\n# On the other hand, large radius error bars will never overlap, they just\n# lead to unwanted scale in the data, reducing the displayed range.\n\nfig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(projection='polar')\nax.errorbar(theta, r, xerr=0.25, yerr=10.1, capsize=7, fmt=\"o\", c=\"orangered\")\nax.set_title(\"Large radius error bars\")\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`\n#    - `matplotlib.projections.polar`\n#\n# .. tags::\n#\n#    component: error\n#    plot-type: errorbar\n#    plot-type: polar\n#    level: beginner\n"
    },
    {
      "filename": "polar_legend.py",
      "title": "Polar Legend",
      "code": "\"\"\"\n============\nPolar legend\n============\n\nUsing a legend on a polar-axis plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection=\"polar\", facecolor=\"lightgoldenrodyellow\")\n\nr = np.linspace(0, 3, 301)\ntheta = 2 * np.pi * r\nax.plot(theta, r, color=\"tab:orange\", lw=3, label=\"a line\")\nax.plot(0.5 * theta, r, color=\"tab:blue\", ls=\"--\", lw=3, label=\"another line\")\nax.tick_params(grid_color=\"palegoldenrod\")\n# For polar Axes, it may be useful to move the legend slightly away from the\n# Axes center, to avoid overlap between the legend and the Axes.  The following\n# snippet places the legend's lower left corner just outside the polar Axes\n# at an angle of 67.5 degrees in polar coordinates.\nangle = np.deg2rad(67.5)\nax.legend(loc=\"lower left\",\n          bbox_to_anchor=(.5 + np.cos(angle)/2, .5 + np.sin(angle)/2))\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n#    - `matplotlib.projections.polar`\n#    - `matplotlib.projections.polar.PolarAxes`\n#\n# .. tags::\n#\n#    component: legend\n#    plot-type: polar\n#    level: beginner\n"
    },
    {
      "filename": "polar_scatter.py",
      "title": "Polar Scatter",
      "code": "\"\"\"\n==========================\nScatter plot on polar axis\n==========================\n\nSize increases radially in this example and color increases with angle\n(just to verify the symbols are being scattered correctly).\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Compute areas and colors\nN = 150\nr = 2 * np.random.rand(N)\ntheta = 2 * np.pi * np.random.rand(N)\narea = 200 * r**2\ncolors = theta\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\n# %%\n# Scatter plot on polar axis, with offset origin\n# ----------------------------------------------\n#\n# The main difference with the previous plot is the configuration of the origin\n# radius, producing an annulus. Additionally, the theta zero location is set to\n# rotate the plot.\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\nax.set_rorigin(-2.5)\nax.set_theta_zero_location('W', offset=10)\n\n# %%\n# Scatter plot on polar axis confined to a sector\n# -----------------------------------------------\n#\n# The main difference with the previous plots is the configuration of the\n# theta start and end limits, producing a sector instead of a full circle.\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\nax.set_thetamin(45)\nax.set_thetamax(135)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.scatter` / `matplotlib.pyplot.scatter`\n#    - `matplotlib.projections.polar`\n#    - `matplotlib.projections.polar.PolarAxes.set_rorigin`\n#    - `matplotlib.projections.polar.PolarAxes.set_theta_zero_location`\n#    - `matplotlib.projections.polar.PolarAxes.set_thetamin`\n#    - `matplotlib.projections.polar.PolarAxes.set_thetamax`\n#\n# .. tags::\n#\n#    plot-style: polar\n#    plot-style: scatter\n#    level: beginner\n"
    }
  ],
  "pyplots": [
    {
      "filename": "pyplot_simple.py",
      "title": "Pyplot Simple",
      "code": "\"\"\"\n===========\nSimple plot\n===========\n\nA simple plot where a list of numbers are plotted against their index,\nresulting in a straight line. Use a format string (here, 'o-r') to set the\nmarkers (circles), linestyle (solid line) and color (red).\n\n.. redirect-from:: /gallery/pyplots/fig_axes_labels_simple\n.. redirect-from:: /gallery/pyplots/pyplot_formatstr\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4], 'o-r')\nplt.ylabel('some numbers')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.plot`\n#    - `matplotlib.pyplot.ylabel`\n#    - `matplotlib.pyplot.show`\n"
    },
    {
      "filename": "pyplot_text.py",
      "title": "Pyplot Text",
      "code": "\"\"\"\n==============================\nText and mathtext using pyplot\n==============================\n\nSet the special text objects `~.pyplot.title`, `~.pyplot.xlabel`, and\n`~.pyplot.ylabel` through the dedicated pyplot functions.  Additional text\nobjects can be placed in the Axes using `~.pyplot.text`.\n\nYou can use TeX-like mathematical typesetting in all texts; see also\n:ref:`mathtext`.\n\n.. redirect-from:: /gallery/pyplots/pyplot_mathtext\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2*np.pi*t)\n\nplt.plot(t, s)\nplt.text(0, -1, r'Hello, world!', fontsize=15)\nplt.title(r'$\\mathcal{A}\\sin(\\omega t)$', fontsize=20)\nplt.xlabel('Time [s]')\nplt.ylabel('Voltage [mV]')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.hist`\n#    - `matplotlib.pyplot.xlabel`\n#    - `matplotlib.pyplot.ylabel`\n#    - `matplotlib.pyplot.text`\n#    - `matplotlib.pyplot.grid`\n#    - `matplotlib.pyplot.show`\n"
    },
    {
      "filename": "pyplot_three.py",
      "title": "Pyplot Three",
      "code": "\"\"\"\n===========================\nMultiple lines using pyplot\n===========================\n\nPlot three datasets with a single call to `~matplotlib.pyplot.plot`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# evenly sampled time at 200ms intervals\nt = np.arange(0., 5., 0.2)\n\n# red dashes, blue squares and green triangles\nplt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n"
    },
    {
      "filename": "pyplot_two_subplots.py",
      "title": "Pyplot Two Subplots",
      "code": "\"\"\"\n=========================\nTwo subplots using pyplot\n=========================\n\nCreate a figure with two subplots using `.pyplot.subplot`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef f(t):\n    return np.exp(-t) * np.cos(2*np.pi*t)\n\n\nt1 = np.arange(0.0, 5.0, 0.1)\nt2 = np.arange(0.0, 5.0, 0.02)\n\nplt.figure()\nplt.subplot(211)\nplt.plot(t1, f(t1), color='tab:blue', marker='o')\nplt.plot(t2, f(t2), color='black')\n\nplt.subplot(212)\nplt.plot(t2, np.cos(2*np.pi*t2), color='tab:orange', linestyle='--')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.figure`\n#    - `matplotlib.pyplot.subplot`\n"
    }
  ],
  "scales": [
    {
      "filename": "asinh_demo.py",
      "title": "Asinh Demo",
      "code": "\"\"\"\n===========\nAsinh scale\n===========\n\nIllustration of the `asinh <.scale.AsinhScale>` axis scaling,\nwhich uses the transformation\n\n.. math::\n\n    a \\\\rightarrow a_0 \\\\sinh^{-1} (a / a_0)\n\nFor coordinate values close to zero (i.e. much smaller than\nthe \"linear width\" :math:`a_0`), this leaves values essentially unchanged:\n\n.. math::\n\n    a \\\\rightarrow a + \\\\mathcal{O}(a^3)\n\nbut for larger values (i.e. :math:`|a| \\\\gg a_0`, this is asymptotically\n\n.. math::\n\n    a \\\\rightarrow a_0 \\\\, \\\\mathrm{sgn}(a) \\\\ln |a| + \\\\mathcal{O}(1)\n\nAs with the `symlog <.scale.SymmetricalLogScale>` scaling,\nthis allows one to plot quantities\nthat cover a very wide dynamic range that includes both positive\nand negative values. However, ``symlog`` involves a transformation\nthat has discontinuities in its gradient because it is built\nfrom *separate* linear and logarithmic transformations.\nThe ``asinh`` scaling uses a transformation that is smooth\nfor all (finite) values, which is both mathematically cleaner\nand reduces visual artifacts associated with an abrupt\ntransition between linear and logarithmic regions of the plot.\n\n.. note::\n   `.scale.AsinhScale` is experimental, and the API may change.\n\nSee `~.scale.AsinhScale`, `~.scale.SymmetricalLogScale`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Prepare sample values for variations on y=x graph:\nx = np.linspace(-3, 6, 500)\n\n# %%\n# Compare \"symlog\" and \"asinh\" behaviour on sample y=x graph,\n# where there is a discontinuous gradient in \"symlog\" near y=2:\nfig1 = plt.figure()\nax0, ax1 = fig1.subplots(1, 2, sharex=True)\n\nax0.plot(x, x)\nax0.set_yscale('symlog')\nax0.grid()\nax0.set_title('symlog')\n\nax1.plot(x, x)\nax1.set_yscale('asinh')\nax1.grid()\nax1.set_title('asinh')\n\n\n# %%\n# Compare \"asinh\" graphs with different scale parameter \"linear_width\":\nfig2 = plt.figure(layout='constrained')\naxs = fig2.subplots(1, 3, sharex=True)\nfor ax, (a0, base) in zip(axs, ((0.2, 2), (1.0, 0), (5.0, 10))):\n    ax.set_title(f'linear_width={a0:.3g}')\n    ax.plot(x, x, label='y=x')\n    ax.plot(x, 10*x, label='y=10x')\n    ax.plot(x, 100*x, label='y=100x')\n    ax.set_yscale('asinh', linear_width=a0, base=base)\n    ax.grid()\n    ax.legend(loc='best', fontsize='small')\n\n\n# %%\n# Compare \"symlog\" and \"asinh\" scalings\n# on 2D Cauchy-distributed random numbers,\n# where one may be able to see more subtle artifacts near y=2\n# due to the gradient-discontinuity in \"symlog\":\nfig3 = plt.figure()\nax = fig3.subplots(1, 1)\nr = 3 * np.tan(np.random.uniform(-np.pi / 2.02, np.pi / 2.02,\n                                 size=(5000,)))\nth = np.random.uniform(0, 2*np.pi, size=r.shape)\n\nax.scatter(r * np.cos(th), r * np.sin(th), s=4, alpha=0.5)\nax.set_xscale('asinh')\nax.set_yscale('symlog')\nax.set_xlabel('asinh')\nax.set_ylabel('symlog')\nax.set_title('2D Cauchy random deviates')\nax.set_xlim(-50, 50)\nax.set_ylim(-50, 50)\nax.grid()\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    - `matplotlib.scale.AsinhScale`\n#    - `matplotlib.ticker.AsinhLocator`\n#    - `matplotlib.scale.SymmetricalLogScale`\n"
    },
    {
      "filename": "aspect_loglog.py",
      "title": "Aspect Loglog",
      "code": "\"\"\"\n=============\nLoglog aspect\n=============\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nax1.set_xscale(\"log\")\nax1.set_yscale(\"log\")\nax1.set_xlim(1e1, 1e3)\nax1.set_ylim(1e2, 1e3)\nax1.set_aspect(1)\nax1.set_title(\"adjustable = box\")\n\nax2.set_xscale(\"log\")\nax2.set_yscale(\"log\")\nax2.set_adjustable(\"datalim\")\nax2.plot([1, 3, 10], [1, 9, 100], \"o-\")\nax2.set_xlim(1e-1, 1e2)\nax2.set_ylim(1e-1, 1e3)\nax2.set_aspect(1)\nax2.set_title(\"adjustable = datalim\")\n\nplt.show()\n"
    },
    {
      "filename": "custom_scale.py",
      "title": "Custom Scale",
      "code": "\"\"\"\n.. _custom_scale:\n\n============\nCustom scale\n============\n\nCustom scales can be created in two ways\n\n#. For simple cases, use `~.scale.FuncScale` and the ``'function'`` option of\n   `~.Axes.set_xscale` and `~.Axes.set_yscale`.  See the last example in\n   :doc:`/gallery/scales/scales`.\n\n#. Create a custom scale class such as the one in this example, which implements\n   the scaling use for latitude data in a Mercator Projection.  This more complicated\n   approach is useful when\n\n   * You are making special use of the `.Transform` class, such as the special\n     handling of values beyond the threshold in ``MercatorLatitudeTransform``\n     below.\n\n   * You want to override the default locators and formatters for the axis\n     (``set_default_locators_and_formatters`` below).\n\n   * You want to limit the range of the axis (``limit_range_for_scale`` below).\n\n\"\"\"\n\nimport numpy as np\nfrom numpy import ma\n\nfrom matplotlib import scale as mscale\nfrom matplotlib import transforms as mtransforms\nfrom matplotlib.ticker import FixedLocator, FuncFormatter\n\n\nclass MercatorLatitudeScale(mscale.ScaleBase):\n    \"\"\"\n    Scales data in range -pi/2 to pi/2 (-90 to 90 degrees) using\n    the system used to scale latitudes in a Mercator__ projection.\n\n    The scale function:\n      ln(tan(y) + sec(y))\n\n    The inverse scale function:\n      atan(sinh(y))\n\n    Since the Mercator scale tends to infinity at +/- 90 degrees,\n    there is user-defined threshold, above and below which nothing\n    will be plotted.  This defaults to +/- 85 degrees.\n\n    __ https://en.wikipedia.org/wiki/Mercator_projection\n    \"\"\"\n\n    # The scale class must have a member ``name`` that defines the string used\n    # to select the scale.  For example, ``ax.set_yscale(\"mercator\")`` would be\n    # used to select this scale.\n    name = 'mercator'\n\n    def __init__(self, axis, *, thresh=np.deg2rad(85), **kwargs):\n        \"\"\"\n        Any keyword arguments passed to ``set_xscale`` and ``set_yscale`` will\n        be passed along to the scale's constructor.\n\n        thresh: The degree above which to crop the data.\n        \"\"\"\n        super().__init__(axis)\n        if thresh >= np.pi / 2:\n            raise ValueError(\"thresh must be less than pi/2\")\n        self.thresh = thresh\n\n    def get_transform(self):\n        \"\"\"\n        Override this method to return a new instance that does the\n        actual transformation of the data.\n\n        The MercatorLatitudeTransform class is defined below as a\n        nested class of this one.\n        \"\"\"\n        return self.MercatorLatitudeTransform(self.thresh)\n\n    def set_default_locators_and_formatters(self, axis):\n        \"\"\"\n        Override to set up the locators and formatters to use with the\n        scale.  This is only required if the scale requires custom\n        locators and formatters.  Writing custom locators and\n        formatters is rather outside the scope of this example, but\n        there are many helpful examples in :mod:`.ticker`.\n\n        In our case, the Mercator example uses a fixed locator from -90 to 90\n        degrees and a custom formatter to convert the radians to degrees and\n        put a degree symbol after the value.\n        \"\"\"\n        fmt = FuncFormatter(\n            lambda x, pos=None: f\"{np.degrees(x):.0f}\\N{DEGREE SIGN}\")\n        axis.set(major_locator=FixedLocator(np.radians(range(-90, 90, 10))),\n                 major_formatter=fmt, minor_formatter=fmt)\n\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Override to limit the bounds of the axis to the domain of the\n        transform.  In the case of Mercator, the bounds should be\n        limited to the threshold that was passed in.  Unlike the\n        autoscaling provided by the tick locators, this range limiting\n        will always be adhered to, whether the axis range is set\n        manually, determined automatically or changed through panning\n        and zooming.\n        \"\"\"\n        return max(vmin, -self.thresh), min(vmax, self.thresh)\n\n    class MercatorLatitudeTransform(mtransforms.Transform):\n        # There are two value members that must be defined.\n        # ``input_dims`` and ``output_dims`` specify number of input\n        # dimensions and output dimensions to the transformation.\n        # These are used by the transformation framework to do some\n        # error checking and prevent incompatible transformations from\n        # being connected together.  When defining transforms for a\n        # scale, which are, by definition, separable and have only one\n        # dimension, these members should always be set to 1.\n        input_dims = output_dims = 1\n\n        def __init__(self, thresh):\n            mtransforms.Transform.__init__(self)\n            self.thresh = thresh\n\n        def transform_non_affine(self, a):\n            \"\"\"\n            This transform takes a numpy array and returns a transformed copy.\n            Since the range of the Mercator scale is limited by the\n            user-specified threshold, the input array must be masked to\n            contain only valid values.  Matplotlib will handle masked arrays\n            and remove the out-of-range data from the plot.  However, the\n            returned array *must* have the same shape as the input array, since\n            these values need to remain synchronized with values in the other\n            dimension.\n            \"\"\"\n            masked = ma.masked_where((a < -self.thresh) | (a > self.thresh), a)\n            if masked.mask.any():\n                return ma.log(np.abs(ma.tan(masked) + 1 / ma.cos(masked)))\n            else:\n                return np.log(np.abs(np.tan(a) + 1 / np.cos(a)))\n\n        def inverted(self):\n            \"\"\"\n            Override this method so Matplotlib knows how to get the\n            inverse transform for this transform.\n            \"\"\"\n            return MercatorLatitudeScale.InvertedMercatorLatitudeTransform(\n                self.thresh)\n\n    class InvertedMercatorLatitudeTransform(mtransforms.Transform):\n        input_dims = output_dims = 1\n\n        def __init__(self, thresh):\n            mtransforms.Transform.__init__(self)\n            self.thresh = thresh\n\n        def transform_non_affine(self, a):\n            return np.arctan(np.sinh(a))\n\n        def inverted(self):\n            return MercatorLatitudeScale.MercatorLatitudeTransform(self.thresh)\n\n\n# Now that the Scale class has been defined, it must be registered so\n# that Matplotlib can find it.\nmscale.register_scale(MercatorLatitudeScale)\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    t = np.arange(-180.0, 180.0, 0.1)\n    s = np.radians(t)/2.\n\n    plt.plot(t, s, '-', lw=2)\n    plt.yscale('mercator')\n\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title('Mercator projection')\n    plt.grid(True)\n\n    plt.show()\n"
    },
    {
      "filename": "log_demo.py",
      "title": "Log Demo",
      "code": "\"\"\"\n=========\nLog scale\n=========\n\nExamples of plots with logarithmic axes.\n\nYou can set the x/y axes to be logarithmic by passing \"log\" to `~.Axes.set_xscale` /\n`~.Axes.set_yscale`.\n\nConvenience functions ``semilogx``, ``semilogy``, and ``loglog``\n----------------------------------------------------------------\nSince plotting data on semi-logarithmic or double-logarithmic scales is very common,\nthe functions `~.Axes.semilogx`, `~.Axes.semilogy`, and `~.Axes.loglog` are shortcuts\nfor setting the scale and plotting data; e.g. ``ax.semilogx(x, y)`` is equivalent to\n``ax.set_xscale('log'); ax.plot(x, y)``.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, layout='constrained', figsize=(7, 7/3))\n# log x axis\nt = np.arange(0.01, 10.0, 0.01)\nax1.semilogx(t, np.sin(2 * np.pi * t))\nax1.set(title='semilogx')\nax1.grid()\nax1.grid(which=\"minor\", color=\"0.9\")\n\n# log y axis\nx = np.arange(4)\nax2.semilogy(4*x, 10**x, 'o--')\nax2.set(title='semilogy')\nax2.grid()\nax2.grid(which=\"minor\", color=\"0.9\")\n\n# log x and y axis\nx = np.array([1, 10, 100, 1000])\nax3.loglog(x, 5 * x, 'o--')\nax3.set(title='loglog')\nax3.grid()\nax3.grid(which=\"minor\", color=\"0.9\")\n\n# %%\n# Logarithms with other bases\n# ---------------------------\n# By default, the log scale is to the base 10. One can change this via the *base*\n# parameter.\nfig, ax = plt.subplots()\nax.bar([\"L1 cache\", \"L2 cache\", \"L3 cache\", \"RAM\", \"SSD\"],\n       [32, 1_000, 32_000, 16_000_000, 512_000_000])\nax.set_yscale('log', base=2)\nax.set_yticks([1, 2**10, 2**20, 2**30], labels=['kB', 'MB', 'GB', 'TB'])\nax.set_title(\"Typical memory sizes\")\nax.yaxis.grid()\n\n# %%\n# Dealing with negative values\n# ----------------------------\n# Non-positive values cannot be displayed on a log scale. The scale has two options\n# to handle these. Either mask the values so that they are ignored, or clip them\n# to a small positive value. Which one is more suited depends on the type of the\n# data and the visualization.\n#\n# The following example contains errorbars going negative. If we mask these values,\n# the bar vanishes, which is not desirable. In contrast, clipping makes the value\n# small positive (but well below the used scale) so that the error bar is drawn\n# to the edge of the Axes.\nx = np.linspace(0.0, 2.0, 10)\ny = 10**x\nyerr = 1.75 + 0.75*y\n\nfig, (ax1, ax2) = plt.subplots(1, 2, layout=\"constrained\", figsize=(6, 3))\nfig.suptitle(\"errorbars going negative\")\nax1.set_yscale(\"log\", nonpositive='mask')\nax1.set_title('nonpositive=\"mask\"')\nax1.errorbar(x, y, yerr=yerr, fmt='o', capsize=5)\n\nax2.set_yscale(\"log\", nonpositive='clip')\nax2.set_title('nonpositive=\"clip\"')\nax2.errorbar(x, y, yerr=yerr, fmt='o', capsize=5)\n\nplt.show()\n"
    },
    {
      "filename": "logit_demo.py",
      "title": "Logit Demo",
      "code": "\"\"\"\n===========\nLogit scale\n===========\n\nExamples of plots with logit axes.\n\nThis example visualises how ``set_yscale(\"logit\")`` works on probability plots\nby generating three distributions: normal, laplacian, and cauchy in one plot.\n\nThe advantage of logit scale is that it effectively spreads out values close to 0 and 1.\n\nIn a linear scale plot, probability values near 0 and 1 appear compressed,\nmaking it difficult to see differences in those regions.\n\nIn a logit scale plot, the transformation expands these regions,\nmaking the graph cleaner and easier to compare across different probability values.\n\nThis makes the logit scale especially useful when visalising probabilities in logistic\nregression, classification models, and cumulative distribution functions.\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nxmax = 10\nx = np.linspace(-xmax, xmax, 10000)\ncdf_norm = [math.erf(w / np.sqrt(2)) / 2 + 1 / 2 for w in x]\ncdf_laplacian = np.where(x < 0, 1 / 2 * np.exp(x), 1 - 1 / 2 * np.exp(-x))\ncdf_cauchy = np.arctan(x) / np.pi + 1 / 2\n\nfig, axs = plt.subplots(nrows=3, ncols=2, figsize=(6.4, 8.5))\n\n# Common part, for the example, we will do the same plots on all graphs\nfor i in range(3):\n    for j in range(2):\n        axs[i, j].plot(x, cdf_norm, label=r\"$\\mathcal{N}$\")\n        axs[i, j].plot(x, cdf_laplacian, label=r\"$\\mathcal{L}$\")\n        axs[i, j].plot(x, cdf_cauchy, label=\"Cauchy\")\n        axs[i, j].legend()\n        axs[i, j].grid()\n\n# First line, logitscale, with standard notation\naxs[0, 0].set(title=\"logit scale\")\naxs[0, 0].set_yscale(\"logit\")\naxs[0, 0].set_ylim(1e-5, 1 - 1e-5)\n\naxs[0, 1].set(title=\"logit scale\")\naxs[0, 1].set_yscale(\"logit\")\naxs[0, 1].set_xlim(0, xmax)\naxs[0, 1].set_ylim(0.8, 1 - 5e-3)\n\n# Second line, logitscale, with survival notation (with `use_overline`), and\n# other format display 1/2\naxs[1, 0].set(title=\"logit scale\")\naxs[1, 0].set_yscale(\"logit\", one_half=\"1/2\", use_overline=True)\naxs[1, 0].set_ylim(1e-5, 1 - 1e-5)\n\naxs[1, 1].set(title=\"logit scale\")\naxs[1, 1].set_yscale(\"logit\", one_half=\"1/2\", use_overline=True)\naxs[1, 1].set_xlim(0, xmax)\naxs[1, 1].set_ylim(0.8, 1 - 5e-3)\n\n# Third line, linear scale\naxs[2, 0].set(title=\"linear scale\")\naxs[2, 0].set_ylim(0, 1)\n\naxs[2, 1].set(title=\"linear scale\")\naxs[2, 1].set_xlim(0, xmax)\naxs[2, 1].set_ylim(0.8, 1)\n\nfig.tight_layout()\nplt.show()\n"
    },
    {
      "filename": "power_norm.py",
      "title": "Power Norm",
      "code": "\"\"\"\n========================\nExploring normalizations\n========================\n\nVarious normalization on a multivariate normal distribution.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import multivariate_normal\n\nimport matplotlib.colors as mcolors\n\n# Fixing random state for reproducibility.\nnp.random.seed(19680801)\n\ndata = np.vstack([\n    multivariate_normal([10, 10], [[3, 2], [2, 3]], size=100000),\n    multivariate_normal([30, 20], [[3, 1], [1, 3]], size=1000)\n])\n\ngammas = [0.8, 0.5, 0.3]\n\nfig, axs = plt.subplots(nrows=2, ncols=2)\n\naxs[0, 0].set_title('Linear normalization')\naxs[0, 0].hist2d(data[:, 0], data[:, 1], bins=100)\n\nfor ax, gamma in zip(axs.flat[1:], gammas):\n    ax.set_title(r'Power law $(\\gamma=%1.1f)$' % gamma)\n    ax.hist2d(data[:, 0], data[:, 1], bins=100, norm=mcolors.PowerNorm(gamma))\n\nfig.tight_layout()\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colors`\n#    - `matplotlib.colors.PowerNorm`\n#    - `matplotlib.axes.Axes.hist2d`\n#    - `matplotlib.pyplot.hist2d`\n"
    },
    {
      "filename": "scales.py",
      "title": "Scales",
      "code": "\"\"\"\n===============\nScales overview\n===============\n\nIllustrate the scale transformations applied to axes, e.g. log, symlog, logit.\n\nSee `matplotlib.scale` for a full list of built-in scales, and\n:doc:`/gallery/scales/custom_scale` for how to create your own scale.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(400)\ny = np.linspace(0.002, 1, 400)\n\nfig, axs = plt.subplots(3, 2, figsize=(6, 8), layout='constrained')\n\naxs[0, 0].plot(x, y)\naxs[0, 0].set_yscale('linear')\naxs[0, 0].set_title('linear')\naxs[0, 0].grid(True)\n\naxs[0, 1].plot(x, y)\naxs[0, 1].set_yscale('log')\naxs[0, 1].set_title('log')\naxs[0, 1].grid(True)\n\naxs[1, 0].plot(x, y - y.mean())\naxs[1, 0].set_yscale('symlog', linthresh=0.02)\naxs[1, 0].set_title('symlog')\naxs[1, 0].grid(True)\n\naxs[1, 1].plot(x, y)\naxs[1, 1].set_yscale('logit')\naxs[1, 1].set_title('logit')\naxs[1, 1].grid(True)\n\naxs[2, 0].plot(x, y - y.mean())\naxs[2, 0].set_yscale('asinh', linear_width=0.01)\naxs[2, 0].set_title('asinh')\naxs[2, 0].grid(True)\n\n\n# Function x**(1/2)\ndef forward(x):\n    return x**(1/2)\n\n\ndef inverse(x):\n    return x**2\n\n\naxs[2, 1].plot(x, y)\naxs[2, 1].set_yscale('function', functions=(forward, inverse))\naxs[2, 1].set_title('function: $x^{1/2}$')\naxs[2, 1].grid(True)\naxs[2, 1].set_yticks(np.arange(0, 1.2, 0.2))\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.set_xscale`\n#    - `matplotlib.axes.Axes.set_yscale`\n#    - `matplotlib.scale.LinearScale`\n#    - `matplotlib.scale.LogScale`\n#    - `matplotlib.scale.SymmetricalLogScale`\n#    - `matplotlib.scale.LogitScale`\n#    - `matplotlib.scale.FuncScale`\n"
    },
    {
      "filename": "symlog_demo.py",
      "title": "Symlog Demo",
      "code": "\"\"\"\n============\nSymlog scale\n============\n\nThe symmetric logarithmic scale is an extension of the logarithmic scale that\nalso covers negative values. As with the logarithmic scale, it is particularly\nuseful for numerical data that spans a broad range of values, especially when there\nare significant differences between the magnitudes of the numbers involved.\n\nExample use of symlog (symmetric log) axis scaling.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndt = 0.01\nx = np.arange(-50.0, 50.0, dt)\ny = np.arange(0, 100.0, dt)\n\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=3)\n\nax0.plot(x, y)\nax0.set_xscale('symlog')\nax0.set_ylabel('symlogx')\nax0.grid()\nax0.xaxis.grid(which='minor')  # minor grid on too\n\nax1.plot(y, x)\nax1.set_yscale('symlog')\nax1.set_ylabel('symlogy')\n\nax2.plot(x, np.sin(x / 3.0))\nax2.set_xscale('symlog')\nax2.set_yscale('symlog', linthresh=0.015)\nax2.grid()\nax2.set_ylabel('symlog both')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n# Linear threshold\n# ----------------\n# Since each decade on a logarithmic scale covers the same amount of visual space\n# and there are infinitely many decades between a given number and zero, the symlog\n# scale must deviate from logarithmic mapping in a small range\n# *(-linthresh, linthresh)*, so that the range is mapped to a finite visual space.\n\n\ndef format_axes(ax, title=None):\n    \"\"\"A helper function to better visualize properties of the symlog scale.\"\"\"\n    ax.xaxis.get_minor_locator().set_params(subs=[2, 3, 4, 5, 6, 7, 8, 9])\n    ax.grid()\n    ax.xaxis.grid(which='minor')  # minor grid on too\n    linthresh = ax.xaxis.get_transform().linthresh\n    linscale = ax.xaxis.get_transform().linscale\n    ax.axvspan(-linthresh, linthresh, color='0.9')\n    if title:\n        ax.set_title(title.format(linthresh=linthresh, linscale=linscale))\n\n\nx = np.linspace(-60, 60, 201)\ny = np.linspace(0, 100.0, 201)\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, layout=\"constrained\")\n\nax1.plot(x, y)\nax1.set_xscale('symlog', linthresh=1)\nformat_axes(ax1, title='Linear region: linthresh={linthresh}')\n\nax2.plot(x, y)\nax2.set_xscale('symlog', linthresh=5)\nformat_axes(ax2, title='Linear region: linthresh={linthresh}')\n\n# %%\n# Generally, *linthresh* should be chosen so that no or only a few\n# data points are in the linear region. As a rule of thumb,\n# :math:`linthresh \\approx \\mathrm{min} |x|`.\n#\n#\n# Linear scale\n# ------------\n# Additionally, the *linscale* parameter determines how much visual space should be\n# used for the linear range. More precisely, it defines the ratio of visual space\n# of the region (0, linthresh) relative to one decade.\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, layout=\"constrained\")\n\nax1.plot(x, y)\nax1.set_xscale('symlog', linthresh=1)\nformat_axes(ax1, title='Linear region: linthresh={linthresh}, linscale={linscale}')\n\nax2.plot(x, y)\nax2.set_xscale('symlog', linthresh=1, linscale=0.1)\nformat_axes(ax2, title='Linear region: linthresh={linthresh}, linscale={linscale}')\n\n# %%\n# The suitable value for linscale depends on the dynamic range of data. As most data\n# will be outside the linear region, you typically the linear region only to cover\n# a small fraction of the visual area.\n#\n# Limitations and alternatives\n# ----------------------------\n# The coordinate transform used by ``symlog`` has a discontinuous gradient at the\n# transition between its linear and logarithmic regions. Depending on data and\n# scaling, this will be more or less obvious in the plot.\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xscale('symlog', linscale=0.05)\nformat_axes(ax, title=\"Discontinuous gradient at linear/log transition\")\n\n# %%\n# The ``asinh`` axis scale is an alternative transformation that supports a wide\n# dynamic range with a smooth gradient and thus may avoid such visual artifacts.\n# See :doc:`/gallery/scales/asinh_demo`.\n#\n#\n# .. admonition:: References\n#\n#    - `matplotlib.scale.SymmetricalLogScale`\n#    - `matplotlib.ticker.SymmetricalLogLocator`\n#    - `matplotlib.scale.AsinhScale`\n"
    }
  ],
  "shapes_and_collections": [
    {
      "filename": "arrow_guide.py",
      "title": "Arrow Guide",
      "code": "\"\"\"\n===========\nArrow guide\n===========\n\nAdding arrow patches to plots.\n\nArrows are often used to annotate plots. This tutorial shows how to plot arrows\nthat behave differently when the data limits on a plot are changed. In general,\npoints on a plot can either be fixed in \"data space\" or \"display space\".\nSomething plotted in data space moves when the data limits are altered - an\nexample would be the points in a scatter plot. Something plotted in display\nspace stays static when data limits are altered - an example would be a\nfigure title or the axis labels.\n\nArrows consist of a head (and possibly a tail) and a stem drawn between a\nstart point and end point, called 'anchor points' from now on.\nHere we show three use cases for plotting arrows, depending on whether the\nhead or anchor points need to be fixed in data or display space:\n\n1. Head shape fixed in display space, anchor points fixed in data space\n2. Head shape and anchor points fixed in display space\n3. Entire patch fixed in data space\n\nBelow each use case is presented in turn.\n\n.. redirect-from:: /gallery/text_labels_and_annotations/arrow_simple_demo\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nx_tail = 0.1\ny_tail = 0.5\nx_head = 0.9\ny_head = 0.8\ndx = x_head - x_tail\ndy = y_head - y_tail\n\n\n# %%\n# Head shape fixed in display space and anchor points fixed in data space\n# -----------------------------------------------------------------------\n#\n# This is useful if you are annotating a plot, and don't want the arrow\n# to change shape or position if you pan or scale the plot.\n#\n# In this case we use `.patches.FancyArrowPatch`.\n#\n# Note that when the axis limits are changed, the arrow shape stays the same,\n# but the anchor points move.\n\nfig, axs = plt.subplots(nrows=2)\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100)\naxs[0].add_patch(arrow)\n\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100)\naxs[1].add_patch(arrow)\naxs[1].set(xlim=(0, 2), ylim=(0, 2))\n\n# %%\n# Head shape and anchor points fixed in display space\n# ---------------------------------------------------\n#\n# This is useful if you are annotating a plot, and don't want the arrow to\n# change shape or position if you pan or scale the plot.\n#\n# In this case we use `.patches.FancyArrowPatch`, and pass the keyword argument\n# ``transform=ax.transAxes`` where ``ax`` is the Axes we are adding the patch\n# to.\n#\n# Note that when the axis limits are changed, the arrow shape and location\n# stay the same.\n\nfig, axs = plt.subplots(nrows=2)\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100,\n                                 transform=axs[0].transAxes)\naxs[0].add_patch(arrow)\n\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100,\n                                 transform=axs[1].transAxes)\naxs[1].add_patch(arrow)\naxs[1].set(xlim=(0, 2), ylim=(0, 2))\n\n\n# %%\n# Head shape and anchor points fixed in data space\n# ------------------------------------------------\n#\n# In this case we use `.patches.Arrow`, or `.patches.FancyArrow` (the latter is\n# in orange).\n#\n# Note that when the axis limits are changed, the arrow shape and location\n# change.\n#\n# `.FancyArrow`'s API is relatively awkward, and requires in particular passing\n# ``length_includes_head=True`` so that the arrow *tip* is ``(dx, dy)`` away\n# from the arrow start.  It is only included in this reference because it is\n# the arrow class returned by `.Axes.arrow` (in green).\n\nfig, axs = plt.subplots(nrows=2)\n\narrow = mpatches.Arrow(x_tail, y_tail, dx, dy)\naxs[0].add_patch(arrow)\narrow = mpatches.FancyArrow(x_tail, y_tail - .4, dx, dy,\n                            width=.1, length_includes_head=True, color=\"C1\")\naxs[0].add_patch(arrow)\naxs[0].arrow(x_tail + 1, y_tail - .4, dx, dy,\n             width=.1, length_includes_head=True, color=\"C2\")\n\narrow = mpatches.Arrow(x_tail, y_tail, dx, dy)\naxs[1].add_patch(arrow)\narrow = mpatches.FancyArrow(x_tail, y_tail - .4, dx, dy,\n                            width=.1, length_includes_head=True, color=\"C1\")\naxs[1].add_patch(arrow)\naxs[1].arrow(x_tail + 1, y_tail - .4, dx, dy,\n             width=.1, length_includes_head=True, color=\"C2\")\naxs[1].set(xlim=(0, 2), ylim=(0, 2))\n\n# %%\n\nplt.show()\n"
    },
    {
      "filename": "artist_reference.py",
      "title": "Artist Reference",
      "code": "\"\"\"\n.. _artist_reference:\n\n================================\nReference for Matplotlib artists\n================================\n\nThis example displays several of Matplotlib's graphics primitives (artists).\nA full list of artists is documented at :ref:`the artist API <artist-api>`.\n\nSee also :doc:`/gallery/shapes_and_collections/patch_collection`, which groups\nall artists into a single `.PatchCollection` instead.\n\nCopyright (c) 2010, Bartosz Telenczuk\nBSD License\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib as mpl\nimport matplotlib.lines as mlines\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\n# Prepare the data for the PathPatch below.\nPath = mpath.Path\ncodes, verts = zip(*[\n    (Path.MOVETO, [0.018, -0.11]),\n    (Path.CURVE4, [-0.031, -0.051]),\n    (Path.CURVE4, [-0.115, 0.073]),\n    (Path.CURVE4, [-0.03, 0.073]),\n    (Path.LINETO, [-0.011, 0.039]),\n    (Path.CURVE4, [0.043, 0.121]),\n    (Path.CURVE4, [0.075, -0.005]),\n    (Path.CURVE4, [0.035, -0.027]),\n    (Path.CLOSEPOLY, [0.018, -0.11])])\n\nartists = [\n    mpatches.Circle((0, 0), 0.1, ec=\"none\"),\n    mpatches.Rectangle((-0.025, -0.05), 0.05, 0.1, ec=\"none\"),\n    mpatches.Wedge((0, 0), 0.1, 30, 270, ec=\"none\"),\n    mpatches.RegularPolygon((0, 0), 5, radius=0.1),\n    mpatches.Ellipse((0, 0), 0.2, 0.1),\n    mpatches.Arrow(-0.05, -0.05, 0.1, 0.1, width=0.1),\n    mpatches.PathPatch(mpath.Path(verts, codes), ec=\"none\"),\n    mpatches.FancyBboxPatch((-0.025, -0.05), 0.05, 0.1, ec=\"none\",\n                            boxstyle=mpatches.BoxStyle(\"Round\", pad=0.02)),\n    mlines.Line2D([-0.06, 0.0, 0.1], [0.05, -0.05, 0.05], lw=5),\n]\n\naxs = plt.figure(figsize=(6, 6), layout=\"constrained\").subplots(3, 3)\nfor i, (ax, artist) in enumerate(zip(axs.flat, artists)):\n    artist.set(color=mpl.colormaps[\"hsv\"](i / len(artists)))\n    ax.add_artist(artist)\n    ax.set(title=type(artist).__name__,\n           aspect=1, xlim=(-.2, .2), ylim=(-.2, .2))\n    ax.set_axis_off()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.lines`\n#    - `matplotlib.lines.Line2D`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.patches.Ellipse`\n#    - `matplotlib.patches.Wedge`\n#    - `matplotlib.patches.Rectangle`\n#    - `matplotlib.patches.Arrow`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.patches.FancyBboxPatch`\n#    - `matplotlib.patches.RegularPolygon`\n#    - `matplotlib.axes.Axes.add_artist`\n"
    },
    {
      "filename": "collections.py",
      "title": "Collections",
      "code": "\"\"\"\n=========================================================\nLine, Poly and RegularPoly Collection with autoscaling\n=========================================================\n\nFor the first two subplots, we will use spirals.  Their size will be set in\nplot units, not data units.  Their positions will be set in data units by using\nthe *offsets* and *offset_transform* keyword arguments of the `.LineCollection`\nand `.PolyCollection`.\n\nThe third subplot will make regular polygons, with the same\ntype of scaling and positioning as in the first two.\n\nThe last subplot illustrates the use of ``offsets=(xo, yo)``,\nthat is, a single tuple instead of a list of tuples, to generate\nsuccessively offset curves, with the offset given in data\nunits.  This behavior is available only for the LineCollection.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import collections, transforms\n\nnverts = 50\nnpts = 100\n\n# Make some spirals\nr = np.arange(nverts)\ntheta = np.linspace(0, 2*np.pi, nverts)\nxx = r * np.sin(theta)\nyy = r * np.cos(theta)\nspiral = np.column_stack([xx, yy])\n\n# Fixing random state for reproducibility\nrs = np.random.RandomState(19680801)\n\n# Make some offsets\nxyo = rs.randn(npts, 2)\n\n# Make a list of colors cycling through the default series.\ncolors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nfig.subplots_adjust(top=0.92, left=0.07, right=0.97,\n                    hspace=0.3, wspace=0.3)\n\n\ncol = collections.LineCollection(\n    [spiral], offsets=xyo, offset_transform=ax1.transData)\ntrans = fig.dpi_scale_trans + transforms.Affine2D().scale(1.0/72.0)\ncol.set_transform(trans)  # the points to pixels transform\n# Note: the first argument to the collection initializer\n# must be a list of sequences of (x, y) tuples; we have only\n# one sequence, but we still have to put it in a list.\nax1.add_collection(col, autolim=True)\n# autolim=True enables autoscaling.  For collections with\n# offsets like this, it is neither efficient nor accurate,\n# but it is good enough to generate a plot that you can use\n# as a starting point.  If you know beforehand the range of\n# x and y that you want to show, it is better to set them\n# explicitly, leave out the *autolim* keyword argument (or set it to False),\n# and omit the 'ax1.autoscale_view()' call below.\n\n# Make a transform for the line segments such that their size is\n# given in points:\ncol.set_color(colors)\n\nax1.autoscale_view()  # See comment above, after ax1.add_collection.\nax1.set_title('LineCollection using offsets')\n\n\n# The same data as above, but fill the curves.\ncol = collections.PolyCollection(\n    [spiral], offsets=xyo, offset_transform=ax2.transData)\ntrans = transforms.Affine2D().scale(fig.dpi/72.0)\ncol.set_transform(trans)  # the points to pixels transform\nax2.add_collection(col, autolim=True)\ncol.set_color(colors)\n\n\nax2.autoscale_view()\nax2.set_title('PolyCollection using offsets')\n\n# 7-sided regular polygons\n\ncol = collections.RegularPolyCollection(\n    7, sizes=np.abs(xx) * 10.0, offsets=xyo, offset_transform=ax3.transData)\ntrans = transforms.Affine2D().scale(fig.dpi / 72.0)\ncol.set_transform(trans)  # the points to pixels transform\nax3.add_collection(col, autolim=True)\ncol.set_color(colors)\nax3.autoscale_view()\nax3.set_title('RegularPolyCollection using offsets')\n\n\n# Simulate a series of ocean current profiles, successively\n# offset by 0.1 m/s so that they form what is sometimes called\n# a \"waterfall\" plot or a \"stagger\" plot.\n\nnverts = 60\nncurves = 20\noffs = (0.1, 0.0)\n\nyy = np.linspace(0, 2*np.pi, nverts)\nym = np.max(yy)\nxx = (0.2 + (ym - yy) / ym) ** 2 * np.cos(yy - 0.4) * 0.5\nsegs = []\nfor i in range(ncurves):\n    xxx = xx + 0.02*rs.randn(nverts)\n    curve = np.column_stack([xxx, yy * 100])\n    segs.append(curve)\n\ncol = collections.LineCollection(segs, offsets=offs)\nax4.add_collection(col, autolim=True)\ncol.set_color(colors)\nax4.autoscale_view()\nax4.set_title('Successive data offsets')\nax4.set_xlabel('Zonal velocity component (m/s)')\nax4.set_ylabel('Depth (m)')\n# Reverse the y-axis so depth increases downward\nax4.set_ylim(ax4.get_ylim()[::-1])\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure`\n#    - `matplotlib.collections`\n#    - `matplotlib.collections.LineCollection`\n#    - `matplotlib.collections.RegularPolyCollection`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.axes.Axes.autoscale_view`\n#    - `matplotlib.transforms.Affine2D`\n#    - `matplotlib.transforms.Affine2D.scale`\n"
    },
    {
      "filename": "compound_path.py",
      "title": "Compound Path",
      "code": "\"\"\"\n=============\nCompound path\n=============\n\nMake a compound path -- in this case two simple polygons, a rectangle\nand a triangle.  Use ``CLOSEPOLY`` and ``MOVETO`` for the different parts of\nthe compound path\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nvertices = []\ncodes = []\n\ncodes = [Path.MOVETO] + [Path.LINETO]*3 + [Path.CLOSEPOLY]\nvertices = [(1, 1), (1, 2), (2, 2), (2, 1), (0, 0)]\n\ncodes += [Path.MOVETO] + [Path.LINETO]*2 + [Path.CLOSEPOLY]\nvertices += [(4, 4), (5, 5), (5, 4), (0, 0)]\n\npath = Path(vertices, codes)\n\npathpatch = PathPatch(path, facecolor='none', edgecolor='green')\n\nfig, ax = plt.subplots()\nax.add_patch(pathpatch)\nax.set_title('A compound path')\n\nax.autoscale_view()\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.axes.Axes.autoscale_view`\n"
    },
    {
      "filename": "dolphin.py",
      "title": "Dolphin",
      "code": "\"\"\"\n========\nDolphins\n========\n\nThis example shows how to draw, and manipulate shapes given vertices\nand nodes using the `~.path.Path`, `~.patches.PathPatch` and\n`~matplotlib.transforms` classes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\nfrom matplotlib.patches import Circle, PathPatch\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Affine2D\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nr = np.random.rand(50)\nt = np.random.rand(50) * np.pi * 2.0\nx = r * np.cos(t)\ny = r * np.sin(t)\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncircle = Circle((0, 0), 1, facecolor='none',\n                edgecolor=(0, 0.8, 0.8), linewidth=3, alpha=0.5)\nax.add_patch(circle)\n\nim = plt.imshow(np.random.random((100, 100)),\n                origin='lower', cmap=cm.winter,\n                interpolation='spline36',\n                extent=(-1, 1, -1, 1))\nim.set_clip_path(circle)\n\nplt.plot(x, y, 'o', color=(0.9, 0.9, 1.0), alpha=0.8)\n\n# Dolphin from OpenClipart library by Andy Fitzsimon\n#   <cc:License rdf:about=\"http://web.resource.org/cc/PublicDomain\">\n#     <cc:permits rdf:resource=\"http://web.resource.org/cc/Reproduction\"/>\n#     <cc:permits rdf:resource=\"http://web.resource.org/cc/Distribution\"/>\n#     <cc:permits rdf:resource=\"http://web.resource.org/cc/DerivativeWorks\"/>\n#   </cc:License>\n\ndolphin = \"\"\"\nM -0.59739425,160.18173 C -0.62740401,160.18885 -0.57867129,160.11183\n-0.57867129,160.11183 C -0.57867129,160.11183 -0.5438361,159.89315\n-0.39514638,159.81496 C -0.24645668,159.73678 -0.18316813,159.71981\n-0.18316813,159.71981 C -0.18316813,159.71981 -0.10322971,159.58124\n-0.057804323,159.58725 C -0.029723983,159.58913 -0.061841603,159.60356\n-0.071265813,159.62815 C -0.080250183,159.65325 -0.082918513,159.70554\n-0.061841203,159.71248 C -0.040763903,159.7194 -0.0066711426,159.71091\n0.077336307,159.73612 C 0.16879567,159.76377 0.28380306,159.86448\n0.31516668,159.91533 C 0.3465303,159.96618 0.5011127,160.1771\n0.5011127,160.1771 C 0.63668998,160.19238 0.67763022,160.31259\n0.66556395,160.32668 C 0.65339985,160.34212 0.66350443,160.33642\n0.64907098,160.33088 C 0.63463742,160.32533 0.61309688,160.297\n0.5789627,160.29339 C 0.54348657,160.28968 0.52329693,160.27674\n0.50728856,160.27737 C 0.49060916,160.27795 0.48965803,160.31565\n0.46114204,160.33673 C 0.43329696,160.35786 0.4570711,160.39871\n0.43309565,160.40685 C 0.4105108,160.41442 0.39416631,160.33027\n0.3954995,160.2935 C 0.39683269,160.25672 0.43807996,160.21522\n0.44567915,160.19734 C 0.45327833,160.17946 0.27946869,159.9424\n-0.061852613,159.99845 C -0.083965233,160.0427 -0.26176109,160.06683\n-0.26176109,160.06683 C -0.30127962,160.07028 -0.21167141,160.09731\n-0.24649368,160.1011 C -0.32642366,160.11569 -0.34521187,160.06895\n-0.40622293,160.0819 C -0.467234,160.09485 -0.56738444,160.17461\n-0.59739425,160.18173\n\"\"\"\n\nvertices = []\ncodes = []\nparts = dolphin.split()\ni = 0\ncode_map = {\n    'M': Path.MOVETO,\n    'C': Path.CURVE4,\n    'L': Path.LINETO,\n}\n\nwhile i < len(parts):\n    path_code = code_map[parts[i]]\n    npoints = Path.NUM_VERTICES_FOR_CODE[path_code]\n    codes.extend([path_code] * npoints)\n    vertices.extend([[*map(float, y.split(','))]\n                     for y in parts[i + 1:][:npoints]])\n    i += npoints + 1\nvertices = np.array(vertices)\nvertices[:, 1] -= 160\n\ndolphin_path = Path(vertices, codes)\ndolphin_patch = PathPatch(dolphin_path, facecolor=(0.6, 0.6, 0.6),\n                          edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch)\n\nvertices = Affine2D().rotate_deg(60).transform(vertices)\ndolphin_path2 = Path(vertices, codes)\ndolphin_patch2 = PathPatch(dolphin_path2, facecolor=(0.5, 0.5, 0.5),\n                           edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch2)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.transforms`\n#    - `matplotlib.transforms.Affine2D`\n#    - `matplotlib.transforms.Affine2D.rotate_deg`\n"
    },
    {
      "filename": "donut.py",
      "title": "Donut",
      "code": "r\"\"\"\n=============\nMmh Donuts!!!\n=============\n\nDraw donuts (miam!) using `~.path.Path`\\s and `~.patches.PathPatch`\\es.\nThis example shows the effect of the path's orientations in a compound path.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\n\ndef wise(v):\n    if v == 1:\n        return \"CCW\"\n    else:\n        return \"CW\"\n\n\ndef make_circle(r):\n    t = np.arange(0, np.pi * 2.0, 0.01)\n    t = t.reshape((len(t), 1))\n    x = r * np.cos(t)\n    y = r * np.sin(t)\n    return np.hstack((x, y))\n\nPath = mpath.Path\n\nfig, ax = plt.subplots()\n\ninside_vertices = make_circle(0.5)\noutside_vertices = make_circle(1.0)\ncodes = np.ones(\n    len(inside_vertices), dtype=mpath.Path.code_type) * mpath.Path.LINETO\ncodes[0] = mpath.Path.MOVETO\n\nfor i, (inside, outside) in enumerate(((1, 1), (1, -1), (-1, 1), (-1, -1))):\n    # Concatenate the inside and outside subpaths together, changing their\n    # order as needed\n    vertices = np.concatenate((outside_vertices[::outside],\n                               inside_vertices[::inside]))\n    # Shift the path\n    vertices[:, 0] += i * 2.5\n    # The codes will be all \"LINETO\" commands, except for \"MOVETO\"s at the\n    # beginning of each subpath\n    all_codes = np.concatenate((codes, codes))\n    # Create the Path object\n    path = mpath.Path(vertices, all_codes)\n    # Add plot it\n    patch = mpatches.PathPatch(path, facecolor='#885500', edgecolor='black')\n    ax.add_patch(patch)\n\n    ax.annotate(f\"Outside {wise(outside)},\\nInside {wise(inside)}\",\n                (i * 2.5, -1.5), va=\"top\", ha=\"center\")\n\nax.set_xlim(-2, 10)\nax.set_ylim(-3, 2)\nax.set_title('Mmm, donuts!')\nax.set_aspect(1.0)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.axes.Axes.annotate`\n#    - `matplotlib.axes.Axes.set_aspect`\n#    - `matplotlib.axes.Axes.set_xlim`\n#    - `matplotlib.axes.Axes.set_ylim`\n#    - `matplotlib.axes.Axes.set_title`\n"
    },
    {
      "filename": "ellipse_arrow.py",
      "title": "Ellipse Arrow",
      "code": "\"\"\"\n===================================\nEllipse with orientation arrow demo\n===================================\n\nThis demo shows how to draw an ellipse with\nan orientation arrow (clockwise or counterclockwise).\nCompare this to the :doc:`Ellipse collection example\n</gallery/shapes_and_collections/ellipse_collection>`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Ellipse\nfrom matplotlib.transforms import Affine2D\n\n# Create a figure and axis\nfig, ax = plt.subplots(subplot_kw={\"aspect\": \"equal\"})\n\nellipse = Ellipse(\n    xy=(2, 4),\n    width=30,\n    height=20,\n    angle=35,\n    facecolor=\"none\",\n    edgecolor=\"b\"\n)\nax.add_patch(ellipse)\n\n# Plot an arrow marker at the end point of minor axis\nvertices = ellipse.get_co_vertices()\nt = Affine2D().rotate_deg(ellipse.angle)\nax.plot(\n    vertices[0][0],\n    vertices[0][1],\n    color=\"b\",\n    marker=MarkerStyle(\">\", \"full\", t),\n    markersize=10\n)\n# Note: To reverse the orientation arrow, switch the marker type from > to <.\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Ellipse`\n"
    },
    {
      "filename": "ellipse_collection.py",
      "title": "Ellipse Collection",
      "code": "\"\"\"\n==================\nEllipse Collection\n==================\n\nDrawing a collection of ellipses. While this would equally be possible using\na `~.collections.EllipseCollection` or `~.collections.PathCollection`, the use\nof an `~.collections.EllipseCollection` allows for much shorter code.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import EllipseCollection\n\nx = np.arange(10)\ny = np.arange(15)\nX, Y = np.meshgrid(x, y)\n\nXY = np.column_stack((X.ravel(), Y.ravel()))\n\nww = X / 10.0\nhh = Y / 15.0\naa = X * 9\n\n\nfig, ax = plt.subplots()\n\nec = EllipseCollection(ww, hh, aa, units='x', offsets=XY,\n                       offset_transform=ax.transData)\nec.set_array((X + Y).ravel())\nax.add_collection(ec)\nax.autoscale_view()\nax.set_xlabel('X')\nax.set_ylabel('y')\ncbar = plt.colorbar(ec)\ncbar.set_label('X+Y')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.collections`\n#    - `matplotlib.collections.EllipseCollection`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.axes.Axes.autoscale_view`\n#    - `matplotlib.cm.ScalarMappable.set_array`\n"
    },
    {
      "filename": "ellipse_demo.py",
      "title": "Ellipse Demo",
      "code": "\"\"\"\n============\nEllipse Demo\n============\n\nDraw many ellipses. Here individual ellipses are drawn. Compare this\nto the :doc:`Ellipse collection example\n</gallery/shapes_and_collections/ellipse_collection>`.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nNUM = 250\n\nells = [Ellipse(xy=np.random.rand(2) * 10,\n                width=np.random.rand(), height=np.random.rand(),\n                angle=np.random.rand() * 360)\n        for i in range(NUM)]\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 10), ylim=(0, 10), aspect=\"equal\")\n\nfor e in ells:\n    ax.add_artist(e)\n    e.set_clip_box(ax.bbox)\n    e.set_alpha(np.random.rand())\n    e.set_facecolor(np.random.rand(3))\n\nplt.show()\n\n# %%\n# ===============\n# Ellipse Rotated\n# ===============\n#\n# Draw many ellipses with different angles.\n#\n\nangle_step = 45  # degrees\nangles = np.arange(0, 180, angle_step)\n\nfig, ax = plt.subplots()\nax.set(xlim=(-2.2, 2.2), ylim=(-2.2, 2.2), aspect=\"equal\")\n\nfor angle in angles:\n    ellipse = Ellipse((0, 0), 4, 2, angle=angle, alpha=0.1)\n    ax.add_artist(ellipse)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Ellipse`\n#    - `matplotlib.axes.Axes.add_artist`\n#    - `matplotlib.artist.Artist.set_clip_box`\n#    - `matplotlib.artist.Artist.set_alpha`\n#    - `matplotlib.patches.Patch.set_facecolor`\n"
    },
    {
      "filename": "fancybox_demo.py",
      "title": "Fancybox Demo",
      "code": "\"\"\"\n===================\nDrawing fancy boxes\n===================\n\nThe following examples show how to plot boxes (`.FancyBboxPatch`) with different\nvisual properties.\n\"\"\"\n\nimport inspect\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatch\nfrom matplotlib.patches import FancyBboxPatch\nimport matplotlib.transforms as mtransforms\n\n# %%\n# Box styles\n# ----------\n# `.FancyBboxPatch` supports different `.BoxStyle`\\s. Note that `~.Axes.text`\n# allows to draw a box around the text by adding the ``bbox`` parameter. Therefore,\n# you don't see explicit `.FancyBboxPatch` and `.BoxStyle` calls in the following\n# example.\n\nstyles = mpatch.BoxStyle.get_styles()\nncol = 2\nnrow = (len(styles) + 1) // ncol\naxs = (plt.figure(figsize=(3 * ncol, 1 + nrow))\n       .add_gridspec(1 + nrow, ncol, wspace=.5).subplots())\nfor ax in axs.flat:\n    ax.set_axis_off()\nfor ax in axs[0, :]:\n    ax.text(.2, .5, \"boxstyle\",\n            transform=ax.transAxes, size=\"large\", color=\"tab:blue\",\n            horizontalalignment=\"right\", verticalalignment=\"center\")\n    ax.text(.4, .5, \"default parameters\",\n            transform=ax.transAxes,\n            horizontalalignment=\"left\", verticalalignment=\"center\")\nfor ax, (stylename, stylecls) in zip(axs[1:, :].T.flat, styles.items()):\n    ax.text(.2, .5, stylename, bbox=dict(boxstyle=stylename, fc=\"w\", ec=\"k\"),\n            transform=ax.transAxes, size=\"large\", color=\"tab:blue\",\n            horizontalalignment=\"right\", verticalalignment=\"center\")\n    ax.text(.4, .5, str(inspect.signature(stylecls))[1:-1].replace(\", \", \"\\n\"),\n            transform=ax.transAxes,\n            horizontalalignment=\"left\", verticalalignment=\"center\")\n\n\n# %%\n# Parameters for modifying the box\n# --------------------------------\n# `.BoxStyle`\\s have additional parameters to configure their appearance.\n# For example, \"round\" boxes can have ``pad`` and ``rounding``.\n#\n# Additionally, the `.FancyBboxPatch` parameters ``mutation_scale`` and\n# ``mutation_aspect`` scale the box appearance.\n\ndef add_fancy_patch_around(ax, bb, **kwargs):\n    kwargs = {\n        'facecolor': (1, 0.8, 1, 0.5),\n        'edgecolor': (1, 0.5, 1, 0.5),\n        **kwargs\n    }\n    fancy = FancyBboxPatch(bb.p0, bb.width, bb.height, **kwargs)\n    ax.add_patch(fancy)\n    return fancy\n\n\ndef draw_control_points_for_patches(ax):\n    for patch in ax.patches:\n        patch.axes.plot(*patch.get_path().vertices.T, \".\",\n                        c=patch.get_edgecolor())\n\n\nfig, axs = plt.subplots(2, 2, figsize=(8, 8))\n\n# Bbox object around which the fancy box will be drawn.\nbb = mtransforms.Bbox([[0.3, 0.4], [0.7, 0.6]])\n\nax = axs[0, 0]\n# a fancy box with round corners. pad=0.1\nadd_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.1\")\nax.set(xlim=(0, 1), ylim=(0, 1), aspect=1,\n       title='boxstyle=\"round,pad=0.1\"')\n\nax = axs[0, 1]\n# bbox=round has two optional arguments: pad and rounding_size.\n# They can be set during the initialization.\nfancy = add_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.1\")\n# The boxstyle and its argument can be later modified with set_boxstyle().\n# Note that the old attributes are simply forgotten even if the boxstyle name\n# is same.\nfancy.set_boxstyle(\"round,pad=0.1,rounding_size=0.2\")\n# or: fancy.set_boxstyle(\"round\", pad=0.1, rounding_size=0.2)\nax.set(xlim=(0, 1), ylim=(0, 1), aspect=1,\n       title='boxstyle=\"round,pad=0.1,rounding_size=0.2\"')\n\nax = axs[1, 0]\n# mutation_scale determines the overall scale of the mutation, i.e. both pad\n# and rounding_size is scaled according to this value.\nadd_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.1\", mutation_scale=2)\nax.set(xlim=(0, 1), ylim=(0, 1), aspect=1,\n       title='boxstyle=\"round,pad=0.1\"\\n mutation_scale=2')\n\nax = axs[1, 1]\n# mutation_aspect scales the vertical influence of the parameters (technically,\n# it scales the height of the box down by mutation_aspect, applies the box parameters\n# and scales the result back up). In effect, the vertical pad is scaled to\n# pad * mutation_aspect, e.g. mutation_aspect=0.5 halves the vertical pad.\nadd_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.1\", mutation_aspect=0.5)\nax.set(xlim=(0, 1), ylim=(0, 1),\n       title='boxstyle=\"round,pad=0.1\"\\nmutation_aspect=0.5')\n\nfor ax in axs.flat:\n    draw_control_points_for_patches(ax)\n    # Draw the original bbox (using boxstyle=square with pad=0).\n    add_fancy_patch_around(ax, bb, boxstyle=\"square,pad=0\",\n                           edgecolor=\"black\", facecolor=\"none\", zorder=10)\n\nfig.tight_layout()\n\n\nplt.show()\n\n# %%\n# Creating visually constant padding on non-equal aspect Axes\n# -----------------------------------------------------------\n# Since padding is in box coordinates, i.e. usually data coordinates,\n# a given padding is rendered to different visual sizes if the\n# Axes aspect is not 1.\n# To get visually equal vertical and horizontal padding, set the\n# mutation_aspect to the inverse of the Axes aspect. This scales\n# the vertical padding appropriately.\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6.5, 5))\n\n# original boxes\nbb = mtransforms.Bbox([[-0.5, -0.5], [0.5, 0.5]])\nadd_fancy_patch_around(ax1, bb, boxstyle=\"square,pad=0\",\n                       edgecolor=\"black\", facecolor=\"none\", zorder=10)\nadd_fancy_patch_around(ax2, bb, boxstyle=\"square,pad=0\",\n                       edgecolor=\"black\", facecolor=\"none\", zorder=10)\nax1.set(xlim=(-1.5, 1.5), ylim=(-1.5, 1.5), aspect=2)\nax2.set(xlim=(-1.5, 1.5), ylim=(-1.5, 1.5), aspect=2)\n\n\nfancy = add_fancy_patch_around(\n    ax1, bb, boxstyle=\"round,pad=0.5\")\nax1.set_title(\"aspect=2\\nmutation_aspect=1\")\n\nfancy = add_fancy_patch_around(\n    ax2, bb, boxstyle=\"round,pad=0.5\", mutation_aspect=0.5)\nax2.set_title(\"aspect=2\\nmutation_aspect=0.5\")\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.FancyBboxPatch`\n#    - `matplotlib.patches.BoxStyle`\n#    - ``matplotlib.patches.BoxStyle.get_styles``\n#    - `matplotlib.transforms.Bbox`\n#    - `matplotlib.figure.Figure.text`\n#    - `matplotlib.axes.Axes.text`\n"
    },
    {
      "filename": "hatch_demo.py",
      "title": "Hatch Demo",
      "code": "\"\"\"\n==========\nHatch demo\n==========\n\nHatches can be added to most polygons in Matplotlib, including `~.Axes.bar`,\n`~.Axes.fill_between`, `~.Axes.contourf`, and children of `~.patches.Polygon`.\nThey are currently supported in the PS, PDF, SVG, macosx, and Agg backends. The WX\nand Cairo backends do not currently support hatching.\n\nSee also :doc:`/gallery/images_contours_and_fields/contourf_hatching` for\nan example using `~.Axes.contourf`, and\n:doc:`/gallery/shapes_and_collections/hatch_style_reference` for swatches\nof the existing hatches.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse, Polygon\n\nx = np.arange(1, 5)\ny1 = np.arange(1, 5)\ny2 = np.ones(y1.shape) * 4\n\nfig = plt.figure()\naxs = fig.subplot_mosaic([['bar1', 'patches'], ['bar2', 'patches']])\n\naxs['bar1'].bar(x, y1, edgecolor='black', hatch=\"/\")\naxs['bar1'].bar(x, y2, bottom=y1, edgecolor='black', hatch='//')\n\naxs['bar2'].bar(x, y1, edgecolor='black', hatch=['--', '+', 'x', '\\\\'])\naxs['bar2'].bar(x, y2, bottom=y1, edgecolor='black',\n                hatch=['*', 'o', 'O', '.'])\n\nx = np.arange(0, 40, 0.2)\naxs['patches'].fill_between(x, np.sin(x) * 4 + 30, y2=0,\n                            hatch='///', zorder=2, fc='c')\naxs['patches'].add_patch(Ellipse((4, 50), 10, 10, fill=True,\n                                 hatch='*', facecolor='y'))\naxs['patches'].add_patch(Polygon([(10, 20), (30, 50), (50, 10)],\n                                 hatch='\\\\/...', facecolor='g'))\naxs['patches'].set_xlim([0, 40])\naxs['patches'].set_ylim([10, 60])\naxs['patches'].set_aspect(1)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Ellipse`\n#    - `matplotlib.patches.Polygon`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.patches.Patch.set_hatch`\n#    - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`\n"
    },
    {
      "filename": "hatch_style_reference.py",
      "title": "Hatch Style Reference",
      "code": "\"\"\"\n=====================\nHatch style reference\n=====================\n\nHatches can be added to most polygons in Matplotlib, including `~.Axes.bar`,\n`~.Axes.fill_between`, `~.Axes.contourf`, and children of `~.patches.Polygon`.\nThey are currently supported in the PS, PDF, SVG, macosx, and Agg backends. The WX\nand Cairo backends do not currently support hatching.\n\nSee also :doc:`/gallery/images_contours_and_fields/contourf_hatching` for\nan example using `~.Axes.contourf`, and\n:doc:`/gallery/shapes_and_collections/hatch_demo` for more usage examples.\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.patches import Rectangle\n\nfig, axs = plt.subplots(2, 5, layout='constrained', figsize=(6.4, 3.2))\n\nhatches = ['/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*']\n\n\ndef hatches_plot(ax, h):\n    ax.add_patch(Rectangle((0, 0), 2, 2, fill=False, hatch=h))\n    ax.text(1, -0.5, f\"' {h} '\", size=15, ha=\"center\")\n    ax.axis('equal')\n    ax.axis('off')\n\nfor ax, h in zip(axs.flat, hatches):\n    hatches_plot(ax, h)\n\n# %%\n# Hatching patterns can be repeated to increase the density.\n\nfig, axs = plt.subplots(2, 5, layout='constrained', figsize=(6.4, 3.2))\n\nhatches = ['//', '\\\\\\\\', '||', '--', '++', 'xx', 'oo', 'OO', '..', '**']\n\nfor ax, h in zip(axs.flat, hatches):\n    hatches_plot(ax, h)\n\n# %%\n# Hatching patterns can be combined to create additional patterns.\n\nfig, axs = plt.subplots(2, 5, layout='constrained', figsize=(6.4, 3.2))\n\nhatches = ['/o', '\\\\|', '|*', '-\\\\', '+o', 'x*', 'o-', 'O|', 'O.', '*-']\n\nfor ax, h in zip(axs.flat, hatches):\n    hatches_plot(ax, h)\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Rectangle`\n#    - `matplotlib.axes.Axes.add_patch`\n#    - `matplotlib.axes.Axes.text`\n#\n# .. tags::\n#\n#    purpose: reference\n"
    },
    {
      "filename": "line_collection.py",
      "title": "Line Collection",
      "code": "\"\"\"\n==========================================\nPlot multiple lines using a LineCollection\n==========================================\n\nMatplotlib can efficiently draw multiple lines at once using a `~.LineCollection`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import LineCollection\n\ncolors = [\"indigo\", \"blue\", \"green\", \"yellow\", \"orange\", \"red\"]\n\n# create a list of half-circles with varying radii\ntheta = np.linspace(0, np.pi, 36)\nradii = np.linspace(4, 5, num=len(colors))\narcs = [np.column_stack([r * np.cos(theta), r * np.sin(theta)]) for r in radii]\n\nfig, ax = plt.subplots(figsize=(6.4, 3.2))\n# set axes limits manually because Collections do not take part in autoscaling\nax.set_xlim(-6, 6)\nax.set_ylim(0, 6)\nax.set_aspect(\"equal\")  # to make the arcs look circular\n\n# create a LineCollection with the half-circles\n# its properties can be set per line by passing a sequence (here used for *colors*)\n# or they can be set for all lines by passing a scalar (here used for *linewidths*)\nline_collection = LineCollection(arcs, colors=colors, linewidths=4)\nax.add_collection(line_collection)\n\nplt.show()\n\n# %%\n# Instead of passing a list of colors (``colors=colors``), we can alternatively use\n# colormapping. The lines are then color-coded based on an additional array of values\n# passed to the *array* parameter. In the below example, we color the lines based on\n# their radius by passing ``array=radii``.\n\nnum_arcs = 15\ntheta = np.linspace(0, np.pi, 36)\nradii = np.linspace(4, 5.5, num=num_arcs)\narcs = [np.column_stack([r * np.cos(theta), r * np.sin(theta)]) for r in radii]\n\nfig, ax = plt.subplots(figsize=(6.4, 3))\n# set axes limits manually because Collections do not take part in autoscaling\nax.set_xlim(-6, 6)\nax.set_ylim(0, 6)\nax.set_aspect(\"equal\")  # to make the arcs look circular\n\n# create a LineCollection with the half-circles and color mapping\nline_collection = LineCollection(arcs, array=radii, cmap=\"rainbow\")\nax.add_collection(line_collection)\n\nfig.colorbar(line_collection, label=\"Radius\")\nax.set_title(\"Line Collection with mapped colors\")\n\nplt.show()\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.collections.LineCollection`\n#    - `matplotlib.collections.Collection.set_array`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n"
    },
    {
      "filename": "patch_collection.py",
      "title": "Patch Collection",
      "code": "\"\"\"\n============================\nCircles, Wedges and Polygons\n============================\n\nThis example demonstrates how to use `.collections.PatchCollection`.\n\nSee also :doc:`/gallery/shapes_and_collections/artist_reference`, which instead\nadds each artist separately to its own Axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Circle, Polygon, Wedge\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\n\nresolution = 50  # the number of vertices\nN = 3\nx = np.random.rand(N)\ny = np.random.rand(N)\nradii = 0.1*np.random.rand(N)\npatches = []\nfor x1, y1, r in zip(x, y, radii):\n    circle = Circle((x1, y1), r)\n    patches.append(circle)\n\nx = np.random.rand(N)\ny = np.random.rand(N)\nradii = 0.1*np.random.rand(N)\ntheta1 = 360.0*np.random.rand(N)\ntheta2 = 360.0*np.random.rand(N)\nfor x1, y1, r, t1, t2 in zip(x, y, radii, theta1, theta2):\n    wedge = Wedge((x1, y1), r, t1, t2)\n    patches.append(wedge)\n\n# Some limiting conditions on Wedge\npatches += [\n    Wedge((.3, .7), .1, 0, 360),             # Full circle\n    Wedge((.7, .8), .2, 0, 360, width=0.05),  # Full ring\n    Wedge((.8, .3), .2, 0, 45),              # Full sector\n    Wedge((.8, .3), .2, 45, 90, width=0.10),  # Ring sector\n]\n\nfor i in range(N):\n    polygon = Polygon(np.random.rand(N, 2), closed=True)\n    patches.append(polygon)\n\ncolors = 100 * np.random.rand(len(patches))\np = PatchCollection(patches, alpha=0.4)\np.set_array(colors)\nax.add_collection(p)\nfig.colorbar(p, ax=ax)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.patches.Wedge`\n#    - `matplotlib.patches.Polygon`\n#    - `matplotlib.collections.PatchCollection`\n#    - `matplotlib.collections.Collection.set_array`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.figure.Figure.colorbar`\n"
    },
    {
      "filename": "path_patch.py",
      "title": "Path Patch",
      "code": "r\"\"\"\n================\nPathPatch object\n================\n\nThis example shows how to create `~.path.Path` and `~.patches.PathPatch`\nobjects through Matplotlib's API.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\nfig, ax = plt.subplots()\n\nPath = mpath.Path\npath_data = [\n    (Path.MOVETO, (1.58, -2.57)),\n    (Path.CURVE4, (0.35, -1.1)),\n    (Path.CURVE4, (-1.75, 2.0)),\n    (Path.CURVE4, (0.375, 2.0)),\n    (Path.LINETO, (0.85, 1.15)),\n    (Path.CURVE4, (2.2, 3.2)),\n    (Path.CURVE4, (3, 0.05)),\n    (Path.CURVE4, (2.0, -0.5)),\n    (Path.CLOSEPOLY, (1.58, -2.57)),\n    ]\ncodes, verts = zip(*path_data)\npath = mpath.Path(verts, codes)\npatch = mpatches.PathPatch(path, facecolor='r', alpha=0.5)\nax.add_patch(patch)\n\n# plot control points and connecting lines\nx, y = zip(*path.vertices)\nline, = ax.plot(x, y, 'go-')\n\nax.grid()\nax.axis('equal')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.axes.Axes.add_patch`\n"
    },
    {
      "filename": "quad_bezier.py",
      "title": "Quad Bezier",
      "code": "\"\"\"\n============\nBezier curve\n============\n\nThis example showcases the `~.patches.PathPatch` object to create a Bezier\npolycurve path patch.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\nPath = mpath.Path\n\nfig, ax = plt.subplots()\npp1 = mpatches.PathPatch(\n    Path([(0, 0), (1, 0), (1, 1), (0, 0)],\n         [Path.MOVETO, Path.CURVE3, Path.CURVE3, Path.CLOSEPOLY]),\n    fc=\"none\", transform=ax.transData)\n\nax.add_patch(pp1)\nax.plot([0.75], [0.25], \"ro\")\nax.set_title('The red point should be on the path')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.PathPatch`\n#    - `matplotlib.axes.Axes.add_patch`\n"
    },
    {
      "filename": "scatter.py",
      "title": "Scatter",
      "code": "\"\"\"\n============\nScatter plot\n============\n\nThis example showcases a simple scatter plot.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nN = 50\nx = np.random.rand(N)\ny = np.random.rand(N)\ncolors = np.random.rand(N)\narea = (30 * np.random.rand(N))**2  # 0 to 15 point radii\n\nplt.scatter(x, y, s=area, c=colors, alpha=0.5)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.scatter` / `matplotlib.pyplot.scatter`\n"
    }
  ],
  "showcase": [
    {
      "filename": "anatomy.py",
      "title": "Anatomy",
      "code": "\"\"\"\n===================\nAnatomy of a figure\n===================\n\nThis figure shows the name of several matplotlib elements composing a figure\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle\nfrom matplotlib.patheffects import withStroke\nfrom matplotlib.ticker import AutoMinorLocator, MultipleLocator\n\nroyal_blue = [0, 20/256, 82/256]\n\n\n# make the figure\n\nnp.random.seed(19680801)\n\nX = np.linspace(0.5, 3.5, 100)\nY1 = 3+np.cos(X)\nY2 = 1+np.cos(1+X/0.75)/2\nY3 = np.random.uniform(Y1, Y2, len(X))\n\nfig = plt.figure(figsize=(7.5, 7.5))\nax = fig.add_axes([0.2, 0.17, 0.68, 0.7], aspect=1)\n\nax.xaxis.set_major_locator(MultipleLocator(1.000))\nax.xaxis.set_minor_locator(AutoMinorLocator(4))\nax.yaxis.set_major_locator(MultipleLocator(1.000))\nax.yaxis.set_minor_locator(AutoMinorLocator(4))\nax.xaxis.set_minor_formatter(\"{x:.2f}\")\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nax.tick_params(which='major', width=1.0, length=10, labelsize=14)\nax.tick_params(which='minor', width=1.0, length=5, labelsize=10,\n               labelcolor='0.25')\n\nax.grid(linestyle=\"--\", linewidth=0.5, color='.25', zorder=-10)\n\nax.plot(X, Y1, c='C0', lw=2.5, label=\"Blue signal\", zorder=10)\nax.plot(X, Y2, c='C1', lw=2.5, label=\"Orange signal\")\nax.plot(X[::3], Y3[::3], linewidth=0, markersize=9,\n        marker='s', markerfacecolor='none', markeredgecolor='C4',\n        markeredgewidth=2.5)\n\nax.set_title(\"Anatomy of a figure\", fontsize=20, verticalalignment='bottom')\nax.set_xlabel(\"x Axis label\", fontsize=14)\nax.set_ylabel(\"y Axis label\", fontsize=14)\nax.legend(loc=\"upper right\", fontsize=14)\n\n\n# Annotate the figure\n\ndef annotate(x, y, text, code):\n    # Circle marker\n    c = Circle((x, y), radius=0.15, clip_on=False, zorder=10, linewidth=2.5,\n               edgecolor=royal_blue + [0.6], facecolor='none',\n               path_effects=[withStroke(linewidth=7, foreground='white')])\n    ax.add_artist(c)\n\n    # use path_effects as a background for the texts\n    # draw the path_effects and the colored text separately so that the\n    # path_effects cannot clip other texts\n    for path_effects in [[withStroke(linewidth=7, foreground='white')], []]:\n        color = 'white' if path_effects else royal_blue\n        ax.text(x, y-0.2, text, zorder=100,\n                ha='center', va='top', weight='bold', color=color,\n                style='italic', fontfamily='monospace',\n                path_effects=path_effects)\n\n        color = 'white' if path_effects else 'black'\n        ax.text(x, y-0.33, code, zorder=100,\n                ha='center', va='top', weight='normal', color=color,\n                fontfamily='monospace', fontsize='medium',\n                path_effects=path_effects)\n\n\nannotate(3.5, -0.13, \"Minor tick label\", \"ax.xaxis.set_minor_formatter\")\nannotate(-0.03, 1.0, \"Major tick\", \"ax.yaxis.set_major_locator\")\nannotate(0.00, 3.75, \"Minor tick\", \"ax.yaxis.set_minor_locator\")\nannotate(-0.15, 3.00, \"Major tick label\", \"ax.yaxis.set_major_formatter\")\nannotate(1.68, -0.39, \"xlabel\", \"ax.set_xlabel\")\nannotate(-0.38, 1.67, \"ylabel\", \"ax.set_ylabel\")\nannotate(1.52, 4.15, \"Title\", \"ax.set_title\")\nannotate(1.75, 2.80, \"Line\", \"ax.plot\")\nannotate(2.25, 1.54, \"Markers\", \"ax.scatter\")\nannotate(3.00, 3.00, \"Grid\", \"ax.grid\")\nannotate(3.60, 3.58, \"Legend\", \"ax.legend\")\nannotate(2.5, 0.55, \"Axes\", \"fig.subplots\")\nannotate(4, 4.5, \"Figure\", \"plt.figure\")\nannotate(0.65, 0.01, \"x Axis\", \"ax.xaxis\")\nannotate(0, 0.36, \"y Axis\", \"ax.yaxis\")\nannotate(4.0, 0.7, \"Spine\", \"ax.spines\")\n\n# frame around figure\nfig.patch.set(linewidth=4, edgecolor='0.5')\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.figure`\n#    - `matplotlib.axes.Axes.text`\n#    - `matplotlib.axis.Axis.set_minor_formatter`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.axis.Axis.set_minor_locator`\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.patheffects.withStroke`\n#    - `matplotlib.ticker.FuncFormatter`\n"
    },
    {
      "filename": "firefox.py",
      "title": "Firefox",
      "code": "\"\"\"\n=======\nFirefox\n=======\n\nThis example shows how to create the Firefox logo with path and patches.\n\"\"\"\n\nimport re\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as patches\nfrom matplotlib.path import Path\n\n# From: https://dmitrybaranovskiy.github.io/raphael/icons/#firefox\nfirefox = \"M28.4,22.469c0.479-0.964,0.851-1.991,1.095-3.066c0.953-3.661,0.666-6.854,0.666-6.854l-0.327,2.104c0,0-0.469-3.896-1.044-5.353c-0.881-2.231-1.273-2.214-1.274-2.21c0.542,1.379,0.494,2.169,0.483,2.288c-0.01-0.016-0.019-0.032-0.027-0.047c-0.131-0.324-0.797-1.819-2.225-2.878c-2.502-2.481-5.943-4.014-9.745-4.015c-4.056,0-7.705,1.745-10.238,4.525C5.444,6.5,5.183,5.938,5.159,5.317c0,0-0.002,0.002-0.006,0.005c0-0.011-0.003-0.021-0.003-0.031c0,0-1.61,1.247-1.436,4.612c-0.299,0.574-0.56,1.172-0.777,1.791c-0.375,0.817-0.75,2.004-1.059,3.746c0,0,0.133-0.422,0.399-0.988c-0.064,0.482-0.103,0.971-0.116,1.467c-0.09,0.845-0.118,1.865-0.039,3.088c0,0,0.032-0.406,0.136-1.021c0.834,6.854,6.667,12.165,13.743,12.165l0,0c1.86,0,3.636-0.37,5.256-1.036C24.938,27.771,27.116,25.196,28.4,22.469zM16.002,3.356c2.446,0,4.73,0.68,6.68,1.86c-2.274-0.528-3.433-0.261-3.423-0.248c0.013,0.015,3.384,0.589,3.981,1.411c0,0-1.431,0-2.856,0.41c-0.065,0.019,5.242,0.663,6.327,5.966c0,0-0.582-1.213-1.301-1.42c0.473,1.439,0.351,4.17-0.1,5.528c-0.058,0.174-0.118-0.755-1.004-1.155c0.284,2.037-0.018,5.268-1.432,6.158c-0.109,0.07,0.887-3.189,0.201-1.93c-4.093,6.276-8.959,2.539-10.934,1.208c1.585,0.388,3.267,0.108,4.242-0.559c0.982-0.672,1.564-1.162,2.087-1.047c0.522,0.117,0.87-0.407,0.464-0.872c-0.405-0.466-1.392-1.105-2.725-0.757c-0.94,0.247-2.107,1.287-3.886,0.233c-1.518-0.899-1.507-1.63-1.507-2.095c0-0.366,0.257-0.88,0.734-1.028c0.58,0.062,1.044,0.214,1.537,0.466c0.005-0.135,0.006-0.315-0.001-0.519c0.039-0.077,0.015-0.311-0.047-0.596c-0.036-0.287-0.097-0.582-0.19-0.851c0.01-0.002,0.017-0.007,0.021-0.021c0.076-0.344,2.147-1.544,2.299-1.659c0.153-0.114,0.55-0.378,0.506-1.183c-0.015-0.265-0.058-0.294-2.232-0.286c-0.917,0.003-1.425-0.894-1.589-1.245c0.222-1.231,0.863-2.11,1.919-2.704c0.02-0.011,0.015-0.021-0.008-0.027c0.219-0.127-2.524-0.006-3.76,1.604C9.674,8.045,9.219,7.95,8.71,7.95c-0.638,0-1.139,0.07-1.603,0.187c-0.05,0.013-0.122,0.011-0.208-0.001C6.769,8.04,6.575,7.88,6.365,7.672c0.161-0.18,0.324-0.356,0.495-0.526C9.201,4.804,12.43,3.357,16.002,3.356z\"  # noqa\n\n\ndef svg_parse(path):\n    commands = {'M': (Path.MOVETO,),\n                'L': (Path.LINETO,),\n                'Q': (Path.CURVE3,)*2,\n                'C': (Path.CURVE4,)*3,\n                'Z': (Path.CLOSEPOLY,)}\n    vertices = []\n    codes = []\n    cmd_values = re.split(\"([A-Za-z])\", path)[1:]  # Split over commands.\n    for cmd, values in zip(cmd_values[::2], cmd_values[1::2]):\n        # Numbers are separated either by commas, or by +/- signs (but not at\n        # the beginning of the string).\n        points = ([*map(float, re.split(\",|(?<!^)(?=[+-])\", values))] if values\n                  else [(0., 0.)])  # Only for \"z/Z\" (CLOSEPOLY).\n        points = np.reshape(points, (-1, 2))\n        if cmd.islower():\n            points += vertices[-1][-1]\n        codes.extend(commands[cmd.upper()])\n        vertices.append(points)\n    return np.array(codes), np.concatenate(vertices)\n\n\n# SVG to Matplotlib\ncodes, verts = svg_parse(firefox)\npath = Path(verts, codes)\n\nxmin, ymin = verts.min(axis=0) - 1\nxmax, ymax = verts.max(axis=0) + 1\n\nfig = plt.figure(figsize=(5, 5), facecolor=\"0.75\")  # gray background\nax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1,\n                  xlim=(xmin, xmax),  # centering\n                  ylim=(ymax, ymin),  # centering, upside down\n                  xticks=[], yticks=[])  # no ticks\n\n# White outline (width = 6)\nax.add_patch(patches.PathPatch(path, facecolor='none', edgecolor='w', lw=6))\n# Actual shape with black outline\nax.add_patch(patches.PathPatch(path, facecolor='orange', edgecolor='k', lw=2))\n\nplt.show()  # Display\n"
    },
    {
      "filename": "integral.py",
      "title": "Integral",
      "code": "\"\"\"\n==================================\nIntegral as the area under a curve\n==================================\n\nAlthough this is a simple example, it demonstrates some important tweaks:\n\n* A simple line plot with custom color and line width.\n* A shaded region created using a Polygon patch.\n* A text label with mathtext rendering.\n* figtext calls to label the x- and y-axes.\n* Use of axis spines to hide the top and right spines.\n* Custom tick placement and labels.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n\ndef func(x):\n    return (x - 3) * (x - 5) * (x - 7) + 85\n\n\na, b = 2, 9  # integral limits\nx = np.linspace(0, 10)\ny = func(x)\n\nfig, ax = plt.subplots()\nax.plot(x, y, 'r', linewidth=2)\nax.set_ylim(bottom=0)\n\n# Make the shaded region\nix = np.linspace(a, b)\niy = func(ix)\nverts = [(a, 0), *zip(ix, iy), (b, 0)]\npoly = Polygon(verts, facecolor='0.9', edgecolor='0.5')\nax.add_patch(poly)\n\nax.text(0.5 * (a + b), 30, r\"$\\int_a^b f(x)\\mathrm{d}x$\",\n        horizontalalignment='center', fontsize=20)\n\nfig.text(0.9, 0.05, '$x$')\nfig.text(0.1, 0.9, '$y$')\n\nax.spines[['top', 'right']].set_visible(False)\nax.set_xticks([a, b], labels=['$a$', '$b$'])\nax.set_yticks([])\n\nplt.show()\n"
    },
    {
      "filename": "mandelbrot.py",
      "title": "Mandelbrot",
      "code": "\"\"\"\n===================================\nShaded & power normalized rendering\n===================================\n\nThe Mandelbrot set rendering can be improved by using a normalized recount\nassociated with a power normalized colormap (gamma=0.3). Rendering can be\nfurther enhanced thanks to shading.\n\nThe ``maxiter`` gives the precision of the computation. ``maxiter=200`` should\ntake a few seconds on most modern laptops.\n\"\"\"\nimport numpy as np\n\n\ndef mandelbrot_set(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon=2.0):\n    X = np.linspace(xmin, xmax, xn).astype(np.float32)\n    Y = np.linspace(ymin, ymax, yn).astype(np.float32)\n    C = X + Y[:, None] * 1j\n    N = np.zeros_like(C, dtype=int)\n    Z = np.zeros_like(C)\n    for n in range(maxiter):\n        I = abs(Z) < horizon\n        N[I] = n\n        Z[I] = Z[I]**2 + C[I]\n    N[N == maxiter-1] = 0\n    return Z, N\n\n\nif __name__ == '__main__':\n    import time\n\n    import matplotlib.pyplot as plt\n\n    import matplotlib\n    from matplotlib import colors\n\n    xmin, xmax, xn = -2.25, +0.75, 3000 // 2\n    ymin, ymax, yn = -1.25, +1.25, 2500 // 2\n    maxiter = 200\n    horizon = 2.0 ** 40\n    log_horizon = np.log2(np.log(horizon))\n    Z, N = mandelbrot_set(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon)\n\n    # Normalized recount as explained in:\n    # https://linas.org/art-gallery/escape/smooth.html\n    # https://web.archive.org/web/20160331171238/https://www.ibm.com/developerworks/community/blogs/jfp/entry/My_Christmas_Gift?lang=en\n\n    # This line will generate warnings for null values, but it is faster to\n    # process them afterwards using the nan_to_num\n    with np.errstate(invalid='ignore'):\n        M = np.nan_to_num(N + 1 - np.log2(np.log(abs(Z))) + log_horizon)\n\n    dpi = 72\n    width = 10\n    height = 10*yn/xn\n    fig = plt.figure(figsize=(width, height), dpi=dpi)\n    ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1)\n\n    # Shaded rendering\n    light = colors.LightSource(azdeg=315, altdeg=10)\n    M = light.shade(M, cmap=plt.cm.hot, vert_exag=1.5,\n                    norm=colors.PowerNorm(0.3), blend_mode='hsv')\n    ax.imshow(M, extent=[xmin, xmax, ymin, ymax], interpolation=\"bicubic\")\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    # Some advertisement for matplotlib\n    year = time.strftime(\"%Y\")\n    text = (\"The Mandelbrot fractal set\\n\"\n            \"Rendered with matplotlib %s, %s - https://matplotlib.org\"\n            % (matplotlib.__version__, year))\n    ax.text(xmin+.025, ymin+.025, text, color=\"white\", fontsize=12, alpha=0.5)\n\n    plt.show()\n"
    },
    {
      "filename": "pan_zoom_overlap.py",
      "title": "Pan Zoom Overlap",
      "code": "\"\"\"\n===================================\nPan/zoom events of overlapping axes\n===================================\n\nExample to illustrate how pan/zoom events of overlapping axes are treated.\n\n\nThe default is the following:\n\n- Axes with a visible patch capture pan/zoom events\n- Axes with an invisible patch forward pan/zoom events to axes below\n- Shared axes always trigger with their parent axes\n  (irrespective of the patch visibility)\n\nNote: The visibility of the patch hereby refers to the value of\n``ax.patch.get_visible()``. The color and transparency of a\npatch have no effect on the treatment of pan/zoom events!\n\n\n``ax.set_forward_navigation_events(val)`` can be used to override the\ndefault behaviour:\n\n- ``True``:  Forward navigation events to axes below.\n- ``False``: Execute navigation events only on this axes.\n- ``\"auto\"``: Use the default behaviour.\n\nTo disable pan/zoom events completely, use ``ax.set_navigate(False)``\n\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(11, 6))\nfig.suptitle(\"Showcase for pan/zoom events on overlapping axes.\")\n\nax = fig.add_axes((.05, .05, .9, .9))\nax.patch.set_color(\".75\")\nax_twin = ax.twinx()\n\nax1 = fig.add_subplot(221)\nax1_twin = ax1.twinx()\nax1.text(.5, .5,\n         \"Visible patch\\n\\n\"\n         \"Pan/zoom events are NOT\\n\"\n         \"forwarded to axes below\",\n         ha=\"center\", va=\"center\", transform=ax1.transAxes)\n\nax11 = fig.add_subplot(223, sharex=ax1, sharey=ax1)\nax11.set_forward_navigation_events(True)\nax11.text(.5, .5,\n          \"Visible patch\\n\\n\"\n          \"Override capture behavior:\\n\\n\"\n          \"ax.set_forward_navigation_events(True)\",\n          ha=\"center\", va=\"center\", transform=ax11.transAxes)\n\nax2 = fig.add_subplot(222)\nax2_twin = ax2.twinx()\nax2.patch.set_visible(False)\nax2.text(.5, .5,\n         \"Invisible patch\\n\\n\"\n         \"Pan/zoom events are\\n\"\n         \"forwarded to axes below\",\n         ha=\"center\", va=\"center\", transform=ax2.transAxes)\n\nax22 = fig.add_subplot(224, sharex=ax2, sharey=ax2)\nax22.patch.set_visible(False)\nax22.set_forward_navigation_events(False)\nax22.text(.5, .5,\n          \"Invisible patch\\n\\n\"\n          \"Override capture behavior:\\n\\n\"\n          \"ax.set_forward_navigation_events(False)\",\n          ha=\"center\", va=\"center\", transform=ax22.transAxes)\n"
    },
    {
      "filename": "stock_prices.py",
      "title": "Stock Prices",
      "code": "\"\"\"\n==========================\nStock prices over 32 years\n==========================\n\n.. redirect-from:: /gallery/showcase/bachelors_degrees_by_gender\n\nA graph of multiple time series that demonstrates custom styling of plot frame,\ntick lines, tick labels, and line graph properties. It also uses custom\nplacement of text labels along the right edge as an alternative to a\nconventional legend.\n\nNote: The third-party mpl style dufte_ produces similar-looking plots with less\ncode.\n\n.. _dufte: https://github.com/nschloe/dufte\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nimport matplotlib.transforms as mtransforms\n\nwith get_sample_data('Stocks.csv') as file:\n    stock_data = np.genfromtxt(\n        file, delimiter=',', names=True, dtype=None,\n        converters={0: lambda x: np.datetime64(x, 'D')}, skip_header=1)\n\nfig, ax = plt.subplots(1, 1, figsize=(6, 8), layout='constrained')\n\n# These are the colors that will be used in the plot\nax.set_prop_cycle(color=[\n    '#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a',\n    '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94',\n    '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d',\n    '#17becf', '#9edae5'])\n\nstocks_name = ['IBM', 'Apple', 'Microsoft', 'Xerox', 'Amazon', 'Dell',\n               'Alphabet', 'Adobe', 'S&P 500', 'NASDAQ']\nstocks_ticker = ['IBM', 'AAPL', 'MSFT', 'XRX', 'AMZN', 'DELL', 'GOOGL',\n                 'ADBE', 'GSPC', 'IXIC']\n\n# Manually adjust the label positions vertically (units are points = 1/72 inch)\ny_offsets = dict.fromkeys(stocks_ticker, 0)\ny_offsets['IBM'] = 5\ny_offsets['AAPL'] = -5\ny_offsets['AMZN'] = -6\n\nfor nn, column in enumerate(stocks_ticker):\n    # Plot each line separately with its own color.\n    # don't include any data with NaN.\n    good = np.nonzero(np.isfinite(stock_data[column]))\n    line, = ax.plot(stock_data['Date'][good], stock_data[column][good], lw=2.5)\n\n    # Add a text label to the right end of every line. Most of the code below\n    # is adding specific offsets y position because some labels overlapped.\n    y_pos = stock_data[column][-1]\n\n    # Use an offset transform, in points, for any text that needs to be nudged\n    # up or down.\n    offset = y_offsets[column] / 72\n    trans = mtransforms.ScaledTranslation(0, offset, fig.dpi_scale_trans)\n    trans = ax.transData + trans\n\n    # Again, make sure that all labels are large enough to be easily read\n    # by the viewer.\n    ax.text(np.datetime64('2022-10-01'), y_pos, stocks_name[nn],\n            color=line.get_color(), transform=trans)\n\nax.set_xlim(np.datetime64('1989-06-01'), np.datetime64('2023-01-01'))\n\nfig.suptitle(\"Technology company stocks prices dollars (1990-2022)\",\n             ha=\"center\")\n\n# Remove the plot frame lines. They are unnecessary here.\nax.spines[:].set_visible(False)\n\n# Ensure that the axis ticks only show up on the bottom and left of the plot.\n# Ticks on the right and top of the plot are generally unnecessary.\nax.xaxis.tick_bottom()\nax.yaxis.tick_left()\nax.set_yscale('log')\n\n# Provide tick lines across the plot to help your viewers trace along\n# the axis ticks. Make sure that the lines are light and small so they\n# don't obscure the primary data lines.\nax.grid(True, 'major', 'both', ls='--', lw=.5, c='k', alpha=.3)\n\n# Remove the tick marks; they are unnecessary with the tick lines we just\n# plotted. Make sure your axis ticks are large enough to be easily read.\n# You don't want your viewers squinting to read your plot.\nax.tick_params(axis='both', which='both', labelsize='large',\n               bottom=False, top=False, labelbottom=True,\n               left=False, right=False, labelleft=True)\n\n# Finally, save the figure as a PNG.\n# You can also save it as a PDF, JPEG, etc.\n# Just change the file extension in this call.\n# fig.savefig('stock-prices.png', bbox_inches='tight')\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axes.Axes.text`\n#    - `matplotlib.axis.XAxis.tick_bottom`\n#    - `matplotlib.axis.YAxis.tick_left`\n#    - `matplotlib.artist.Artist.set_visible`\n"
    },
    {
      "filename": "xkcd.py",
      "title": "Xkcd",
      "code": "\"\"\"\n====\nXKCD\n====\n\nShows how to create an xkcd-like plot.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n\nwith plt.xkcd():\n    # Based on \"Stove Ownership\" from XKCD by Randall Munroe\n    # https://xkcd.com/418/\n\n    fig = plt.figure()\n    ax = fig.add_axes((0.1, 0.2, 0.8, 0.7))\n    ax.spines[['top', 'right']].set_visible(False)\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_ylim([-30, 10])\n\n    data = np.ones(100)\n    data[70:] -= np.arange(30)\n\n    ax.annotate(\n        'THE DAY I REALIZED\\nI COULD COOK BACON\\nWHENEVER I WANTED',\n        xy=(70, 1), arrowprops=dict(arrowstyle='->'), xytext=(15, -10))\n\n    ax.plot(data)\n\n    ax.set_xlabel('time')\n    ax.set_ylabel('my overall health')\n    fig.text(\n        0.5, 0.05,\n        '\"Stove Ownership\" from xkcd by Randall Munroe',\n        ha='center')\n\n# %%\n\nwith plt.xkcd():\n    # Based on \"The Data So Far\" from XKCD by Randall Munroe\n    # https://xkcd.com/373/\n\n    fig = plt.figure()\n    ax = fig.add_axes((0.1, 0.2, 0.8, 0.7))\n    ax.bar([0, 1], [0, 100], 0.25)\n    ax.spines[['top', 'right']].set_visible(False)\n    ax.xaxis.set_ticks_position('bottom')\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(['CONFIRMED BY\\nEXPERIMENT', 'REFUTED BY\\nEXPERIMENT'])\n    ax.set_xlim([-0.5, 1.5])\n    ax.set_yticks([])\n    ax.set_ylim([0, 110])\n\n    ax.set_title(\"CLAIMS OF SUPERNATURAL POWERS\")\n\n    fig.text(\n        0.5, 0.05,\n        '\"The Data So Far\" from xkcd by Randall Munroe',\n        ha='center')\n\nplt.show()\n"
    }
  ],
  "specialty_plots": [
    {
      "filename": "advanced_hillshading.py",
      "title": "Advanced Hillshading",
      "code": "\"\"\"\n===========\nHillshading\n===========\n\nDemonstrates a few common tricks with shaded plots.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import LightSource, Normalize\n\n\ndef display_colorbar():\n    \"\"\"Display a correct numeric colorbar for a shaded plot.\"\"\"\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    cmap = plt.cm.copper\n    ls = LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    fig, ax = plt.subplots()\n    ax.imshow(rgb, interpolation='bilinear')\n\n    # Use a proxy artist for the colorbar...\n    im = ax.imshow(z, cmap=cmap)\n    im.remove()\n    fig.colorbar(im, ax=ax)\n\n    ax.set_title('Using a colorbar with a shaded plot', size='x-large')\n\n\ndef avoid_outliers():\n    \"\"\"Use a custom norm to control the displayed z-range of a shaded plot.\"\"\"\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    # Add some outliers...\n    z[100, 105] = 2000\n    z[120, 110] = -9000\n\n    ls = LightSource(315, 45)\n    fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 4.5))\n\n    rgb = ls.shade(z, plt.cm.copper)\n    ax1.imshow(rgb, interpolation='bilinear')\n    ax1.set_title('Full range of data')\n\n    rgb = ls.shade(z, plt.cm.copper, vmin=-10, vmax=10)\n    ax2.imshow(rgb, interpolation='bilinear')\n    ax2.set_title('Manually set range')\n\n    fig.suptitle('Avoiding Outliers in Shaded Plots', size='x-large')\n\n\ndef shade_other_data():\n    \"\"\"Demonstrates displaying different variables through shade and color.\"\"\"\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z1 = np.sin(x**2)  # Data to hillshade\n    z2 = np.cos(x**2 + y**2)  # Data to color\n\n    norm = Normalize(z2.min(), z2.max())\n    cmap = plt.cm.RdBu\n\n    ls = LightSource(315, 45)\n    rgb = ls.shade_rgb(cmap(norm(z2)), z1)\n\n    fig, ax = plt.subplots()\n    ax.imshow(rgb, interpolation='bilinear')\n    ax.set_title('Shade by one variable, color by another', size='x-large')\n\ndisplay_colorbar()\navoid_outliers()\nshade_other_data()\nplt.show()\n"
    },
    {
      "filename": "anscombe.py",
      "title": "Anscombe",
      "code": "\"\"\"\n==================\nAnscombe's quartet\n==================\n\n`Anscombe's quartet`_ is a group of datasets (x, y) that have the same mean,\nstandard deviation, and regression line, but which are qualitatively different.\n\nIt is often used to illustrate the importance of looking at a set of data\ngraphically and not only relying on basic statistic properties.\n\n.. _Anscombe's quartet: https://en.wikipedia.org/wiki/Anscombe%27s_quartet\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5]\ny1 = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68]\ny2 = [9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74]\ny3 = [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73]\nx4 = [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8]\ny4 = [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89]\n\ndatasets = {\n    'I': (x, y1),\n    'II': (x, y2),\n    'III': (x, y3),\n    'IV': (x4, y4)\n}\n\nfig, axs = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 6),\n                        gridspec_kw={'wspace': 0.08, 'hspace': 0.08})\naxs[0, 0].set(xlim=(0, 20), ylim=(2, 14))\naxs[0, 0].set(xticks=(0, 10, 20), yticks=(4, 8, 12))\n\nfor ax, (label, (x, y)) in zip(axs.flat, datasets.items()):\n    ax.text(0.1, 0.9, label, fontsize=20, transform=ax.transAxes, va='top')\n    ax.tick_params(direction='in', top=True, right=True)\n    ax.plot(x, y, 'o')\n\n    # linear regression\n    p1, p0 = np.polyfit(x, y, deg=1)  # slope, intercept\n    ax.axline(xy1=(0, p0), slope=p1, color='r', lw=2)\n\n    # add text box for the statistics\n    stats = (f'$\\\\mu$ = {np.mean(y):.2f}\\n'\n             f'$\\\\sigma$ = {np.std(y):.2f}\\n'\n             f'$r$ = {np.corrcoef(x, y)[0][1]:.2f}')\n    bbox = dict(boxstyle='round', fc='blanchedalmond', ec='orange', alpha=0.5)\n    ax.text(0.95, 0.07, stats, fontsize=9, bbox=bbox,\n            transform=ax.transAxes, horizontalalignment='right')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.axline` / `matplotlib.pyplot.axline`\n#    - `matplotlib.axes.Axes.text` / `matplotlib.pyplot.text`\n#    - `matplotlib.axes.Axes.tick_params` / matplotlib.pyplot.tick_params`\n"
    },
    {
      "filename": "hinton_demo.py",
      "title": "Hinton Demo",
      "code": "\"\"\"\n===============\nHinton diagrams\n===============\n\nHinton diagrams are useful for visualizing the values of a 2D array (e.g.\na weight matrix): Positive and negative values are represented by white and\nblack squares, respectively, and the size of each square represents the\nmagnitude of each value.\n\nInitial idea from David Warde-Farley on the SciPy Cookbook\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef hinton(matrix, max_weight=None, ax=None):\n    \"\"\"Draw Hinton diagram for visualizing a weight matrix.\"\"\"\n    ax = ax if ax is not None else plt.gca()\n\n    if not max_weight:\n        max_weight = 2 ** np.ceil(np.log2(np.abs(matrix).max()))\n\n    ax.patch.set_facecolor('gray')\n    ax.set_aspect('equal', 'box')\n    ax.xaxis.set_major_locator(plt.NullLocator())\n    ax.yaxis.set_major_locator(plt.NullLocator())\n\n    for (x, y), w in np.ndenumerate(matrix):\n        color = 'white' if w > 0 else 'black'\n        size = np.sqrt(abs(w) / max_weight)\n        rect = plt.Rectangle([x - size / 2, y - size / 2], size, size,\n                             facecolor=color, edgecolor=color)\n        ax.add_patch(rect)\n\n    ax.autoscale_view()\n    ax.invert_yaxis()\n\n\nif __name__ == '__main__':\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    hinton(np.random.rand(20, 20) - 0.5)\n    plt.show()\n"
    },
    {
      "filename": "ishikawa_diagram.py",
      "title": "Ishikawa Diagram",
      "code": "\"\"\"\n================\nIshikawa Diagram\n================\n\nIshikawa Diagrams, fishbone diagrams, herringbone diagrams, or cause-and-effect\ndiagrams are used to identify problems in a system by showing how causes and\neffects are linked.\nSource: https://en.wikipedia.org/wiki/Ishikawa_diagram\n\n\"\"\"\nimport math\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.patches import Polygon, Wedge\n\nfig, ax = plt.subplots(figsize=(10, 6), layout='constrained')\nax.set_xlim(-5, 5)\nax.set_ylim(-5, 5)\nax.axis('off')\n\n\ndef problems(data: str,\n             problem_x: float, problem_y: float,\n             angle_x: float, angle_y: float):\n    \"\"\"\n    Draw each problem section of the Ishikawa plot.\n\n    Parameters\n    ----------\n    data : str\n        The name of the problem category.\n    problem_x, problem_y : float, optional\n        The `X` and `Y` positions of the problem arrows (`Y` defaults to zero).\n    angle_x, angle_y : float, optional\n        The angle of the problem annotations. They are always angled towards\n        the tail of the plot.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    ax.annotate(str.upper(data), xy=(problem_x, problem_y),\n                xytext=(angle_x, angle_y),\n                fontsize=10,\n                color='white',\n                weight='bold',\n                xycoords='data',\n                verticalalignment='center',\n                horizontalalignment='center',\n                textcoords='offset fontsize',\n                arrowprops=dict(arrowstyle=\"->\", facecolor='black'),\n                bbox=dict(boxstyle='square',\n                          facecolor='tab:blue',\n                          pad=0.8))\n\n\ndef causes(data: list,\n           cause_x: float, cause_y: float,\n           cause_xytext=(-9, -0.3), top: bool = True):\n    \"\"\"\n    Place each cause to a position relative to the problems\n    annotations.\n\n    Parameters\n    ----------\n    data : indexable object\n        The input data. IndexError is\n        raised if more than six arguments are passed.\n    cause_x, cause_y : float\n        The `X` and `Y` position of the cause annotations.\n    cause_xytext : tuple, optional\n        Adjust to set the distance of the cause text from the problem\n        arrow in fontsize units.\n    top : bool, default: True\n        Determines whether the next cause annotation will be\n        plotted above or below the previous one.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    for index, cause in enumerate(data):\n        # [<x pos>, <y pos>]\n        coords = [[0.02, 0],\n                  [0.23, 0.5],\n                  [-0.46, -1],\n                  [0.69, 1.5],\n                  [-0.92, -2],\n                  [1.15, 2.5]]\n\n        # First 'cause' annotation is placed in the middle of the 'problems' arrow\n        # and each subsequent cause is plotted above or below it in succession.\n        cause_x -= coords[index][0]\n        cause_y += coords[index][1] if top else -coords[index][1]\n\n        ax.annotate(cause, xy=(cause_x, cause_y),\n                    horizontalalignment='center',\n                    xytext=cause_xytext,\n                    fontsize=9,\n                    xycoords='data',\n                    textcoords='offset fontsize',\n                    arrowprops=dict(arrowstyle=\"->\",\n                                    facecolor='black'))\n\n\ndef draw_body(data: dict):\n    \"\"\"\n    Place each problem section in its correct place by changing\n    the coordinates on each loop.\n\n    Parameters\n    ----------\n    data : dict\n        The input data (can be a dict of lists or tuples). ValueError\n        is raised if more than six arguments are passed.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # Set the length of the spine according to the number of 'problem' categories.\n    length = (math.ceil(len(data) / 2)) - 1\n    draw_spine(-2 - length, 2 + length)\n\n    # Change the coordinates of the 'problem' annotations after each one is rendered.\n    offset = 0\n    prob_section = [1.55, 0.8]\n    for index, problem in enumerate(data.values()):\n        plot_above = index % 2 == 0\n        cause_arrow_y = 1.7 if plot_above else -1.7\n        y_prob_angle = 16 if plot_above else -16\n\n        # Plot each section in pairs along the main spine.\n        prob_arrow_x = prob_section[0] + length + offset\n        cause_arrow_x = prob_section[1] + length + offset\n        if not plot_above:\n            offset -= 2.5\n        if index > 5:\n            raise ValueError(f'Maximum number of problems is 6, you have entered '\n                             f'{len(data)}')\n\n        problems(list(data.keys())[index], prob_arrow_x, 0, -12, y_prob_angle)\n        causes(problem, cause_arrow_x, cause_arrow_y, top=plot_above)\n\n\ndef draw_spine(xmin: int, xmax: int):\n    \"\"\"\n    Draw main spine, head and tail.\n\n    Parameters\n    ----------\n    xmin : int\n        The default position of the head of the spine's\n        x-coordinate.\n    xmax : int\n        The default position of the tail of the spine's\n        x-coordinate.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # draw main spine\n    ax.plot([xmin - 0.1, xmax], [0, 0], color='tab:blue', linewidth=2)\n    # draw fish head\n    ax.text(xmax + 0.1, - 0.05, 'PROBLEM', fontsize=10,\n            weight='bold', color='white')\n    semicircle = Wedge((xmax, 0), 1, 270, 90, fc='tab:blue')\n    ax.add_patch(semicircle)\n    # draw fish tail\n    tail_pos = [[xmin - 0.8, 0.8], [xmin - 0.8, -0.8], [xmin, -0.01]]\n    triangle = Polygon(tail_pos, fc='tab:blue')\n    ax.add_patch(triangle)\n\n\n# Input data\ncategories = {\n    'Method': ['Time consumption', 'Cost', 'Procedures', 'Inefficient process',\n               'Sampling'],\n    'Machine': ['Faulty equipment', 'Compatibility'],\n    'Material': ['Poor-quality input', 'Raw materials', 'Supplier',\n                 'Shortage'],\n    'Measurement': ['Calibration', 'Performance', 'Wrong measurements'],\n    'Environment': ['Bad conditions'],\n    'People': ['Lack of training', 'Managers', 'Labor shortage',\n               'Procedures', 'Sales strategy']\n}\n\ndraw_body(categories)\nplt.show()\n"
    },
    {
      "filename": "leftventricle_bullseye.py",
      "title": "Leftventricle Bullseye",
      "code": "\"\"\"\n=======================\nLeft ventricle bullseye\n=======================\n\nThis example demonstrates how to create the 17 segment model for the left\nventricle recommended by the American Heart Association (AHA).\n\n.. redirect-from:: /gallery/specialty_plots/leftventricle_bulleye\n\nSee also the :doc:`/gallery/pie_and_polar_charts/nested_pie` example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\n\ndef bullseye_plot(ax, data, seg_bold=None, cmap=\"viridis\", norm=None):\n    \"\"\"\n    Bullseye representation for the left ventricle.\n\n    Parameters\n    ----------\n    ax : Axes\n    data : list[float]\n        The intensity values for each of the 17 segments.\n    seg_bold : list[int], optional\n        A list with the segments to highlight.\n    cmap : colormap, default: \"viridis\"\n        Colormap for the data.\n    norm : Normalize or None, optional\n        Normalizer for the data.\n\n    Notes\n    -----\n    This function creates the 17 segment model for the left ventricle according\n    to the American Heart Association (AHA) [1]_\n\n    References\n    ----------\n    .. [1] M. D. Cerqueira, N. J. Weissman, V. Dilsizian, A. K. Jacobs,\n        S. Kaul, W. K. Laskey, D. J. Pennell, J. A. Rumberger, T. Ryan,\n        and M. S. Verani, \"Standardized myocardial segmentation and\n        nomenclature for tomographic imaging of the heart\",\n        Circulation, vol. 105, no. 4, pp. 539-542, 2002.\n    \"\"\"\n\n    data = np.ravel(data)\n    if seg_bold is None:\n        seg_bold = []\n    if norm is None:\n        norm = mpl.colors.Normalize(vmin=data.min(), vmax=data.max())\n\n    r = np.linspace(0.2, 1, 4)\n\n    ax.set(ylim=[0, 1], xticklabels=[], yticklabels=[])\n    ax.grid(False)  # Remove grid\n\n    # Fill segments 1-6, 7-12, 13-16.\n    for start, stop, r_in, r_out in [\n            (0, 6, r[2], r[3]),\n            (6, 12, r[1], r[2]),\n            (12, 16, r[0], r[1]),\n            (16, 17, 0, r[0]),\n    ]:\n        n = stop - start\n        dtheta = 2*np.pi / n\n        ax.bar(np.arange(n) * dtheta + np.pi/2, r_out - r_in, dtheta, r_in,\n               color=cmap(norm(data[start:stop])))\n\n    # Now, draw the segment borders.  In order for the outer bold borders not\n    # to be covered by inner segments, the borders are all drawn separately\n    # after the segments have all been filled.  We also disable clipping, which\n    # would otherwise affect the outermost segment edges.\n    # Draw edges of segments 1-6, 7-12, 13-16.\n    for start, stop, r_in, r_out in [\n            (0, 6, r[2], r[3]),\n            (6, 12, r[1], r[2]),\n            (12, 16, r[0], r[1]),\n    ]:\n        n = stop - start\n        dtheta = 2*np.pi / n\n        ax.bar(np.arange(n) * dtheta + np.pi/2, r_out - r_in, dtheta, r_in,\n               clip_on=False, color=\"none\", edgecolor=\"k\", linewidth=[\n                   4 if i + 1 in seg_bold else 2 for i in range(start, stop)])\n    # Draw edge of segment 17 -- here; the edge needs to be drawn differently,\n    # using plot().\n    ax.plot(np.linspace(0, 2*np.pi), np.linspace(r[0], r[0]), \"k\",\n            linewidth=(4 if 17 in seg_bold else 2))\n\n\n# Create the fake data\ndata = np.arange(17) + 1\n\n\n# Make a figure and Axes with dimensions as desired.\nfig = plt.figure(figsize=(10, 5), layout=\"constrained\")\nfig.get_layout_engine().set(wspace=.1, w_pad=.2)\naxs = fig.subplots(1, 3, subplot_kw=dict(projection='polar'))\nfig.canvas.manager.set_window_title('Left Ventricle Bulls Eyes (AHA)')\n\n\n# Set the colormap and norm to correspond to the data for which\n# the colorbar will be used.\ncmap = mpl.cm.viridis\nnorm = mpl.colors.Normalize(vmin=1, vmax=17)\n# Create an empty ScalarMappable to set the colorbar's colormap and norm.\n# The following gives a basic continuous colorbar with ticks and labels.\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap, norm=norm),\n             cax=axs[0].inset_axes([0, -.15, 1, .1]),\n             orientation='horizontal', label='Some units')\n\n\n# And again for the second colorbar.\ncmap2 = mpl.cm.cool\nnorm2 = mpl.colors.Normalize(vmin=1, vmax=17)\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap2, norm=norm2),\n             cax=axs[1].inset_axes([0, -.15, 1, .1]),\n             orientation='horizontal', label='Some other units')\n\n\n# The second example illustrates the use of a ListedColormap, a\n# BoundaryNorm, and extended ends to show the \"over\" and \"under\"\n# value colors.\ncmap3 = (mpl.colors.ListedColormap(['r', 'g', 'b', 'c'])\n         .with_extremes(over='0.35', under='0.75'))\n# If a ListedColormap is used, the length of the bounds array must be\n# one greater than the length of the color list.  The bounds must be\n# monotonically increasing.\nbounds = [2, 3, 7, 9, 15]\nnorm3 = mpl.colors.BoundaryNorm(bounds, cmap3.N)\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap3, norm=norm3),\n             cax=axs[2].inset_axes([0, -.15, 1, .1]),\n             extend='both',\n             ticks=bounds,  # optional\n             spacing='proportional',\n             orientation='horizontal',\n             label='Discrete intervals, some other units')\n\n\n# Create the 17 segment model\nbullseye_plot(axs[0], data, cmap=cmap, norm=norm)\naxs[0].set_title('Bulls Eye (AHA)')\n\nbullseye_plot(axs[1], data, cmap=cmap2, norm=norm2)\naxs[1].set_title('Bulls Eye (AHA)')\n\nbullseye_plot(axs[2], data, seg_bold=[3, 5, 6, 11, 12, 16],\n              cmap=cmap3, norm=norm3)\naxs[2].set_title('Segments [3, 5, 6, 11, 12, 16] in bold')\n\nplt.show()\n"
    },
    {
      "filename": "mri_with_eeg.py",
      "title": "Mri With Eeg",
      "code": "\"\"\"\n============\nMRI with EEG\n============\n\nDisplays a set of subplots with an MRI image, its intensity\nhistogram and some EEG traces.\n\n.. redirect-from:: /gallery/specialty_plots/mri_demo\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\nfig, axd = plt.subplot_mosaic(\n    [[\"image\", \"density\"],\n     [\"EEG\", \"EEG\"]],\n    layout=\"constrained\",\n    # \"image\" will contain a square image. We fine-tune the width so that\n    # there is no excess horizontal or vertical margin around the image.\n    width_ratios=[1.05, 2],\n)\n\n# Load the MRI data (256x256 16-bit integers)\nwith cbook.get_sample_data('s1045.ima.gz') as dfile:\n    im = np.frombuffer(dfile.read(), np.uint16).reshape((256, 256))\n\n# Plot the MRI image\naxd[\"image\"].imshow(im, cmap=\"gray\")\naxd[\"image\"].axis('off')\n\n# Plot the histogram of MRI intensity\nim = im[im.nonzero()]  # Ignore the background\naxd[\"density\"].hist(im, bins=np.arange(0, 2**16+1, 512))\naxd[\"density\"].set(xlabel='Intensity (a.u.)', xlim=(0, 2**16),\n                   ylabel='MRI density', yticks=[])\naxd[\"density\"].minorticks_on()\n\n# Load the EEG data\nn_samples, n_rows = 800, 4\nwith cbook.get_sample_data('eeg.dat') as eegfile:\n    data = np.fromfile(eegfile, dtype=float).reshape((n_samples, n_rows))\nt = 10 * np.arange(n_samples) / n_samples\n\n# Plot the EEG\naxd[\"EEG\"].set_xlabel('Time (s)')\naxd[\"EEG\"].set_xlim(0, 10)\ndy = (data.min() - data.max()) * 0.7  # Crowd them a bit.\naxd[\"EEG\"].set_ylim(-dy, n_rows * dy)\naxd[\"EEG\"].set_yticks([0, dy, 2*dy, 3*dy], labels=['PG3', 'PG5', 'PG7', 'PG9'])\n\nfor i, data_col in enumerate(data.T):\n    axd[\"EEG\"].plot(t, data_col + i*dy, color=\"C0\")\n\nplt.show()\n"
    },
    {
      "filename": "radar_chart.py",
      "title": "Radar Chart",
      "code": "\"\"\"\n======================================\nRadar chart (aka spider or star chart)\n======================================\n\nThis example creates a radar chart, also known as a spider or star chart [1]_.\n\nAlthough this example allows a frame of either 'circle' or 'polygon', polygon\nframes don't have proper gridlines (the lines are circles instead of polygons).\nIt's possible to get a polygon grid by setting GRIDLINE_INTERPOLATION_STEPS in\n`matplotlib.axis` to the desired number of vertices, but the orientation of the\npolygon is not aligned with the radial axis.\n\n.. [1] https://en.wikipedia.org/wiki/Radar_chart\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle, RegularPolygon\nfrom matplotlib.path import Path\nfrom matplotlib.projections import register_projection\nfrom matplotlib.projections.polar import PolarAxes\nfrom matplotlib.spines import Spine\nfrom matplotlib.transforms import Affine2D\n\n\ndef radar_factory(num_vars, frame='circle'):\n    \"\"\"\n    Create a radar chart with `num_vars` Axes.\n\n    This function creates a RadarAxes projection and registers it.\n\n    Parameters\n    ----------\n    num_vars : int\n        Number of variables for radar chart.\n    frame : {'circle', 'polygon'}\n        Shape of frame surrounding Axes.\n\n    \"\"\"\n    # calculate evenly-spaced axis angles\n    theta = np.linspace(0, 2*np.pi, num_vars, endpoint=False)\n\n    class RadarTransform(PolarAxes.PolarTransform):\n\n        def transform_path_non_affine(self, path):\n            # Paths with non-unit interpolation steps correspond to gridlines,\n            # in which case we force interpolation (to defeat PolarTransform's\n            # autoconversion to circular arcs).\n            if path._interpolation_steps > 1:\n                path = path.interpolated(num_vars)\n            return Path(self.transform(path.vertices), path.codes)\n\n    class RadarAxes(PolarAxes):\n\n        name = 'radar'\n        PolarTransform = RadarTransform\n\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            # rotate plot such that the first axis is at the top\n            self.set_theta_zero_location('N')\n\n        def fill(self, *args, closed=True, **kwargs):\n            \"\"\"Override fill so that line is closed by default\"\"\"\n            return super().fill(closed=closed, *args, **kwargs)\n\n        def plot(self, *args, **kwargs):\n            \"\"\"Override plot so that line is closed by default\"\"\"\n            lines = super().plot(*args, **kwargs)\n            for line in lines:\n                self._close_line(line)\n\n        def _close_line(self, line):\n            x, y = line.get_data()\n            # FIXME: markers at x[0], y[0] get doubled-up\n            if x[0] != x[-1]:\n                x = np.append(x, x[0])\n                y = np.append(y, y[0])\n                line.set_data(x, y)\n\n        def set_varlabels(self, labels):\n            self.set_thetagrids(np.degrees(theta), labels)\n\n        def _gen_axes_patch(self):\n            # The Axes patch must be centered at (0.5, 0.5) and of radius 0.5\n            # in axes coordinates.\n            if frame == 'circle':\n                return Circle((0.5, 0.5), 0.5)\n            elif frame == 'polygon':\n                return RegularPolygon((0.5, 0.5), num_vars,\n                                      radius=.5, edgecolor=\"k\")\n            else:\n                raise ValueError(\"Unknown value for 'frame': %s\" % frame)\n\n        def _gen_axes_spines(self):\n            if frame == 'circle':\n                return super()._gen_axes_spines()\n            elif frame == 'polygon':\n                # spine_type must be 'left'/'right'/'top'/'bottom'/'circle'.\n                spine = Spine(axes=self,\n                              spine_type='circle',\n                              path=Path.unit_regular_polygon(num_vars))\n                # unit_regular_polygon gives a polygon of radius 1 centered at\n                # (0, 0) but we want a polygon of radius 0.5 centered at (0.5,\n                # 0.5) in axes coordinates.\n                spine.set_transform(Affine2D().scale(.5).translate(.5, .5)\n                                    + self.transAxes)\n                return {'polar': spine}\n            else:\n                raise ValueError(\"Unknown value for 'frame': %s\" % frame)\n\n    register_projection(RadarAxes)\n    return theta\n\n\ndef example_data():\n    # The following data is from the Denver Aerosol Sources and Health study.\n    # See doi:10.1016/j.atmosenv.2008.12.017\n    #\n    # The data are pollution source profile estimates for five modeled\n    # pollution sources (e.g., cars, wood-burning, etc) that emit 7-9 chemical\n    # species. The radar charts are experimented with here to see if we can\n    # nicely visualize how the modeled source profiles change across four\n    # scenarios:\n    #  1) No gas-phase species present, just seven particulate counts on\n    #     Sulfate\n    #     Nitrate\n    #     Elemental Carbon (EC)\n    #     Organic Carbon fraction 1 (OC)\n    #     Organic Carbon fraction 2 (OC2)\n    #     Organic Carbon fraction 3 (OC3)\n    #     Pyrolyzed Organic Carbon (OP)\n    #  2)Inclusion of gas-phase specie carbon monoxide (CO)\n    #  3)Inclusion of gas-phase specie ozone (O3).\n    #  4)Inclusion of both gas-phase species is present...\n    data = [\n        ['Sulfate', 'Nitrate', 'EC', 'OC1', 'OC2', 'OC3', 'OP', 'CO', 'O3'],\n        ('Basecase', [\n            [0.88, 0.01, 0.03, 0.03, 0.00, 0.06, 0.01, 0.00, 0.00],\n            [0.07, 0.95, 0.04, 0.05, 0.00, 0.02, 0.01, 0.00, 0.00],\n            [0.01, 0.02, 0.85, 0.19, 0.05, 0.10, 0.00, 0.00, 0.00],\n            [0.02, 0.01, 0.07, 0.01, 0.21, 0.12, 0.98, 0.00, 0.00],\n            [0.01, 0.01, 0.02, 0.71, 0.74, 0.70, 0.00, 0.00, 0.00]]),\n        ('With CO', [\n            [0.88, 0.02, 0.02, 0.02, 0.00, 0.05, 0.00, 0.05, 0.00],\n            [0.08, 0.94, 0.04, 0.02, 0.00, 0.01, 0.12, 0.04, 0.00],\n            [0.01, 0.01, 0.79, 0.10, 0.00, 0.05, 0.00, 0.31, 0.00],\n            [0.00, 0.02, 0.03, 0.38, 0.31, 0.31, 0.00, 0.59, 0.00],\n            [0.02, 0.02, 0.11, 0.47, 0.69, 0.58, 0.88, 0.00, 0.00]]),\n        ('With O3', [\n            [0.89, 0.01, 0.07, 0.00, 0.00, 0.05, 0.00, 0.00, 0.03],\n            [0.07, 0.95, 0.05, 0.04, 0.00, 0.02, 0.12, 0.00, 0.00],\n            [0.01, 0.02, 0.86, 0.27, 0.16, 0.19, 0.00, 0.00, 0.00],\n            [0.01, 0.03, 0.00, 0.32, 0.29, 0.27, 0.00, 0.00, 0.95],\n            [0.02, 0.00, 0.03, 0.37, 0.56, 0.47, 0.87, 0.00, 0.00]]),\n        ('CO & O3', [\n            [0.87, 0.01, 0.08, 0.00, 0.00, 0.04, 0.00, 0.00, 0.01],\n            [0.09, 0.95, 0.02, 0.03, 0.00, 0.01, 0.13, 0.06, 0.00],\n            [0.01, 0.02, 0.71, 0.24, 0.13, 0.16, 0.00, 0.50, 0.00],\n            [0.01, 0.03, 0.00, 0.28, 0.24, 0.23, 0.00, 0.44, 0.88],\n            [0.02, 0.00, 0.18, 0.45, 0.64, 0.55, 0.86, 0.00, 0.16]])\n    ]\n    return data\n\n\nif __name__ == '__main__':\n    N = 9\n    theta = radar_factory(N, frame='polygon')\n\n    data = example_data()\n    spoke_labels = data.pop(0)\n\n    fig, axs = plt.subplots(figsize=(9, 9), nrows=2, ncols=2,\n                            subplot_kw=dict(projection='radar'))\n    fig.subplots_adjust(wspace=0.25, hspace=0.20, top=0.85, bottom=0.05)\n\n    colors = ['b', 'r', 'g', 'm', 'y']\n    # Plot the four cases from the example data on separate Axes\n    for ax, (title, case_data) in zip(axs.flat, data):\n        ax.set_rgrids([0.2, 0.4, 0.6, 0.8])\n        ax.set_title(title, weight='bold', size='medium', position=(0.5, 1.1),\n                     horizontalalignment='center', verticalalignment='center')\n        for d, color in zip(case_data, colors):\n            ax.plot(theta, d, color=color)\n            ax.fill(theta, d, facecolor=color, alpha=0.25, label='_nolegend_')\n        ax.set_varlabels(spoke_labels)\n\n    # add legend relative to top-left plot\n    labels = ('Factor 1', 'Factor 2', 'Factor 3', 'Factor 4', 'Factor 5')\n    legend = axs[0, 0].legend(labels, loc=(0.9, .95),\n                              labelspacing=0.1, fontsize='small')\n\n    fig.text(0.5, 0.965, '5-Factor Solution Profiles Across Four Scenarios',\n             horizontalalignment='center', color='black', weight='bold',\n             size='large')\n\n    plt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.path`\n#    - `matplotlib.path.Path`\n#    - `matplotlib.spines`\n#    - `matplotlib.spines.Spine`\n#    - `matplotlib.projections`\n#    - `matplotlib.projections.polar`\n#    - `matplotlib.projections.polar.PolarAxes`\n#    - `matplotlib.projections.register_projection`\n"
    },
    {
      "filename": "sankey_basics.py",
      "title": "Sankey Basics",
      "code": "\"\"\"\n================\nThe Sankey class\n================\n\nDemonstrate the Sankey class by producing three basic diagrams.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\n# %%\n# Example 1 -- Mostly defaults\n#\n# This demonstrates how to create a simple diagram by implicitly calling the\n# Sankey.add() method and by appending finish() to the call to the class.\n\nSankey(flows=[0.25, 0.15, 0.60, -0.20, -0.15, -0.05, -0.50, -0.10],\n       labels=['', '', '', 'First', 'Second', 'Third', 'Fourth', 'Fifth'],\n       orientations=[-1, 1, 0, 1, 1, 1, 0, -1]).finish()\nplt.title(\"The default settings produce a diagram like this.\")\n\n# %%\n# Notice:\n#\n# 1. Axes weren't provided when Sankey() was instantiated, so they were\n#    created automatically.\n# 2. The scale argument wasn't necessary since the data was already\n#    normalized.\n# 3. By default, the lengths of the paths are justified.\n\n\n# %%\n# Example 2\n#\n# This demonstrates:\n#\n# 1. Setting one path longer than the others\n# 2. Placing a label in the middle of the diagram\n# 3. Using the scale argument to normalize the flows\n# 4. Implicitly passing keyword arguments to PathPatch()\n# 5. Changing the angle of the arrow heads\n# 6. Changing the offset between the tips of the paths and their labels\n# 7. Formatting the numbers in the path labels and the associated unit\n# 8. Changing the appearance of the patch and the labels after the figure is\n#    created\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title=\"Flow Diagram of a Widget\")\nsankey = Sankey(ax=ax, scale=0.01, offset=0.2, head_angle=180,\n                format='%.0f', unit='%')\nsankey.add(flows=[25, 0, 60, -10, -20, -5, -15, -10, -40],\n           labels=['', '', '', 'First', 'Second', 'Third', 'Fourth',\n                   'Fifth', 'Hurray!'],\n           orientations=[-1, 1, 0, 1, 1, 1, -1, -1, 0],\n           pathlengths=[0.25, 0.25, 0.25, 0.25, 0.25, 0.6, 0.25, 0.25,\n                        0.25],\n           patchlabel=\"Widget\\nA\")  # Arguments to matplotlib.patches.PathPatch\ndiagrams = sankey.finish()\ndiagrams[0].texts[-1].set_color('r')\ndiagrams[0].text.set_fontweight('bold')\n\n# %%\n# Notice:\n#\n# 1. Since the sum of the flows is nonzero, the width of the trunk isn't\n#    uniform.  The matplotlib logging system logs this at the DEBUG level.\n# 2. The second flow doesn't appear because its value is zero.  Again, this is\n#    logged at the DEBUG level.\n\n\n# %%\n# Example 3\n#\n# This demonstrates:\n#\n# 1. Connecting two systems\n# 2. Turning off the labels of the quantities\n# 3. Adding a legend\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[], title=\"Two Systems\")\nflows = [0.25, 0.15, 0.60, -0.10, -0.05, -0.25, -0.15, -0.10, -0.35]\nsankey = Sankey(ax=ax, unit=None)\nsankey.add(flows=flows, label='one',\n           orientations=[-1, 1, 0, 1, 1, 1, -1, -1, 0])\nsankey.add(flows=[-0.25, 0.15, 0.1], label='two',\n           orientations=[-1, -1, -1], prior=0, connect=(0, 0))\ndiagrams = sankey.finish()\ndiagrams[-1].patch.set_hatch('/')\nplt.legend()\n\n# %%\n# Notice that only one connection is specified, but the systems form a\n# circuit since: (1) the lengths of the paths are justified and (2) the\n# orientation and ordering of the flows is mirrored.\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.sankey`\n#    - `matplotlib.sankey.Sankey`\n#    - `matplotlib.sankey.Sankey.add`\n#    - `matplotlib.sankey.Sankey.finish`\n"
    },
    {
      "filename": "sankey_links.py",
      "title": "Sankey Links",
      "code": "\"\"\"\n======================================\nLong chain of connections using Sankey\n======================================\n\nDemonstrate/test the Sankey class by producing a long chain of connections.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\nlinks_per_side = 6\n\n\ndef side(sankey, n=1):\n    \"\"\"Generate a side chain.\"\"\"\n    prior = len(sankey.diagrams)\n    for i in range(0, 2*n, 2):\n        sankey.add(flows=[1, -1], orientations=[-1, -1],\n                   patchlabel=str(prior + i),\n                   prior=prior + i - 1, connect=(1, 0), alpha=0.5)\n        sankey.add(flows=[1, -1], orientations=[1, 1],\n                   patchlabel=str(prior + i + 1),\n                   prior=prior + i, connect=(1, 0), alpha=0.5)\n\n\ndef corner(sankey):\n    \"\"\"Generate a corner link.\"\"\"\n    prior = len(sankey.diagrams)\n    sankey.add(flows=[1, -1], orientations=[0, 1],\n               patchlabel=str(prior), facecolor='k',\n               prior=prior - 1, connect=(1, 0), alpha=0.5)\n\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title=\"Why would you want to do this?\\n(But you could.)\")\nsankey = Sankey(ax=ax, unit=None)\nsankey.add(flows=[1, -1], orientations=[0, 1],\n           patchlabel=\"0\", facecolor='k',\n           rotation=45)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\nsankey.finish()\n# Notice:\n# 1. The alignment doesn't drift significantly (if at all; with 16007\n#    subdiagrams there is still closure).\n# 2. The first diagram is rotated 45 deg, so all other diagrams are rotated\n#    accordingly.\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.sankey`\n#    - `matplotlib.sankey.Sankey`\n#    - `matplotlib.sankey.Sankey.add`\n#    - `matplotlib.sankey.Sankey.finish`\n"
    },
    {
      "filename": "sankey_rankine.py",
      "title": "Sankey Rankine",
      "code": "\"\"\"\n===================\nRankine power cycle\n===================\n\nDemonstrate the Sankey class with a practical example of a Rankine power cycle.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\nfig = plt.figure(figsize=(8, 9))\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title=\"Rankine Power Cycle: Example 8.6 from Moran and \"\n                     \"Shapiro\\n\\x22Fundamentals of Engineering Thermodynamics \"\n                     \"\\x22, 6th ed., 2008\")\nHdot = [260.431, 35.078, 180.794, 221.115, 22.700,\n        142.361, 10.193, 10.210, 43.670, 44.312,\n        68.631, 10.758, 10.758, 0.017, 0.642,\n        232.121, 44.559, 100.613, 132.168]  # MW\nsankey = Sankey(ax=ax, format='%.3G', unit=' MW', gap=0.5, scale=1.0/Hdot[0])\nsankey.add(patchlabel='\\n\\nPump 1', rotation=90, facecolor='#37c959',\n           flows=[Hdot[13], Hdot[6], -Hdot[7]],\n           labels=['Shaft power', '', None],\n           pathlengths=[0.4, 0.883, 0.25],\n           orientations=[1, -1, 0])\nsankey.add(patchlabel='\\n\\nOpen\\nheater', facecolor='#37c959',\n           flows=[Hdot[11], Hdot[7], Hdot[4], -Hdot[8]],\n           labels=[None, '', None, None],\n           pathlengths=[0.25, 0.25, 1.93, 0.25],\n           orientations=[1, 0, -1, 0], prior=0, connect=(2, 1))\nsankey.add(patchlabel='\\n\\nPump 2', facecolor='#37c959',\n           flows=[Hdot[14], Hdot[8], -Hdot[9]],\n           labels=['Shaft power', '', None],\n           pathlengths=[0.4, 0.25, 0.25],\n           orientations=[1, 0, 0], prior=1, connect=(3, 1))\nsankey.add(patchlabel='Closed\\nheater', trunklength=2.914, fc='#37c959',\n           flows=[Hdot[9], Hdot[1], -Hdot[11], -Hdot[10]],\n           pathlengths=[0.25, 1.543, 0.25, 0.25],\n           labels=['', '', None, None],\n           orientations=[0, -1, 1, -1], prior=2, connect=(2, 0))\nsankey.add(patchlabel='Trap', facecolor='#37c959', trunklength=5.102,\n           flows=[Hdot[11], -Hdot[12]],\n           labels=['\\n', None],\n           pathlengths=[1.0, 1.01],\n           orientations=[1, 1], prior=3, connect=(2, 0))\nsankey.add(patchlabel='Steam\\ngenerator', facecolor='#ff5555',\n           flows=[Hdot[15], Hdot[10], Hdot[2], -Hdot[3], -Hdot[0]],\n           labels=['Heat rate', '', '', None, None],\n           pathlengths=0.25,\n           orientations=[1, 0, -1, -1, -1], prior=3, connect=(3, 1))\nsankey.add(patchlabel='\\n\\n\\nTurbine 1', facecolor='#37c959',\n           flows=[Hdot[0], -Hdot[16], -Hdot[1], -Hdot[2]],\n           labels=['', None, None, None],\n           pathlengths=[0.25, 0.153, 1.543, 0.25],\n           orientations=[0, 1, -1, -1], prior=5, connect=(4, 0))\nsankey.add(patchlabel='\\n\\n\\nReheat', facecolor='#37c959',\n           flows=[Hdot[2], -Hdot[2]],\n           labels=[None, None],\n           pathlengths=[0.725, 0.25],\n           orientations=[-1, 0], prior=6, connect=(3, 0))\nsankey.add(patchlabel='Turbine 2', trunklength=3.212, facecolor='#37c959',\n           flows=[Hdot[3], Hdot[16], -Hdot[5], -Hdot[4], -Hdot[17]],\n           labels=[None, 'Shaft power', None, '', 'Shaft power'],\n           pathlengths=[0.751, 0.15, 0.25, 1.93, 0.25],\n           orientations=[0, -1, 0, -1, 1], prior=6, connect=(1, 1))\nsankey.add(patchlabel='Condenser', facecolor='#58b1fa', trunklength=1.764,\n           flows=[Hdot[5], -Hdot[18], -Hdot[6]],\n           labels=['', 'Heat rate', None],\n           pathlengths=[0.45, 0.25, 0.883],\n           orientations=[-1, 1, 0], prior=8, connect=(2, 0))\ndiagrams = sankey.finish()\nfor diagram in diagrams:\n    diagram.text.set_fontweight('bold')\n    diagram.text.set_fontsize('10')\n    for text in diagram.texts:\n        text.set_fontsize('10')\n# Notice that the explicit connections are handled automatically, but the\n# implicit ones currently are not.  The lengths of the paths and the trunks\n# must be adjusted manually, and that is a bit tricky.\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.sankey`\n#    - `matplotlib.sankey.Sankey`\n#    - `matplotlib.sankey.Sankey.add`\n#    - `matplotlib.sankey.Sankey.finish`\n"
    },
    {
      "filename": "skewt.py",
      "title": "Skewt",
      "code": "\"\"\"\n===========================================================\nSkewT-logP diagram: using transforms and custom projections\n===========================================================\n\nThis serves as an intensive exercise of Matplotlib's transforms and custom\nprojection API. This example produces a so-called SkewT-logP diagram, which is\na common plot in meteorology for displaying vertical profiles of temperature.\nAs far as Matplotlib is concerned, the complexity comes from having X and Y\naxes that are not orthogonal. This is handled by including a skew component to\nthe basic Axes transforms. Additional complexity comes in handling the fact\nthat the upper and lower X-axes have different data ranges, which necessitates\na bunch of custom classes for ticks, spines, and axis to handle this.\n\"\"\"\n\nfrom contextlib import ExitStack\n\nfrom matplotlib.axes import Axes\nimport matplotlib.axis as maxis\nfrom matplotlib.projections import register_projection\nimport matplotlib.spines as mspines\nimport matplotlib.transforms as transforms\n\n\n# The sole purpose of this class is to look at the upper, lower, or total\n# interval as appropriate and see what parts of the tick to draw, if any.\nclass SkewXTick(maxis.XTick):\n    def draw(self, renderer):\n        # When adding the callbacks with `stack.callback`, we fetch the current\n        # visibility state of the artist with `get_visible`; the ExitStack will\n        # restore these states (`set_visible`) at the end of the block (after\n        # the draw).\n        with ExitStack() as stack:\n            for artist in [self.gridline, self.tick1line, self.tick2line,\n                           self.label1, self.label2]:\n                stack.callback(artist.set_visible, artist.get_visible())\n            needs_lower = transforms.interval_contains(\n                self.axes.lower_xlim, self.get_loc())\n            needs_upper = transforms.interval_contains(\n                self.axes.upper_xlim, self.get_loc())\n            self.tick1line.set_visible(\n                self.tick1line.get_visible() and needs_lower)\n            self.label1.set_visible(\n                self.label1.get_visible() and needs_lower)\n            self.tick2line.set_visible(\n                self.tick2line.get_visible() and needs_upper)\n            self.label2.set_visible(\n                self.label2.get_visible() and needs_upper)\n            super().draw(renderer)\n\n    def get_view_interval(self):\n        return self.axes.xaxis.get_view_interval()\n\n\n# This class exists to provide two separate sets of intervals to the tick,\n# as well as create instances of the custom tick\nclass SkewXAxis(maxis.XAxis):\n    def _get_tick(self, major):\n        return SkewXTick(self.axes, None, major=major)\n\n    def get_view_interval(self):\n        return self.axes.upper_xlim[0], self.axes.lower_xlim[1]\n\n\n# This class exists to calculate the separate data range of the\n# upper X-axis and draw the spine there. It also provides this range\n# to the X-axis artist for ticking and gridlines\nclass SkewSpine(mspines.Spine):\n    def _adjust_location(self):\n        pts = self._path.vertices\n        if self.spine_type == 'top':\n            pts[:, 0] = self.axes.upper_xlim\n        else:\n            pts[:, 0] = self.axes.lower_xlim\n\n\n# This class handles registration of the skew-xaxes as a projection as well\n# as setting up the appropriate transformations. It also overrides standard\n# spines and axes instances as appropriate.\nclass SkewXAxes(Axes):\n    # The projection must specify a name.  This will be used be the\n    # user to select the projection, i.e. ``subplot(projection='skewx')``.\n    name = 'skewx'\n\n    def _init_axis(self):\n        # Taken from Axes and modified to use our modified X-axis\n        self.xaxis = SkewXAxis(self)\n        self.spines.top.register_axis(self.xaxis)\n        self.spines.bottom.register_axis(self.xaxis)\n        self.yaxis = maxis.YAxis(self)\n        self.spines.left.register_axis(self.yaxis)\n        self.spines.right.register_axis(self.yaxis)\n\n    def _gen_axes_spines(self):\n        spines = {'top': SkewSpine.linear_spine(self, 'top'),\n                  'bottom': mspines.Spine.linear_spine(self, 'bottom'),\n                  'left': mspines.Spine.linear_spine(self, 'left'),\n                  'right': mspines.Spine.linear_spine(self, 'right')}\n        return spines\n\n    def _set_lim_and_transforms(self):\n        \"\"\"\n        This is called once when the plot is created to set up all the\n        transforms for the data, text and grids.\n        \"\"\"\n        rot = 30\n\n        # Get the standard transform setup from the Axes base class\n        super()._set_lim_and_transforms()\n\n        # Need to put the skew in the middle, after the scale and limits,\n        # but before the transAxes. This way, the skew is done in Axes\n        # coordinates thus performing the transform around the proper origin\n        # We keep the pre-transAxes transform around for other users, like the\n        # spines for finding bounds\n        self.transDataToAxes = (\n            self.transScale\n            + self.transLimits\n            + transforms.Affine2D().skew_deg(rot, 0)\n        )\n        # Create the full transform from Data to Pixels\n        self.transData = self.transDataToAxes + self.transAxes\n\n        # Blended transforms like this need to have the skewing applied using\n        # both axes, in axes coords like before.\n        self._xaxis_transform = (\n            transforms.blended_transform_factory(\n                self.transScale + self.transLimits,\n                transforms.IdentityTransform())\n            + transforms.Affine2D().skew_deg(rot, 0)\n            + self.transAxes\n        )\n\n    @property\n    def lower_xlim(self):\n        return self.axes.viewLim.intervalx\n\n    @property\n    def upper_xlim(self):\n        pts = [[0., 1.], [1., 1.]]\n        return self.transDataToAxes.inverted().transform(pts)[:, 0]\n\n\n# Now register the projection with matplotlib so the user can select it.\nregister_projection(SkewXAxes)\n\nif __name__ == '__main__':\n    # Now make a simple example using the custom projection.\n    from io import StringIO\n\n    import matplotlib.pyplot as plt\n    import numpy as np\n\n    from matplotlib.ticker import (MultipleLocator, NullFormatter,\n                                   ScalarFormatter)\n\n    # Some example data.\n    data_txt = '''\n        978.0    345    7.8    0.8\n        971.0    404    7.2    0.2\n        946.7    610    5.2   -1.8\n        944.0    634    5.0   -2.0\n        925.0    798    3.4   -2.6\n        911.8    914    2.4   -2.7\n        906.0    966    2.0   -2.7\n        877.9   1219    0.4   -3.2\n        850.0   1478   -1.3   -3.7\n        841.0   1563   -1.9   -3.8\n        823.0   1736    1.4   -0.7\n        813.6   1829    4.5    1.2\n        809.0   1875    6.0    2.2\n        798.0   1988    7.4   -0.6\n        791.0   2061    7.6   -1.4\n        783.9   2134    7.0   -1.7\n        755.1   2438    4.8   -3.1\n        727.3   2743    2.5   -4.4\n        700.5   3048    0.2   -5.8\n        700.0   3054    0.2   -5.8\n        698.0   3077    0.0   -6.0\n        687.0   3204   -0.1   -7.1\n        648.9   3658   -3.2  -10.9\n        631.0   3881   -4.7  -12.7\n        600.7   4267   -6.4  -16.7\n        592.0   4381   -6.9  -17.9\n        577.6   4572   -8.1  -19.6\n        555.3   4877  -10.0  -22.3\n        536.0   5151  -11.7  -24.7\n        533.8   5182  -11.9  -25.0\n        500.0   5680  -15.9  -29.9\n        472.3   6096  -19.7  -33.4\n        453.0   6401  -22.4  -36.0\n        400.0   7310  -30.7  -43.7\n        399.7   7315  -30.8  -43.8\n        387.0   7543  -33.1  -46.1\n        382.7   7620  -33.8  -46.8\n        342.0   8398  -40.5  -53.5\n        320.4   8839  -43.7  -56.7\n        318.0   8890  -44.1  -57.1\n        310.0   9060  -44.7  -58.7\n        306.1   9144  -43.9  -57.9\n        305.0   9169  -43.7  -57.7\n        300.0   9280  -43.5  -57.5\n        292.0   9462  -43.7  -58.7\n        276.0   9838  -47.1  -62.1\n        264.0  10132  -47.5  -62.5\n        251.0  10464  -49.7  -64.7\n        250.0  10490  -49.7  -64.7\n        247.0  10569  -48.7  -63.7\n        244.0  10649  -48.9  -63.9\n        243.3  10668  -48.9  -63.9\n        220.0  11327  -50.3  -65.3\n        212.0  11569  -50.5  -65.5\n        210.0  11631  -49.7  -64.7\n        200.0  11950  -49.9  -64.9\n        194.0  12149  -49.9  -64.9\n        183.0  12529  -51.3  -66.3\n        164.0  13233  -55.3  -68.3\n        152.0  13716  -56.5  -69.5\n        150.0  13800  -57.1  -70.1\n        136.0  14414  -60.5  -72.5\n        132.0  14600  -60.1  -72.1\n        131.4  14630  -60.2  -72.2\n        128.0  14792  -60.9  -72.9\n        125.0  14939  -60.1  -72.1\n        119.0  15240  -62.2  -73.8\n        112.0  15616  -64.9  -75.9\n        108.0  15838  -64.1  -75.1\n        107.8  15850  -64.1  -75.1\n        105.0  16010  -64.7  -75.7\n        103.0  16128  -62.9  -73.9\n        100.0  16310  -62.5  -73.5\n    '''\n\n    # Parse the data\n    sound_data = StringIO(data_txt)\n    p, h, T, Td = np.loadtxt(sound_data, unpack=True)\n\n    # Create a new figure. The dimensions here give a good aspect ratio\n    fig = plt.figure(figsize=(6.5875, 6.2125))\n    ax = fig.add_subplot(projection='skewx')\n\n    plt.grid(True)\n\n    # Plot the data using normal plotting functions, in this case using\n    # log scaling in Y, as dictated by the typical meteorological plot\n    ax.semilogy(T, p, color='C3')\n    ax.semilogy(Td, p, color='C2')\n\n    # An example of a slanted line at constant X\n    l = ax.axvline(0, color='C0')\n\n    # Disables the log-formatting that comes with semilogy\n    ax.yaxis.set_major_formatter(ScalarFormatter())\n    ax.yaxis.set_minor_formatter(NullFormatter())\n    ax.set_yticks(np.linspace(100, 1000, 10))\n    ax.set_ylim(1050, 100)\n\n    ax.xaxis.set_major_locator(MultipleLocator(10))\n    ax.set_xlim(-50, 50)\n\n    plt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.transforms`\n#    - `matplotlib.spines`\n#    - `matplotlib.spines.Spine`\n#    - `matplotlib.spines.Spine.register_axis`\n#    - `matplotlib.projections`\n#    - `matplotlib.projections.register_projection`\n"
    },
    {
      "filename": "topographic_hillshading.py",
      "title": "Topographic Hillshading",
      "code": "\"\"\"\n=======================\nTopographic hillshading\n=======================\n\nDemonstrates the visual effect of varying blend mode and vertical exaggeration\non \"hillshaded\" plots.\n\nNote that the \"overlay\" and \"soft\" blend modes work well for complex surfaces\nsuch as this example, while the default \"hsv\" blend mode works best for smooth\nsurfaces such as many mathematical functions.\n\nIn most cases, hillshading is used purely for visual purposes, and *dx*/*dy*\ncan be safely ignored. In that case, you can tweak *vert_exag* (vertical\nexaggeration) by trial and error to give the desired visual effect. However,\nthis example demonstrates how to use the *dx* and *dy* keyword arguments to\nensure that the *vert_exag* parameter is the true vertical exaggeration.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nfrom matplotlib.colors import LightSource\n\ndem = get_sample_data('jacksboro_fault_dem.npz')\nz = dem['elevation']\n# -- Optional dx and dy for accurate vertical exaggeration --------------------\n# If you need topographically accurate vertical exaggeration, or you don't want\n# to guess at what *vert_exag* should be, you'll need to specify the cellsize\n# of the grid (i.e. the *dx* and *dy* parameters).  Otherwise, any *vert_exag*\n# value you specify will be relative to the grid spacing of your input data\n# (in other words, *dx* and *dy* default to 1.0, and *vert_exag* is calculated\n# relative to those parameters).  Similarly, *dx* and *dy* are assumed to be in\n# the same units as your input z-values.  Therefore, we'll need to convert the\n# given dx and dy from decimal degrees to meters.\ndx, dy = dem['dx'], dem['dy']\ndy = 111200 * dy\ndx = 111200 * dx * np.cos(np.radians(dem['ymin']))\n# -----------------------------------------------------------------------------\n\n# Shade from the northwest, with the sun 45 degrees from horizontal\nls = LightSource(azdeg=315, altdeg=45)\ncmap = plt.cm.gist_earth\n\nfig, axs = plt.subplots(nrows=4, ncols=3, figsize=(8, 9))\nplt.setp(axs.flat, xticks=[], yticks=[])\n\n# Vary vertical exaggeration and blend mode and plot all combinations\nfor col, ve in zip(axs.T, [0.1, 1, 10]):\n    # Show the hillshade intensity image in the first row\n    col[0].imshow(ls.hillshade(z, vert_exag=ve, dx=dx, dy=dy), cmap='gray')\n\n    # Place hillshaded plots with different blend modes in the rest of the rows\n    for ax, mode in zip(col[1:], ['hsv', 'overlay', 'soft']):\n        rgb = ls.shade(z, cmap=cmap, blend_mode=mode,\n                       vert_exag=ve, dx=dx, dy=dy)\n        ax.imshow(rgb)\n\n# Label rows and columns\nfor ax, ve in zip(axs[0], [0.1, 1, 10]):\n    ax.set_title(f'{ve}', size=18)\nfor ax, mode in zip(axs[:, 0], ['Hillshade', 'hsv', 'overlay', 'soft']):\n    ax.set_ylabel(mode, size=18)\n\n# Group labels...\naxs[0, 1].annotate('Vertical Exaggeration', (0.5, 1), xytext=(0, 30),\n                   textcoords='offset points', xycoords='axes fraction',\n                   ha='center', va='bottom', size=20)\naxs[2, 0].annotate('Blend Mode', (0, 0.5), xytext=(-30, 0),\n                   textcoords='offset points', xycoords='axes fraction',\n                   ha='right', va='center', size=20, rotation=90)\nfig.subplots_adjust(bottom=0.05, right=0.95)\n\nplt.show()\n"
    }
  ],
  "spines": [
    {
      "filename": "centered_spines_with_arrows.py",
      "title": "Centered Spines With Arrows",
      "code": "\"\"\"\n===========================\nCentered spines with arrows\n===========================\n\nThis example shows a way to draw a \"math textbook\" style plot, where the\nspines (\"axes lines\") are drawn at ``x = 0`` and ``y = 0``, and have arrows at\ntheir ends.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n# Move the left and bottom spines to x = 0 and y = 0, respectively.\nax.spines[[\"left\", \"bottom\"]].set_position((\"data\", 0))\n# Hide the top and right spines.\nax.spines[[\"top\", \"right\"]].set_visible(False)\n\n# Draw arrows (as black triangles: \">k\"/\"^k\") at the end of the axes.  In each\n# case, one of the coordinates (0) is a data coordinate (i.e., y = 0 or x = 0,\n# respectively) and the other one (1) is an axes coordinate (i.e., at the very\n# right/top of the axes).  Also, disable clipping (clip_on=False) as the marker\n# actually spills out of the Axes.\nax.plot(1, 0, \">k\", transform=ax.get_yaxis_transform(), clip_on=False)\nax.plot(0, 1, \"^k\", transform=ax.get_xaxis_transform(), clip_on=False)\n\n# Some sample data.\nx = np.linspace(-0.5, 1., 100)\nax.plot(x, np.sin(x*np.pi))\n\nplt.show()\n"
    },
    {
      "filename": "multiple_yaxis_with_spines.py",
      "title": "Multiple Yaxis With Spines",
      "code": "r\"\"\"\n===========================\nMultiple y-axis with Spines\n===========================\n\nCreate multiple y axes with a shared x-axis. This is done by creating\na `~.axes.Axes.twinx` Axes, turning all spines but the right one invisible\nand offset its position using `~.spines.Spine.set_position`.\n\nNote that this approach uses `matplotlib.axes.Axes` and their\n`~matplotlib.spines.Spine`\\s.  Alternative approaches using non-standard Axes\nare shown in the :doc:`/gallery/axisartist/demo_parasite_axes` and\n:doc:`/gallery/axisartist/demo_parasite_axes2` examples.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(right=0.75)\n\ntwin1 = ax.twinx()\ntwin2 = ax.twinx()\n\n# Offset the right spine of twin2.  The ticks and label have already been\n# placed on the right by twinx above.\ntwin2.spines.right.set_position((\"axes\", 1.2))\n\np1, = ax.plot([0, 1, 2], [0, 1, 2], \"C0\", label=\"Density\")\np2, = twin1.plot([0, 1, 2], [0, 3, 2], \"C1\", label=\"Temperature\")\np3, = twin2.plot([0, 1, 2], [50, 30, 15], \"C2\", label=\"Velocity\")\n\nax.set(xlim=(0, 2), ylim=(0, 2), xlabel=\"Distance\", ylabel=\"Density\")\ntwin1.set(ylim=(0, 4), ylabel=\"Temperature\")\ntwin2.set(ylim=(1, 65), ylabel=\"Velocity\")\n\nax.yaxis.label.set_color(p1.get_color())\ntwin1.yaxis.label.set_color(p2.get_color())\ntwin2.yaxis.label.set_color(p3.get_color())\n\nax.tick_params(axis='y', colors=p1.get_color())\ntwin1.tick_params(axis='y', colors=p2.get_color())\ntwin2.tick_params(axis='y', colors=p3.get_color())\n\nax.legend(handles=[p1, p2, p3])\n\nplt.show()\n"
    },
    {
      "filename": "spine_placement_demo.py",
      "title": "Spine Placement Demo",
      "code": "\"\"\"\n===============\nSpine placement\n===============\n\nThe position of the axis spines can be influenced using `~.Spine.set_position`.\n\nNote: If you want to obtain arrow heads at the ends of the axes, also check\nout the :doc:`/gallery/spines/centered_spines_with_arrows` example.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# %%\n\nx = np.linspace(0, 2*np.pi, 100)\ny = 2 * np.sin(x)\n\nfig, ax_dict = plt.subplot_mosaic(\n    [['center', 'zero'],\n     ['axes', 'data']]\n)\nfig.suptitle('Spine positions')\n\n\nax = ax_dict['center']\nax.set_title(\"'center'\")\nax.plot(x, y)\nax.spines[['left', 'bottom']].set_position('center')\nax.spines[['top', 'right']].set_visible(False)\n\nax = ax_dict['zero']\nax.set_title(\"'zero'\")\nax.plot(x, y)\nax.spines[['left', 'bottom']].set_position('zero')\nax.spines[['top', 'right']].set_visible(False)\n\nax = ax_dict['axes']\nax.set_title(\"'axes' (0.2, 0.2)\")\nax.plot(x, y)\nax.spines.left.set_position(('axes', 0.2))\nax.spines.bottom.set_position(('axes', 0.2))\nax.spines[['top', 'right']].set_visible(False)\n\nax = ax_dict['data']\nax.set_title(\"'data' (1, 2)\")\nax.plot(x, y)\nax.spines.left.set_position(('data', 1))\nax.spines.bottom.set_position(('data', 2))\nax.spines[['top', 'right']].set_visible(False)\n\nplt.show()\n"
    },
    {
      "filename": "spines.py",
      "title": "Spines",
      "code": "\"\"\"\n======\nSpines\n======\n\nThis demo compares:\n\n- normal Axes, with spines on all four sides;\n- an Axes with spines only on the left and bottom;\n- an Axes using custom bounds to limit the extent of the spine.\n\nEach `.axes.Axes` has a list of `.Spine` objects, accessible\nvia the container ``ax.spines``.\n\n.. redirect-from:: /gallery/spines/spines_bounds\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 2 * np.pi, 100)\ny = 2 * np.sin(x)\n\n# Constrained layout makes sure the labels don't overlap the Axes.\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=3, layout='constrained')\n\nax0.plot(x, y)\nax0.set_title('normal spines')\n\nax1.plot(x, y)\nax1.set_title('bottom-left spines')\n\n# Hide the right and top spines\nax1.spines.right.set_visible(False)\nax1.spines.top.set_visible(False)\n\nax2.plot(x, y)\nax2.set_title('spines with bounds limited to data range')\n\n# Only draw spines for the data range, not in the margins\nax2.spines.bottom.set_bounds(x.min(), x.max())\nax2.spines.left.set_bounds(y.min(), y.max())\n# Hide the right and top spines\nax2.spines.right.set_visible(False)\nax2.spines.top.set_visible(False)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.artist.Artist.set_visible`\n#    - `matplotlib.spines.Spine.set_bounds`\n"
    },
    {
      "filename": "spines_dropped.py",
      "title": "Spines Dropped",
      "code": "\"\"\"\n==============\nDropped spines\n==============\n\nDemo of spines offset from the axes (a.k.a. \"dropped spines\").\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef adjust_spines(ax, visible_spines):\n    ax.label_outer(remove_inner_ticks=True)\n    ax.grid(color='0.9')\n\n    for loc, spine in ax.spines.items():\n        if loc in visible_spines:\n            spine.set_position(('outward', 10))  # outward by 10 points\n        else:\n            spine.set_visible(False)\n\n\nx = np.linspace(0, 2 * np.pi, 100)\n\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].plot(x, np.sin(x))\naxs[0, 1].plot(x, np.cos(x))\naxs[1, 0].plot(x, -np.cos(x))\naxs[1, 1].plot(x, -np.sin(x))\n\nadjust_spines(axs[0, 0], ['left'])\nadjust_spines(axs[0, 1], [])\nadjust_spines(axs[1, 0], ['left', 'bottom'])\nadjust_spines(axs[1, 1], ['bottom'])\n\nplt.show()\n"
    }
  ],
  "statistics": [
    {
      "filename": "boxplot.py",
      "title": "Boxplot",
      "code": "\"\"\"\n=================================\nArtist customization in box plots\n=================================\n\nThis example demonstrates how to use the various keyword arguments to fully\ncustomize box plots. The first figure demonstrates how to remove and add\nindividual components (note that the mean is the only value not shown by\ndefault). The second figure demonstrates how the styles of the artists can be\ncustomized. It also demonstrates how to set the limit of the whiskers to\nspecific percentiles (lower right Axes)\n\nA good general reference on boxplots and their history can be found here:\nhttps://vita.had.co.nz/papers/boxplots.pdf\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# fake data\nnp.random.seed(19680801)\ndata = np.random.lognormal(size=(37, 4), mean=1.5, sigma=1.75)\nlabels = list('ABCD')\nfs = 10  # fontsize\n\n# %%\n# Demonstrate how to toggle the display of different elements:\n\nfig, axs = plt.subplots(nrows=2, ncols=3, figsize=(6, 6), sharey=True)\naxs[0, 0].boxplot(data, tick_labels=labels)\naxs[0, 0].set_title('Default', fontsize=fs)\n\naxs[0, 1].boxplot(data, tick_labels=labels, showmeans=True)\naxs[0, 1].set_title('showmeans=True', fontsize=fs)\n\naxs[0, 2].boxplot(data, tick_labels=labels, showmeans=True, meanline=True)\naxs[0, 2].set_title('showmeans=True,\\nmeanline=True', fontsize=fs)\n\naxs[1, 0].boxplot(data, tick_labels=labels, showbox=False, showcaps=False)\ntufte_title = 'Tufte Style \\n(showbox=False,\\nshowcaps=False)'\naxs[1, 0].set_title(tufte_title, fontsize=fs)\n\naxs[1, 1].boxplot(data, tick_labels=labels, notch=True, bootstrap=10000)\naxs[1, 1].set_title('notch=True,\\nbootstrap=10000', fontsize=fs)\n\naxs[1, 2].boxplot(data, tick_labels=labels, showfliers=False)\naxs[1, 2].set_title('showfliers=False', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale('log')\n    ax.set_yticklabels([])\n\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\n\n# %%\n# Demonstrate how to customize the display different elements:\n\nboxprops = dict(linestyle='--', linewidth=3, color='darkgoldenrod')\nflierprops = dict(marker='o', markerfacecolor='green', markersize=12,\n                  markeredgecolor='none')\nmedianprops = dict(linestyle='-.', linewidth=2.5, color='firebrick')\nmeanpointprops = dict(marker='D', markeredgecolor='black',\n                      markerfacecolor='firebrick')\nmeanlineprops = dict(linestyle='--', linewidth=2.5, color='purple')\n\nfig, axs = plt.subplots(nrows=2, ncols=3, figsize=(6, 6), sharey=True)\naxs[0, 0].boxplot(data, boxprops=boxprops)\naxs[0, 0].set_title('Custom boxprops', fontsize=fs)\n\naxs[0, 1].boxplot(data, flierprops=flierprops, medianprops=medianprops)\naxs[0, 1].set_title('Custom medianprops\\nand flierprops', fontsize=fs)\n\naxs[0, 2].boxplot(data, whis=(0, 100))\naxs[0, 2].set_title('whis=(0, 100)', fontsize=fs)\n\naxs[1, 0].boxplot(data, meanprops=meanpointprops, meanline=False,\n                  showmeans=True)\naxs[1, 0].set_title('Custom mean\\nas point', fontsize=fs)\n\naxs[1, 1].boxplot(data, meanprops=meanlineprops, meanline=True,\n                  showmeans=True)\naxs[1, 1].set_title('Custom mean\\nas line', fontsize=fs)\n\naxs[1, 2].boxplot(data, whis=[15, 85])\naxs[1, 2].set_title('whis=[15, 85]\\n#percentiles', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale('log')\n    ax.set_yticklabels([])\n\nfig.suptitle(\"I never said they'd be pretty\")\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: boxplot, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.boxplot` / `matplotlib.pyplot.boxplot`\n"
    },
    {
      "filename": "boxplot_color.py",
      "title": "Boxplot Color",
      "code": "\"\"\"\n=================================\nBox plots with custom fill colors\n=================================\n\nTo color each box of a box plot individually:\n\n1) use the keyword argument ``patch_artist=True`` to create filled boxes.\n2) loop through the created boxes and adapt their color.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\nfruit_weights = [\n    np.random.normal(130, 10, size=100),\n    np.random.normal(125, 20, size=100),\n    np.random.normal(120, 30, size=100),\n]\nlabels = ['peaches', 'oranges', 'tomatoes']\ncolors = ['peachpuff', 'orange', 'tomato']\n\nfig, ax = plt.subplots()\nax.set_ylabel('fruit weight (g)')\n\nbplot = ax.boxplot(fruit_weights,\n                   patch_artist=True,  # fill with color\n                   tick_labels=labels)  # will be used to label x-ticks\n\n# fill with colors\nfor patch, color in zip(bplot['boxes'], colors):\n    patch.set_facecolor(color)\n\nplt.show()\n\n# %%\n#\n# .. tags:: styling: color, domain: statistics, plot-type: boxplot\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.boxplot` / `matplotlib.pyplot.boxplot`\n"
    },
    {
      "filename": "boxplot_demo.py",
      "title": "Boxplot Demo",
      "code": "\"\"\"\n========\nBoxplots\n========\n\nVisualizing boxplots with matplotlib.\n\nThe following examples show off how to visualize boxplots with\nMatplotlib. There are many options to control their appearance and\nthe statistics that they use to summarize the data.\n\n.. redirect-from:: /gallery/pyplots/boxplot_demo_pyplot\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# fake up some data\nspread = np.random.rand(50) * 100\ncenter = np.ones(25) * 50\nflier_high = np.random.rand(10) * 100 + 100\nflier_low = np.random.rand(10) * -100\ndata = np.concatenate((spread, center, flier_high, flier_low))\n\nfig, axs = plt.subplots(2, 3)\n\n# basic plot\naxs[0, 0].boxplot(data)\naxs[0, 0].set_title('basic plot')\n\n# notched plot\naxs[0, 1].boxplot(data, notch=True)\naxs[0, 1].set_title('notched plot')\n\n# change outlier point symbols\naxs[0, 2].boxplot(data, sym='gD')\naxs[0, 2].set_title('change outlier\\npoint symbols')\n\n# don't show outlier points\naxs[1, 0].boxplot(data, sym='')\naxs[1, 0].set_title(\"don't show\\noutlier points\")\n\n# horizontal boxes\naxs[1, 1].boxplot(data, sym='rs', orientation='horizontal')\naxs[1, 1].set_title('horizontal boxes')\n\n# change whisker length\naxs[1, 2].boxplot(data, sym='rs', orientation='horizontal', whis=0.75)\naxs[1, 2].set_title('change whisker length')\n\nfig.subplots_adjust(left=0.08, right=0.98, bottom=0.05, top=0.9,\n                    hspace=0.4, wspace=0.3)\n\n# fake up some more data\nspread = np.random.rand(50) * 100\ncenter = np.ones(25) * 40\nflier_high = np.random.rand(10) * 100 + 100\nflier_low = np.random.rand(10) * -100\nd2 = np.concatenate((spread, center, flier_high, flier_low))\n# Making a 2-D array only works if all the columns are the\n# same length.  If they are not, then use a list instead.\n# This is actually more efficient because boxplot converts\n# a 2-D array into a list of vectors internally anyway.\ndata = [data, d2, d2[::2]]\n\n# Multiple box plots on one Axes\nfig, ax = plt.subplots()\nax.boxplot(data)\n\nplt.show()\n\n\n# %%\n# Below we'll generate data from five different probability distributions,\n# each with different characteristics. We want to play with how an IID\n# bootstrap resample of the data preserves the distributional\n# properties of the original sample, and a boxplot is one visual tool\n# to make this assessment\n\nrandom_dists = ['Normal(1, 1)', 'Lognormal(1, 1)', 'Exp(1)', 'Gumbel(6, 4)',\n                'Triangular(2, 9, 11)']\nN = 500\n\nnorm = np.random.normal(1, 1, N)\nlogn = np.random.lognormal(1, 1, N)\nexpo = np.random.exponential(1, N)\ngumb = np.random.gumbel(6, 4, N)\ntria = np.random.triangular(2, 9, 11, N)\n\n# Generate some random indices that we'll use to resample the original data\n# arrays. For code brevity, just use the same random indices for each array\nbootstrap_indices = np.random.randint(0, N, N)\ndata = [\n    norm, norm[bootstrap_indices],\n    logn, logn[bootstrap_indices],\n    expo, expo[bootstrap_indices],\n    gumb, gumb[bootstrap_indices],\n    tria, tria[bootstrap_indices],\n]\n\nfig, ax1 = plt.subplots(figsize=(10, 6))\nfig.canvas.manager.set_window_title('A Boxplot Example')\nfig.subplots_adjust(left=0.075, right=0.95, top=0.9, bottom=0.25)\n\nbp = ax1.boxplot(data, notch=False, sym='+', orientation='vertical', whis=1.5)\nplt.setp(bp['boxes'], color='black')\nplt.setp(bp['whiskers'], color='black')\nplt.setp(bp['fliers'], color='red', marker='+')\n\n# Add a horizontal grid to the plot, but make it very light in color\n# so we can use it for reading data values but not be distracting\nax1.yaxis.grid(True, linestyle='-', which='major', color='lightgrey',\n               alpha=0.5)\n\nax1.set(\n    axisbelow=True,  # Hide the grid behind plot objects\n    title='Comparison of IID Bootstrap Resampling Across Five Distributions',\n    xlabel='Distribution',\n    ylabel='Value',\n)\n\n# Now fill the boxes with desired colors\nbox_colors = ['darkkhaki', 'royalblue']\nnum_boxes = len(data)\nmedians = np.empty(num_boxes)\nfor i in range(num_boxes):\n    box = bp['boxes'][i]\n    box_x = []\n    box_y = []\n    for j in range(5):\n        box_x.append(box.get_xdata()[j])\n        box_y.append(box.get_ydata()[j])\n    box_coords = np.column_stack([box_x, box_y])\n    # Alternate between Dark Khaki and Royal Blue\n    ax1.add_patch(Polygon(box_coords, facecolor=box_colors[i % 2]))\n    # Now draw the median lines back over what we just filled in\n    med = bp['medians'][i]\n    median_x = []\n    median_y = []\n    for j in range(2):\n        median_x.append(med.get_xdata()[j])\n        median_y.append(med.get_ydata()[j])\n        ax1.plot(median_x, median_y, 'k')\n    medians[i] = median_y[0]\n    # Finally, overplot the sample averages, with horizontal alignment\n    # in the center of each box\n    ax1.plot(np.average(med.get_xdata()), np.average(data[i]),\n             color='w', marker='*', markeredgecolor='k')\n\n# Set the axes ranges and axes labels\nax1.set_xlim(0.5, num_boxes + 0.5)\ntop = 40\nbottom = -5\nax1.set_ylim(bottom, top)\nax1.set_xticklabels(np.repeat(random_dists, 2),\n                    rotation=45, fontsize=8)\n\n# Due to the Y-axis scale being different across samples, it can be\n# hard to compare differences in medians across the samples. Add upper\n# X-axis tick labels with the sample medians to aid in comparison\n# (just use two decimal places of precision)\npos = np.arange(num_boxes) + 1\nupper_labels = [str(round(s, 2)) for s in medians]\nweights = ['bold', 'semibold']\nfor tick, label in zip(range(num_boxes), ax1.get_xticklabels()):\n    k = tick % 2\n    ax1.text(pos[tick], .95, upper_labels[tick],\n             transform=ax1.get_xaxis_transform(),\n             horizontalalignment='center', size='x-small',\n             weight=weights[k], color=box_colors[k])\n\n# Finally, add a basic legend\nfig.text(0.80, 0.08, f'{N} Random Numbers',\n         backgroundcolor=box_colors[0], color='black', weight='roman',\n         size='x-small')\nfig.text(0.80, 0.045, 'IID Bootstrap Resample',\n         backgroundcolor=box_colors[1],\n         color='white', weight='roman', size='x-small')\nfig.text(0.80, 0.015, '*', color='white', backgroundcolor='silver',\n         weight='roman', size='medium')\nfig.text(0.815, 0.013, ' Average Value', color='black', weight='roman',\n         size='x-small')\n\nplt.show()\n\n# %%\n# Here we write a custom function to bootstrap confidence intervals.\n# We can then use the boxplot along with this function to show these intervals.\n\n\ndef fake_bootstrapper(n):\n    \"\"\"\n    This is just a placeholder for the user's method of\n    bootstrapping the median and its confidence intervals.\n\n    Returns an arbitrary median and confidence interval packed into a tuple.\n    \"\"\"\n    if n == 1:\n        med = 0.1\n        ci = (-0.25, 0.25)\n    else:\n        med = 0.2\n        ci = (-0.35, 0.50)\n    return med, ci\n\ninc = 0.1\ne1 = np.random.normal(0, 1, size=500)\ne2 = np.random.normal(0, 1, size=500)\ne3 = np.random.normal(0, 1 + inc, size=500)\ne4 = np.random.normal(0, 1 + 2*inc, size=500)\n\ntreatments = [e1, e2, e3, e4]\nmed1, ci1 = fake_bootstrapper(1)\nmed2, ci2 = fake_bootstrapper(2)\nmedians = [None, None, med1, med2]\nconf_intervals = [None, None, ci1, ci2]\n\nfig, ax = plt.subplots()\npos = np.arange(len(treatments)) + 1\nbp = ax.boxplot(treatments, sym='k+', positions=pos,\n                notch=True, bootstrap=5000,\n                usermedians=medians,\n                conf_intervals=conf_intervals)\n\nax.set_xlabel('treatment')\nax.set_ylabel('response')\nplt.setp(bp['whiskers'], color='k', linestyle='-')\nplt.setp(bp['fliers'], markersize=3.0)\nplt.show()\n\n\n# %%\n# Here we customize the widths of the caps .\n\nx = np.linspace(-7, 7, 140)\nx = np.hstack([-25, x, 25])\nfig, ax = plt.subplots()\n\nax.boxplot([x, x], notch=True, capwidths=[0.01, 0.2])\n\nplt.show()\n\n# %%\n#\n# .. tags:: domain: statistics, plot-type: boxplot\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.boxplot` / `matplotlib.pyplot.boxplot`\n#    - `matplotlib.artist.Artist.set` / `matplotlib.pyplot.setp`\n"
    },
    {
      "filename": "boxplot_vs_violin.py",
      "title": "Boxplot Vs Violin",
      "code": "\"\"\"\n===================================\nBox plot vs. violin plot comparison\n===================================\n\nNote that although violin plots are closely related to Tukey's (1977)\nbox plots, they add useful information such as the distribution of the\nsample data (density trace).\n\nBy default, box plots show data points outside 1.5 * the inter-quartile\nrange as outliers above or below the whiskers whereas violin plots show\nthe whole range of the data.\n\nA good general reference on boxplots and their history can be found\nhere: http://vita.had.co.nz/papers/boxplots.pdf\n\nViolin plots require matplotlib >= 1.4.\n\nFor more information on violin plots, the scikit-learn docs have a great\nsection: https://scikit-learn.org/stable/modules/density.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axs = plt.subplots(nrows=1, ncols=2, figsize=(9, 4))\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# generate some random test data\nall_data = [np.random.normal(0, std, 100) for std in range(6, 10)]\n\n# plot violin plot\naxs[0].violinplot(all_data,\n                  showmeans=False,\n                  showmedians=True)\naxs[0].set_title('Violin plot')\n\n# plot box plot\naxs[1].boxplot(all_data)\naxs[1].set_title('Box plot')\n\n# adding horizontal grid lines\nfor ax in axs:\n    ax.yaxis.grid(True)\n    ax.set_xticks([y + 1 for y in range(len(all_data))],\n                  labels=['x1', 'x2', 'x3', 'x4'])\n    ax.set_xlabel('Four separate samples')\n    ax.set_ylabel('Observed values')\n\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: violin, plot-type: boxplot, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.boxplot` / `matplotlib.pyplot.boxplot`\n#    - `matplotlib.axes.Axes.violinplot` / `matplotlib.pyplot.violinplot`\n"
    },
    {
      "filename": "bxp.py",
      "title": "Bxp",
      "code": "\"\"\"\n=============================================\nSeparate calculation and plotting of boxplots\n=============================================\n\nDrawing a `~.axes.Axes.boxplot` for a given data set, consists of two main operations,\nthat can also be used separately:\n\n1. Calculating the boxplot statistics: `matplotlib.cbook.boxplot_stats`\n2. Drawing the boxplot: `matplotlib.axes.Axes.bxp`\n\nThus, ``ax.boxplot(data)`` is equivalent to ::\n\n    stats = cbook.boxplot_stats(data)\n    ax.bxp(stats)\n\nAll styling keyword arguments are identical between `~.axes.Axes.boxplot` and\n`~.axes.Axes.bxp`, and they are passed through from `~.axes.Axes.boxplot` to\n`~.axes.Axes.bxp`. However, the *tick_labels* parameter of `~.axes.Axes.boxplot`\ntranslates to a generic *labels* parameter in `.boxplot_stats`, because the labels are\ndata-related and attached to the returned per-dataset dictionaries.\n\nThe following code demonstrates the equivalence between the two methods.\n\n\"\"\"\n# sphinx_gallery_thumbnail_number = 2\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\n\nnp.random.seed(19680801)\ndata = np.random.randn(20, 3)\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\n\n# single boxplot call\nax1.boxplot(data, tick_labels=['A', 'B', 'C'],\n            patch_artist=True, boxprops={'facecolor': 'bisque'})\n\n# separate calculation of statistics and plotting\nstats = cbook.boxplot_stats(data, labels=['A', 'B', 'C'])\nax2.bxp(stats, patch_artist=True, boxprops={'facecolor': 'bisque'})\n\n# %%\n# Using the separate functions allows to pre-calculate statistics, in case you need\n# them explicitly for other purposes, or to reuse the statistics for multiple plots.\n#\n# Conversely, you can also use the `~.axes.Axes.bxp` function directly, if you already\n# have the statistical parameters:\n\nfig, ax = plt.subplots()\n\nstats = [\n    dict(med=0, q1=-1, q3=1, whislo=-2, whishi=2, fliers=[-4, -3, 3, 4], label='A'),\n    dict(med=0, q1=-2, q3=2, whislo=-3, whishi=3, fliers=[], label='B'),\n    dict(med=0, q1=-3, q3=3, whislo=-4, whishi=4, fliers=[], label='C'),\n]\n\nax.bxp(stats, patch_artist=True, boxprops={'facecolor': 'bisque'})\n\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: speciality, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.bxp`\n#    - `matplotlib.axes.Axes.boxplot`\n#    - `matplotlib.cbook.boxplot_stats`\n"
    },
    {
      "filename": "confidence_ellipse.py",
      "title": "Confidence Ellipse",
      "code": "\"\"\"\n======================================================\nPlot a confidence ellipse of a two-dimensional dataset\n======================================================\n\nThis example shows how to plot a confidence ellipse of a\ntwo-dimensional dataset, using its pearson correlation coefficient.\n\nThe approach that is used to obtain the correct geometry is\nexplained and proved here:\n\nhttps://carstenschelp.github.io/2018/09/14/Plot_Confidence_Ellipse_001.html\n\nThe method avoids the use of an iterative eigen decomposition algorithm\nand makes use of the fact that a normalized covariance matrix (composed of\npearson correlation coefficients and ones) is particularly easy to handle.\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse\nimport matplotlib.transforms as transforms\n\n# %%\n#\n# The plotting function itself\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# This function plots the confidence ellipse of the covariance of the given\n# array-like variables x and y. The ellipse is plotted into the given\n# Axes object *ax*.\n#\n# The radiuses of the ellipse can be controlled by n_std which is the number\n# of standard deviations. The default value is 3 which makes the ellipse\n# enclose 98.9% of the points if the data is normally distributed\n# like in these examples (3 standard deviations in 1-D contain 99.7%\n# of the data, which is 98.9% of the data in 2-D).\n\n\ndef confidence_ellipse(x, y, ax, n_std=3.0, facecolor='none', **kwargs):\n    \"\"\"\n    Create a plot of the covariance confidence ellipse of *x* and *y*.\n\n    Parameters\n    ----------\n    x, y : array-like, shape (n, )\n        Input data.\n\n    ax : matplotlib.axes.Axes\n        The Axes object to draw the ellipse into.\n\n    n_std : float\n        The number of standard deviations to determine the ellipse's radiuses.\n\n    **kwargs\n        Forwarded to `~matplotlib.patches.Ellipse`\n\n    Returns\n    -------\n    matplotlib.patches.Ellipse\n    \"\"\"\n    if x.size != y.size:\n        raise ValueError(\"x and y must be the same size\")\n\n    cov = np.cov(x, y)\n    pearson = cov[0, 1]/np.sqrt(cov[0, 0] * cov[1, 1])\n    # Using a special case to obtain the eigenvalues of this\n    # two-dimensional dataset.\n    ell_radius_x = np.sqrt(1 + pearson)\n    ell_radius_y = np.sqrt(1 - pearson)\n    ellipse = Ellipse((0, 0), width=ell_radius_x * 2, height=ell_radius_y * 2,\n                      facecolor=facecolor, **kwargs)\n\n    # Calculating the standard deviation of x from\n    # the squareroot of the variance and multiplying\n    # with the given number of standard deviations.\n    scale_x = np.sqrt(cov[0, 0]) * n_std\n    mean_x = np.mean(x)\n\n    # calculating the standard deviation of y ...\n    scale_y = np.sqrt(cov[1, 1]) * n_std\n    mean_y = np.mean(y)\n\n    transf = transforms.Affine2D() \\\n        .rotate_deg(45) \\\n        .scale(scale_x, scale_y) \\\n        .translate(mean_x, mean_y)\n\n    ellipse.set_transform(transf + ax.transData)\n    return ax.add_patch(ellipse)\n\n\n# %%\n#\n# A helper function to create a correlated dataset\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# Creates a random two-dimensional dataset with the specified\n# two-dimensional mean (mu) and dimensions (scale).\n# The correlation can be controlled by the param 'dependency',\n# a 2x2 matrix.\n\ndef get_correlated_dataset(n, dependency, mu, scale):\n    latent = np.random.randn(n, 2)\n    dependent = latent.dot(dependency)\n    scaled = dependent * scale\n    scaled_with_offset = scaled + mu\n    # return x and y of the new, correlated dataset\n    return scaled_with_offset[:, 0], scaled_with_offset[:, 1]\n\n\n# %%\n#\n# Positive, negative and weak correlation\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# Note that the shape for the weak correlation (right) is an ellipse,\n# not a circle because x and y are differently scaled.\n# However, the fact that x and y are uncorrelated is shown by\n# the axes of the ellipse being aligned with the x- and y-axis\n# of the coordinate system.\n\nnp.random.seed(0)\n\nPARAMETERS = {\n    'Positive correlation': [[0.85, 0.35],\n                             [0.15, -0.65]],\n    'Negative correlation': [[0.9, -0.4],\n                             [0.1, -0.6]],\n    'Weak correlation': [[1, 0],\n                         [0, 1]],\n}\n\nmu = 2, 4\nscale = 3, 5\n\nfig, axs = plt.subplots(1, 3, figsize=(9, 3))\nfor ax, (title, dependency) in zip(axs, PARAMETERS.items()):\n    x, y = get_correlated_dataset(800, dependency, mu, scale)\n    ax.scatter(x, y, s=0.5)\n\n    ax.axvline(c='grey', lw=1)\n    ax.axhline(c='grey', lw=1)\n\n    confidence_ellipse(x, y, ax, edgecolor='red')\n\n    ax.scatter(mu[0], mu[1], c='red', s=3)\n    ax.set_title(title)\n\nplt.show()\n\n\n# %%\n#\n# Different number of standard deviations\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# A plot with n_std = 3 (blue), 2 (purple) and 1 (red)\n\nfig, ax_nstd = plt.subplots(figsize=(6, 6))\n\ndependency_nstd = [[0.8, 0.75],\n                   [-0.2, 0.35]]\nmu = 0, 0\nscale = 8, 5\n\nax_nstd.axvline(c='grey', lw=1)\nax_nstd.axhline(c='grey', lw=1)\n\nx, y = get_correlated_dataset(500, dependency_nstd, mu, scale)\nax_nstd.scatter(x, y, s=0.5)\n\nconfidence_ellipse(x, y, ax_nstd, n_std=1,\n                   label=r'$1\\sigma$', edgecolor='firebrick')\nconfidence_ellipse(x, y, ax_nstd, n_std=2,\n                   label=r'$2\\sigma$', edgecolor='fuchsia', linestyle='--')\nconfidence_ellipse(x, y, ax_nstd, n_std=3,\n                   label=r'$3\\sigma$', edgecolor='blue', linestyle=':')\n\nax_nstd.scatter(mu[0], mu[1], c='red', s=3)\nax_nstd.set_title('Different standard deviations')\nax_nstd.legend()\nplt.show()\n\n\n# %%\n#\n# Using the keyword arguments\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# Use the keyword arguments specified for `matplotlib.patches.Patch` in order\n# to have the ellipse rendered in different ways.\n\nfig, ax_kwargs = plt.subplots(figsize=(6, 6))\ndependency_kwargs = [[-0.8, 0.5],\n                     [-0.2, 0.5]]\nmu = 2, -3\nscale = 6, 5\n\nax_kwargs.axvline(c='grey', lw=1)\nax_kwargs.axhline(c='grey', lw=1)\n\nx, y = get_correlated_dataset(500, dependency_kwargs, mu, scale)\n# Plot the ellipse with zorder=0 in order to demonstrate\n# its transparency (caused by the use of alpha).\nconfidence_ellipse(x, y, ax_kwargs,\n                   alpha=0.5, facecolor='pink', edgecolor='purple', zorder=0)\n\nax_kwargs.scatter(x, y, s=0.5)\nax_kwargs.scatter(mu[0], mu[1], c='red', s=3)\nax_kwargs.set_title('Using keyword arguments')\n\nfig.subplots_adjust(hspace=0.25)\nplt.show()\n\n# %%\n#\n# .. tags::\n#\n#    plot-type: speciality\n#    plot-type: scatter\n#    component: ellipse\n#    component: patch\n#    domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.transforms.Affine2D`\n#    - `matplotlib.patches.Ellipse`\n"
    },
    {
      "filename": "customized_violin.py",
      "title": "Customized Violin",
      "code": "\"\"\"\n=========================\nViolin plot customization\n=========================\n\nThis example demonstrates how to fully customize violin plots. The first plot\nshows the default style by providing only the data. The second plot first\nlimits what Matplotlib draws with additional keyword arguments. Then a\nsimplified representation of a box plot is drawn on top. Lastly, the styles of\nthe artists of the violins are modified.\n\nFor more information on violin plots, the scikit-learn docs have a great\nsection: https://scikit-learn.org/stable/modules/density.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef adjacent_values(vals, q1, q3):\n    upper_adjacent_value = q3 + (q3 - q1) * 1.5\n    upper_adjacent_value = np.clip(upper_adjacent_value, q3, vals[-1])\n\n    lower_adjacent_value = q1 - (q3 - q1) * 1.5\n    lower_adjacent_value = np.clip(lower_adjacent_value, vals[0], q1)\n    return lower_adjacent_value, upper_adjacent_value\n\n\ndef set_axis_style(ax, labels):\n    ax.set_xticks(np.arange(1, len(labels) + 1), labels=labels)\n    ax.set_xlim(0.25, len(labels) + 0.75)\n    ax.set_xlabel('Sample name')\n\n\n# create test data\nnp.random.seed(19680801)\ndata = [sorted(np.random.normal(0, std, 100)) for std in range(1, 5)]\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4), sharey=True)\n\nax1.set_title('Default violin plot')\nax1.set_ylabel('Observed values')\nax1.violinplot(data)\n\nax2.set_title('Customized violin plot')\nparts = ax2.violinplot(\n        data, showmeans=False, showmedians=False,\n        showextrema=False)\n\nfor pc in parts['bodies']:\n    pc.set_facecolor('#D43F3A')\n    pc.set_edgecolor('black')\n    pc.set_alpha(1)\n\nquartile1, medians, quartile3 = np.percentile(data, [25, 50, 75], axis=1)\nwhiskers = np.array([\n    adjacent_values(sorted_array, q1, q3)\n    for sorted_array, q1, q3 in zip(data, quartile1, quartile3)])\nwhiskers_min, whiskers_max = whiskers[:, 0], whiskers[:, 1]\n\ninds = np.arange(1, len(medians) + 1)\nax2.scatter(inds, medians, marker='o', color='white', s=30, zorder=3)\nax2.vlines(inds, quartile1, quartile3, color='k', linestyle='-', lw=5)\nax2.vlines(inds, whiskers_min, whiskers_max, color='k', linestyle='-', lw=1)\n\n# set style for the axes\nlabels = ['A', 'B', 'C', 'D']\nfor ax in [ax1, ax2]:\n    set_axis_style(ax, labels)\n\nplt.subplots_adjust(bottom=0.15, wspace=0.05)\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: violin, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.violinplot` / `matplotlib.pyplot.violinplot`\n#    - `matplotlib.axes.Axes.vlines` / `matplotlib.pyplot.vlines`\n"
    },
    {
      "filename": "errorbar.py",
      "title": "Errorbar",
      "code": "\"\"\"\n=================\nErrorbar function\n=================\n\nThis exhibits the most basic use of the error bar method.\nIn this case, constant values are provided for the error\nin both the x- and y-directions.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.5)\ny = np.exp(-x)\n\nfig, ax = plt.subplots()\nax.errorbar(x, y, xerr=0.2, yerr=0.4)\nplt.show()\n\n# %%\n#\n#\n# .. tags:: plot-type: errorbar, domain: statistics,\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`\n"
    },
    {
      "filename": "errorbar_features.py",
      "title": "Errorbar Features",
      "code": "\"\"\"\n=======================================\nDifferent ways of specifying error bars\n=======================================\n\nErrors can be specified as a constant value (as shown in\n:doc:`/gallery/statistics/errorbar`). However, this example demonstrates\nhow they vary by specifying arrays of error values.\n\nIf the raw ``x`` and ``y`` data have length N, there are two options:\n\nArray of shape (N,):\n    Error varies for each point, but the error values are\n    symmetric (i.e. the lower and upper values are equal).\n\nArray of shape (2, N):\n    Error varies for each point, and the lower and upper limits\n    (in that order) are different (asymmetric case)\n\nIn addition, this example demonstrates how to use log\nscale with error bars.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.5)\ny = np.exp(-x)\n\n# example error bar values that vary with x-position\nerror = 0.1 + 0.2 * x\n\nfig, (ax0, ax1) = plt.subplots(nrows=2, sharex=True)\nax0.errorbar(x, y, yerr=error, fmt='-o')\nax0.set_title('variable, symmetric error')\n\n# error bar values w/ different -/+ errors that\n# also vary with the x-position\nlower_error = 0.4 * error\nupper_error = error\nasymmetric_error = [lower_error, upper_error]\n\nax1.errorbar(x, y, xerr=asymmetric_error, fmt='o')\nax1.set_title('variable, asymmetric error')\nax1.set_yscale('log')\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: errorbar, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`\n"
    },
    {
      "filename": "errorbar_limits.py",
      "title": "Errorbar Limits",
      "code": "\"\"\"\n==============================================\nIncluding upper and lower limits in error bars\n==============================================\n\nIn matplotlib, errors bars can have \"limits\". Applying limits to the\nerror bars essentially makes the error unidirectional. Because of that,\nupper and lower limits can be applied in both the y- and x-directions\nvia the ``uplims``, ``lolims``, ``xuplims``, and ``xlolims`` parameters,\nrespectively. These parameters can be scalar or boolean arrays.\n\nFor example, if ``xlolims`` is ``True``, the x-error bars will only\nextend from the data towards increasing values. If ``uplims`` is an\narray filled with ``False`` except for the 4th and 7th values, all of the\ny-error bars will be bidirectional, except the 4th and 7th bars, which\nwill extend from the data towards decreasing y-values.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0])\ny = np.exp(-x)\nxerr = 0.1\nyerr = 0.2\n\n# lower & upper limits of the error\nlolims = np.array([0, 0, 1, 0, 1, 0, 0, 0, 1, 0], dtype=bool)\nuplims = np.array([0, 1, 0, 0, 0, 1, 0, 0, 0, 1], dtype=bool)\nls = 'dotted'\n\nfig, ax = plt.subplots(figsize=(7, 4))\n\n# standard error bars\nax.errorbar(x, y, xerr=xerr, yerr=yerr, linestyle=ls)\n\n# including upper limits\nax.errorbar(x, y + 0.5, xerr=xerr, yerr=yerr, uplims=uplims,\n            linestyle=ls)\n\n# including lower limits\nax.errorbar(x, y + 1.0, xerr=xerr, yerr=yerr, lolims=lolims,\n            linestyle=ls)\n\n# including upper and lower limits\nax.errorbar(x, y + 1.5, xerr=xerr, yerr=yerr,\n            lolims=lolims, uplims=uplims,\n            marker='o', markersize=8,\n            linestyle=ls)\n\n# Plot a series with lower and upper limits in both x & y\n# constant x-error with varying y-error\nxerr = 0.2\nyerr = np.full_like(x, 0.2)\nyerr[[3, 6]] = 0.3\n\n# mock up some limits by modifying previous data\nxlolims = lolims\nxuplims = uplims\nlolims = np.zeros_like(x)\nuplims = np.zeros_like(x)\nlolims[[6]] = True  # only limited at this index\nuplims[[3]] = True  # only limited at this index\n\n# do the plotting\nax.errorbar(x, y + 2.1, xerr=xerr, yerr=yerr,\n            xlolims=xlolims, xuplims=xuplims,\n            uplims=uplims, lolims=lolims,\n            marker='o', markersize=8,\n            linestyle='none')\n\n# tidy up the figure\nax.set_xlim((0, 5.5))\nax.set_title('Errorbar upper and lower limits')\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: errorbar, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`\n"
    },
    {
      "filename": "errorbars_and_boxes.py",
      "title": "Errorbars And Boxes",
      "code": "\"\"\"\n==================================================\nCreate boxes from error bars using PatchCollection\n==================================================\n\nIn this example, we snazz up a pretty standard error bar plot by adding\na rectangle patch defined by the limits of the bars in both the x- and\ny- directions. To do this, we have to write our own custom function\ncalled ``make_error_boxes``. Close inspection of this function will\nreveal the preferred pattern in writing functions for matplotlib:\n\n1. an `~.axes.Axes` object is passed directly to the function\n2. the function operates on the ``Axes`` methods directly, not through\n   the ``pyplot`` interface\n3. plotting keyword arguments that could be abbreviated are spelled out for\n   better code readability in the future (for example we use *facecolor*\n   instead of *fc*)\n4. the artists returned by the ``Axes`` plotting methods are then\n   returned by the function so that, if desired, their styles\n   can be modified later outside of the function (they are not\n   modified in this example).\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Rectangle\n\n# Number of data points\nn = 5\n\n# Dummy data\nnp.random.seed(19680801)\nx = np.arange(0, n, 1)\ny = np.random.rand(n) * 5.\n\n# Dummy errors (above and below)\nxerr = np.random.rand(2, n) + 0.1\nyerr = np.random.rand(2, n) + 0.2\n\n\ndef make_error_boxes(ax, xdata, ydata, xerror, yerror, facecolor='r',\n                     edgecolor='none', alpha=0.5):\n\n    # Loop over data points; create box from errors at each point\n    errorboxes = [Rectangle((x - xe[0], y - ye[0]), xe.sum(), ye.sum())\n                  for x, y, xe, ye in zip(xdata, ydata, xerror.T, yerror.T)]\n\n    # Create patch collection with specified colour/alpha\n    pc = PatchCollection(errorboxes, facecolor=facecolor, alpha=alpha,\n                         edgecolor=edgecolor)\n\n    # Add collection to Axes\n    ax.add_collection(pc)\n\n    # Plot errorbars\n    artists = ax.errorbar(xdata, ydata, xerr=xerror, yerr=yerror,\n                          fmt='none', ecolor='k')\n\n    return artists\n\n\n# Create figure and Axes\nfig, ax = plt.subplots(1)\n\n# Call function to create error boxes\n_ = make_error_boxes(ax, x, y, xerr, yerr)\n\nplt.show()\n\n# %%\n#\n#\n# .. tags::\n#\n#    plot-type: errorbar\n#    component: rectangle\n#    component: patchcollection\n#    domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`\n#    - `matplotlib.axes.Axes.add_collection`\n#    - `matplotlib.collections.PatchCollection`\n"
    },
    {
      "filename": "hexbin_demo.py",
      "title": "Hexbin Demo",
      "code": "\"\"\"\n=====================\nHexagonal binned plot\n=====================\n\n`~.Axes.hexbin` is a 2D histogram plot, in which the bins are hexagons and\nthe color represents the number of data points within each bin.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nn = 100_000\nx = np.random.standard_normal(n)\ny = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n)\nxlim = x.min(), x.max()\nylim = y.min(), y.max()\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, sharey=True, figsize=(9, 4))\n\nhb = ax0.hexbin(x, y, gridsize=50, cmap='inferno')\nax0.set(xlim=xlim, ylim=ylim)\nax0.set_title(\"Hexagon binning\")\ncb = fig.colorbar(hb, ax=ax0, label='counts')\n\nhb = ax1.hexbin(x, y, gridsize=50, bins='log', cmap='inferno')\nax1.set(xlim=xlim, ylim=ylim)\nax1.set_title(\"With a log color scale\")\ncb = fig.colorbar(hb, ax=ax1, label='counts')\n\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: histogram, plot-type: hexbin, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hexbin` / `matplotlib.pyplot.hexbin`\n"
    },
    {
      "filename": "hist.py",
      "title": "Hist",
      "code": "\"\"\"\n==========\nHistograms\n==========\n\nHow to plot histograms with Matplotlib.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors\nfrom matplotlib.ticker import PercentFormatter\n\n# Create a random number generator with a fixed seed for reproducibility\nrng = np.random.default_rng(19680801)\n\n# %%\n# Generate data and plot a simple histogram\n# -----------------------------------------\n#\n# To generate a 1D histogram we only need a single vector of numbers. For a 2D\n# histogram we'll need a second vector. We'll generate both below, and show\n# the histogram for each vector.\n\nN_points = 100000\nn_bins = 20\n\n# Generate two normal distributions\ndist1 = rng.standard_normal(N_points)\ndist2 = 0.4 * rng.standard_normal(N_points) + 5\n\nfig, axs = plt.subplots(1, 2, sharey=True, tight_layout=True)\n\n# We can set the number of bins with the *bins* keyword argument.\naxs[0].hist(dist1, bins=n_bins)\naxs[1].hist(dist2, bins=n_bins)\n\nplt.show()\n\n\n# %%\n# Updating histogram colors\n# -------------------------\n#\n# The histogram method returns (among other things) a ``patches`` object. This\n# gives us access to the properties of the objects drawn. Using this, we can\n# edit the histogram to our liking. Let's change the color of each bar\n# based on its y value.\n\nfig, axs = plt.subplots(1, 2, tight_layout=True)\n\n# N is the count in each bin, bins is the lower-limit of the bin\nN, bins, patches = axs[0].hist(dist1, bins=n_bins)\n\n# We'll color code by height, but you could use any scalar\nfracs = N / N.max()\n\n# we need to normalize the data to 0..1 for the full range of the colormap\nnorm = colors.Normalize(fracs.min(), fracs.max())\n\n# Now, we'll loop through our objects and set the color of each accordingly\nfor thisfrac, thispatch in zip(fracs, patches):\n    color = plt.cm.viridis(norm(thisfrac))\n    thispatch.set_facecolor(color)\n\n# We can also normalize our inputs by the total number of counts\naxs[1].hist(dist1, bins=n_bins, density=True)\n\n# Now we format the y-axis to display percentage\naxs[1].yaxis.set_major_formatter(PercentFormatter(xmax=1))\n\n\n# %%\n# Plot a 2D histogram\n# -------------------\n#\n# To plot a 2D histogram, one only needs two vectors of the same length,\n# corresponding to each axis of the histogram.\n\nfig, ax = plt.subplots(tight_layout=True)\nhist = ax.hist2d(dist1, dist2)\n\n\n# %%\n# Customizing your histogram\n# --------------------------\n#\n# Customizing a 2D histogram is similar to the 1D case, you can control\n# visual components such as the bin size or color normalization.\n\nfig, axs = plt.subplots(3, 1, figsize=(5, 15), sharex=True, sharey=True,\n                        tight_layout=True)\n\n# We can increase the number of bins on each axis\naxs[0].hist2d(dist1, dist2, bins=40)\n\n# As well as define normalization of the colors\naxs[1].hist2d(dist1, dist2, bins=40, norm=colors.LogNorm())\n\n# We can also define custom numbers of bins for each axis\naxs[2].hist2d(dist1, dist2, bins=(80, 10), norm=colors.LogNorm())\n\n# %%\n#\n# .. tags::\n#\n#    plot-type: histogram,\n#    plot-type: histogram2d\n#    domain: statistics\n#    styling: color,\n#    component: normalization\n#    component: patch\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hist` / `matplotlib.pyplot.hist`\n#    - `matplotlib.pyplot.hist2d`\n#    - `matplotlib.ticker.PercentFormatter`\n"
    },
    {
      "filename": "histogram_bihistogram.py",
      "title": "Histogram Bihistogram",
      "code": "\"\"\"\n===========\nBihistogram\n===========\n\nHow to plot a bihistogram with Matplotlib.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create a random number generator with a fixed seed for reproducibility\nrng = np.random.default_rng(19680801)\n\n# %%\n# Generate data and plot a bihistogram\n# ------------------------------------\n#\n# To generate a bihistogram we need two datasets (each being a vector of numbers).\n# We will plot both histograms using plt.hist() and set the weights of the second\n# one to be negative. We'll generate data below and plot the bihistogram.\n\nN_points = 10_000\n\n# Generate two normal distributions\ndataset1 = np.random.normal(0, 1, size=N_points)\ndataset2 = np.random.normal(1, 2, size=N_points)\n\n# Use a constant bin width to make the two histograms easier to compare visually\nbin_width = 0.25\nbins = np.arange(np.min([dataset1, dataset2]),\n                    np.max([dataset1, dataset2]) + bin_width, bin_width)\n\nfig, ax = plt.subplots()\n\n# Plot the first histogram\nax.hist(dataset1, bins=bins, label=\"Dataset 1\")\n\n# Plot the second histogram\n# (notice the negative weights, which flip the histogram upside down)\nax.hist(dataset2, weights=-np.ones_like(dataset2), bins=bins, label=\"Dataset 2\")\nax.axhline(0, color=\"k\")\nax.legend()\n\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: histogram, domain: statistics, purpose: showcase\n"
    },
    {
      "filename": "histogram_cumulative.py",
      "title": "Histogram Cumulative",
      "code": "\"\"\"\n========================\nCumulative distributions\n========================\n\nThis example shows how to plot the empirical cumulative distribution function\n(ECDF) of a sample. We also show the theoretical CDF.\n\nIn engineering, ECDFs are sometimes called \"non-exceedance\" curves: the y-value\nfor a given x-value gives probability that an observation from the sample is\nbelow that x-value. For example, the value of 220 on the x-axis corresponds to\nabout 0.80 on the y-axis, so there is an 80% chance that an observation in the\nsample does not exceed 220. Conversely, the empirical *complementary*\ncumulative distribution function (the ECCDF, or \"exceedance\" curve) shows the\nprobability y that an observation from the sample is above a value x.\n\nA direct method to plot ECDFs is `.Axes.ecdf`.  Passing ``complementary=True``\nresults in an ECCDF instead.\n\nAlternatively, one can use ``ax.hist(data, density=True, cumulative=True)`` to\nfirst bin the data, as if plotting a histogram, and then compute and plot the\ncumulative sums of the frequencies of entries in each bin.  Here, to plot the\nECCDF, pass ``cumulative=-1``.  Note that this approach results in an\napproximation of the E(C)CDF, whereas `.Axes.ecdf` is exact.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nmu = 200\nsigma = 25\nn_bins = 25\ndata = np.random.normal(mu, sigma, size=100)\n\nfig = plt.figure(figsize=(9, 4), layout=\"constrained\")\naxs = fig.subplots(1, 2, sharex=True, sharey=True)\n\n# Cumulative distributions.\naxs[0].ecdf(data, label=\"CDF\")\nn, bins, patches = axs[0].hist(data, n_bins, density=True, histtype=\"step\",\n                               cumulative=True, label=\"Cumulative histogram\")\nx = np.linspace(data.min(), data.max())\ny = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (x - mu))**2))\ny = y.cumsum()\ny /= y[-1]\naxs[0].plot(x, y, \"k--\", linewidth=1.5, label=\"Theory\")\n\n# Complementary cumulative distributions.\naxs[1].ecdf(data, complementary=True, label=\"CCDF\")\naxs[1].hist(data, bins=bins, density=True, histtype=\"step\", cumulative=-1,\n            label=\"Reversed cumulative histogram\")\naxs[1].plot(x, 1 - y, \"k--\", linewidth=1.5, label=\"Theory\")\n\n# Label the figure.\nfig.suptitle(\"Cumulative distributions\")\nfor ax in axs:\n    ax.grid(True)\n    ax.legend()\n    ax.set_xlabel(\"Annual rainfall (mm)\")\n    ax.set_ylabel(\"Probability of occurrence\")\n    ax.label_outer()\n\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: ecdf, plot-type: histogram, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hist` / `matplotlib.pyplot.hist`\n#    - `matplotlib.axes.Axes.ecdf` / `matplotlib.pyplot.ecdf`\n"
    },
    {
      "filename": "histogram_histtypes.py",
      "title": "Histogram Histtypes",
      "code": "\"\"\"\n================================================================\nDemo of the histogram function's different ``histtype`` settings\n================================================================\n\n* Histogram with step curve that has a color fill.\n* Histogram with step curve with no fill.\n* Histogram with custom and unequal bin widths.\n* Two histograms with stacked bars.\n\nSelecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nmu_x = 200\nsigma_x = 25\nx = np.random.normal(mu_x, sigma_x, size=100)\n\nmu_w = 200\nsigma_w = 10\nw = np.random.normal(mu_w, sigma_w, size=100)\n\nfig, axs = plt.subplots(nrows=2, ncols=2)\n\naxs[0, 0].hist(x, 20, density=True, histtype='stepfilled', facecolor='g',\n               alpha=0.75)\naxs[0, 0].set_title('stepfilled')\n\naxs[0, 1].hist(x, 20, density=True, histtype='step', facecolor='g',\n               alpha=0.75)\naxs[0, 1].set_title('step')\n\naxs[1, 0].hist(x, density=True, histtype='barstacked', rwidth=0.8)\naxs[1, 0].hist(w, density=True, histtype='barstacked', rwidth=0.8)\naxs[1, 0].set_title('barstacked')\n\n# Create a histogram by providing the bin edges (unequally spaced).\nbins = [100, 150, 180, 195, 205, 220, 250, 300]\naxs[1, 1].hist(x, bins, density=True, histtype='bar', rwidth=0.8)\naxs[1, 1].set_title('bar, unequal bins')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: histogram, domain: statistics, purpose: reference\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hist` / `matplotlib.pyplot.hist`\n"
    },
    {
      "filename": "histogram_multihist.py",
      "title": "Histogram Multihist",
      "code": "\"\"\"\n=====================================================\nThe histogram (hist) function with multiple data sets\n=====================================================\n\nPlot histogram with multiple sample sets and demonstrate:\n\n* Use of legend with multiple sample sets\n* Stacked bars\n* Step curve with no fill\n* Data sets of different sample sizes\n\nSelecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html\n\n.. redirect-from:: /gallery/lines_bars_and_markers/filled_step\n\n\"\"\"\n# %%\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nn_bins = 10\nx = np.random.randn(1000, 3)\n\nfig, ((ax0, ax1), (ax2, ax3)) = plt.subplots(nrows=2, ncols=2)\n\ncolors = ['red', 'tan', 'lime']\nax0.hist(x, n_bins, density=True, histtype='bar', color=colors, label=colors)\nax0.legend(prop={'size': 10})\nax0.set_title('bars with legend')\n\nax1.hist(x, n_bins, density=True, histtype='bar', stacked=True)\nax1.set_title('stacked bar')\n\nax2.hist(x, n_bins, histtype='step', stacked=True, fill=False)\nax2.set_title('stack step (unfilled)')\n\n# Make a multiple-histogram of data-sets with different length.\nx_multi = [np.random.randn(n) for n in [10000, 5000, 2000]]\nax3.hist(x_multi, n_bins, histtype='bar')\nax3.set_title('different sample sizes')\n\nfig.tight_layout()\nplt.show()\n\n# %%\n# -----------------------------------\n# Setting properties for each dataset\n# -----------------------------------\n#\n# You can style the histograms individually by passing a list of values to the\n# following parameters:\n#\n# * edgecolor\n# * facecolor\n# * hatch\n# * linewidth\n# * linestyle\n#\n#\n# edgecolor\n# .........\n\nfig, ax = plt.subplots()\n\nedgecolors = ['green', 'red', 'blue']\n\nax.hist(x, n_bins, fill=False, histtype=\"step\", stacked=True,\n        edgecolor=edgecolors, label=edgecolors)\nax.legend()\nax.set_title('Stacked Steps with Edgecolors')\n\nplt.show()\n\n# %%\n# facecolor\n# .........\n\nfig, ax = plt.subplots()\n\nfacecolors = ['green', 'red', 'blue']\n\nax.hist(x, n_bins, histtype=\"barstacked\", facecolor=facecolors, label=facecolors)\nax.legend()\nax.set_title(\"Bars with different Facecolors\")\n\nplt.show()\n\n# %%\n# hatch\n# .....\n\nfig, ax = plt.subplots()\n\nhatches = [\".\", \"o\", \"x\"]\n\nax.hist(x, n_bins, histtype=\"barstacked\", hatch=hatches, label=hatches)\nax.legend()\nax.set_title(\"Hatches on Stacked Bars\")\n\nplt.show()\n\n# %%\n# linewidth\n# .........\n\nfig, ax = plt.subplots()\n\nlinewidths = [1, 2, 3]\nedgecolors = [\"green\", \"red\", \"blue\"]\n\nax.hist(x, n_bins, fill=False, histtype=\"bar\", linewidth=linewidths,\n        edgecolor=edgecolors, label=linewidths)\nax.legend()\nax.set_title(\"Bars with Linewidths\")\n\nplt.show()\n\n# %%\n# linestyle\n# .........\n\nfig, ax = plt.subplots()\n\nlinestyles = ['-', ':', '--']\n\nax.hist(x, n_bins, fill=False, histtype='bar', linestyle=linestyles,\n        edgecolor=edgecolors, label=linestyles)\nax.legend()\nax.set_title('Bars with Linestyles')\n\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: histogram, domain: statistics, purpose: reference\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hist` / `matplotlib.pyplot.hist`\n"
    },
    {
      "filename": "histogram_normalization.py",
      "title": "Histogram Normalization",
      "code": "\"\"\"\n.. redirect-from:: /gallery/statistics/histogram_features\n\n===================================\nHistogram bins, density, and weight\n===================================\n\nThe `.Axes.hist` method can flexibly create histograms in a few different ways,\nwhich is flexible and helpful, but can also lead to confusion.  In particular,\nyou can:\n\n- bin the data as you want, either with an automatically chosen number of\n  bins, or with fixed bin edges,\n- normalize the histogram so that its integral is one,\n- and assign weights to the data points, so that each data point affects the\n  count in its bin differently.\n\nThe Matplotlib ``hist`` method calls `numpy.histogram` and plots the results,\ntherefore users should consult the numpy documentation for a definitive guide.\n\nHistograms are created by defining bin edges, and taking a dataset of values\nand sorting them into the bins, and counting or summing how much data is in\neach bin.  In this simple example, 9 numbers between 1 and 4 are sorted into 3\nbins:\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nrng = np.random.default_rng(19680801)\n\nxdata = np.array([1.2, 2.3, 3.3, 3.1, 1.7, 3.4, 2.1, 1.25, 1.3])\nxbins = np.array([1, 2, 3, 4])\n\n# changing the style of the histogram bars just to make it\n# very clear where the boundaries of the bins are:\nstyle = {'facecolor': 'none', 'edgecolor': 'C0', 'linewidth': 3}\n\nfig, ax = plt.subplots()\nax.hist(xdata, bins=xbins, **style)\n\n# plot the xdata locations on the x axis:\nax.plot(xdata, 0*xdata, 'd')\nax.set_ylabel('Number per bin')\nax.set_xlabel('x bins (dx=1.0)')\n\n# %%\n# Modifying bins\n# ==============\n#\n# Changing the bin size changes the shape of this sparse histogram, so its a\n# good idea to choose bins with some care with respect to your data.  Here we\n# make the bins half as wide.\n\nxbins = np.arange(1, 4.5, 0.5)\n\nfig, ax = plt.subplots()\nax.hist(xdata, bins=xbins, **style)\nax.plot(xdata, 0*xdata, 'd')\nax.set_ylabel('Number per bin')\nax.set_xlabel('x bins (dx=0.5)')\n\n# %%\n# We can also let numpy (via Matplotlib) choose the bins automatically, or\n# specify a number of bins to choose automatically:\n\nfig, ax = plt.subplot_mosaic([['auto', 'n4']],\n                             sharex=True, sharey=True, layout='constrained')\n\nax['auto'].hist(xdata, **style)\nax['auto'].plot(xdata, 0*xdata, 'd')\nax['auto'].set_ylabel('Number per bin')\nax['auto'].set_xlabel('x bins (auto)')\n\nax['n4'].hist(xdata, bins=4, **style)\nax['n4'].plot(xdata, 0*xdata, 'd')\nax['n4'].set_xlabel('x bins (\"bins=4\")')\n\n# %%\n# Normalizing histograms: density and weight\n# ==========================================\n#\n# Counts-per-bin is the default length of each bar in the histogram.  However,\n# we can also normalize the bar lengths as a probability density function using\n# the ``density`` parameter:\n\nfig, ax = plt.subplots()\nax.hist(xdata, bins=xbins, density=True, **style)\nax.set_ylabel('Probability density [$V^{-1}$])')\nax.set_xlabel('x bins (dx=0.5 $V$)')\n\n# %%\n# This normalization can be a little hard to interpret when just exploring the\n# data. The value attached to each bar is divided by the total number of data\n# points *and* the width of the bin, and thus the values _integrate_ to one\n# when integrating across the full range of data.\n# e.g. ::\n#\n#     density = counts / (sum(counts) * np.diff(bins))\n#     np.sum(density * np.diff(bins)) == 1\n#\n# This normalization is how `probability density functions\n# <https://en.wikipedia.org/wiki/Probability_density_function>`_ are defined in\n# statistics.  If :math:`X` is a random variable on :math:`x`, then :math:`f_X`\n# is is the probability density function if :math:`P[a<X<b] = \\int_a^b f_X dx`.\n# If the units of x are Volts, then the units of :math:`f_X` are :math:`V^{-1}`\n# or probability per change in voltage.\n#\n# The usefulness of this normalization is a little more clear when we draw from\n# a known distribution and try to compare with theory.  So, choose 1000 points\n# from a `normal distribution\n# <https://en.wikipedia.org/wiki/Normal_distribution>`_, and also calculate the\n# known probability density function:\n\nxdata = rng.normal(size=1000)\nxpdf = np.arange(-4, 4, 0.1)\npdf = 1 / (np.sqrt(2 * np.pi)) * np.exp(-xpdf**2 / 2)\n\n# %%\n# If we don't use ``density=True``, we need to scale the expected probability\n# distribution function by both the length of the data and the width of the\n# bins:\n\nfig, ax = plt.subplot_mosaic([['False', 'True']], layout='constrained')\ndx = 0.1\nxbins = np.arange(-4, 4, dx)\nax['False'].hist(xdata, bins=xbins, density=False, histtype='step', label='Counts')\n\n# scale and plot the expected pdf:\nax['False'].plot(xpdf, pdf * len(xdata) * dx, label=r'$N\\,f_X(x)\\,\\delta x$')\nax['False'].set_ylabel('Count per bin')\nax['False'].set_xlabel('x bins [V]')\nax['False'].legend()\n\nax['True'].hist(xdata, bins=xbins, density=True, histtype='step', label='density')\nax['True'].plot(xpdf, pdf, label='$f_X(x)$')\nax['True'].set_ylabel('Probability density [$V^{-1}$]')\nax['True'].set_xlabel('x bins [$V$]')\nax['True'].legend()\n\n# %%\n# One advantage of using the density is therefore that the shape and amplitude\n# of the histogram does not depend on the size of the bins.  Consider an\n# extreme case where the bins do not have the same width.  In this example, the\n# bins below ``x=-1.25`` are six times wider than the rest of the bins.   By\n# normalizing by density, we preserve the shape of the distribution, whereas if\n# we do not, then the wider bins have much higher counts than the thinner bins:\n\nfig, ax = plt.subplot_mosaic([['False', 'True']], layout='constrained')\ndx = 0.1\nxbins = np.hstack([np.arange(-4, -1.25, 6*dx), np.arange(-1.25, 4, dx)])\nax['False'].hist(xdata, bins=xbins, density=False, histtype='step', label='Counts')\nax['False'].plot(xpdf, pdf * len(xdata) * dx, label=r'$N\\,f_X(x)\\,\\delta x_0$')\nax['False'].set_ylabel('Count per bin')\nax['False'].set_xlabel('x bins [V]')\nax['False'].legend()\n\nax['True'].hist(xdata, bins=xbins, density=True, histtype='step', label='density')\nax['True'].plot(xpdf, pdf, label='$f_X(x)$')\nax['True'].set_ylabel('Probability density [$V^{-1}$]')\nax['True'].set_xlabel('x bins [$V$]')\nax['True'].legend()\n\n# %%\n# Similarly, if we want to compare histograms with different bin widths, we may\n# want to use ``density=True``:\n\nfig, ax = plt.subplot_mosaic([['False', 'True']], layout='constrained')\n\n# expected PDF\nax['True'].plot(xpdf, pdf, '--', label='$f_X(x)$', color='k')\n\nfor nn, dx in enumerate([0.1, 0.4, 1.2]):\n    xbins = np.arange(-4, 4, dx)\n    # expected histogram:\n    ax['False'].plot(xpdf, pdf*1000*dx, '--', color=f'C{nn}')\n    ax['False'].hist(xdata, bins=xbins, density=False, histtype='step')\n\n    ax['True'].hist(xdata, bins=xbins, density=True, histtype='step', label=dx)\n\n# Labels:\nax['False'].set_xlabel('x bins [$V$]')\nax['False'].set_ylabel('Count per bin')\nax['True'].set_ylabel('Probability density [$V^{-1}$]')\nax['True'].set_xlabel('x bins [$V$]')\nax['True'].legend(fontsize='small', title='bin width:')\n\n# %%\n# Sometimes people want to normalize so that the sum of counts is one.  This is\n# analogous to a `probability mass function\n# <https://en.wikipedia.org/wiki/Probability_mass_function>`_ for a discrete\n# variable where the sum of probabilities for all the values equals one.  Using\n# ``hist``, we can get this normalization if we set the *weights* to 1/N.\n# Note that the amplitude of this normalized histogram still depends on\n# width and/or number of the bins:\n\nfig, ax = plt.subplots(layout='constrained', figsize=(3.5, 3))\n\nfor nn, dx in enumerate([0.1, 0.4, 1.2]):\n    xbins = np.arange(-4, 4, dx)\n    ax.hist(xdata, bins=xbins, weights=1/len(xdata) * np.ones(len(xdata)),\n                   histtype='step', label=f'{dx}')\nax.set_xlabel('x bins [$V$]')\nax.set_ylabel('Bin count / N')\nax.legend(fontsize='small', title='bin width:')\n\n# %%\n# The value of normalizing histograms is comparing two distributions that have\n# different sized populations.  Here we compare the distribution of ``xdata``\n# with a population of 1000, and ``xdata2`` with 100 members.\n\nxdata2 = rng.normal(size=100)\n\nfig, ax = plt.subplot_mosaic([['no_norm', 'density', 'weight']],\n                             layout='constrained', figsize=(8, 4))\n\nxbins = np.arange(-4, 4, 0.25)\n\nax['no_norm'].hist(xdata, bins=xbins, histtype='step')\nax['no_norm'].hist(xdata2, bins=xbins, histtype='step')\nax['no_norm'].set_ylabel('Counts')\nax['no_norm'].set_xlabel('x bins [$V$]')\nax['no_norm'].set_title('No normalization')\n\nax['density'].hist(xdata, bins=xbins, histtype='step', density=True)\nax['density'].hist(xdata2, bins=xbins, histtype='step', density=True)\nax['density'].set_ylabel('Probability density [$V^{-1}$]')\nax['density'].set_title('Density=True')\nax['density'].set_xlabel('x bins [$V$]')\n\nax['weight'].hist(xdata, bins=xbins, histtype='step',\n                  weights=1 / len(xdata) * np.ones(len(xdata)),\n                  label='N=1000')\nax['weight'].hist(xdata2, bins=xbins, histtype='step',\n                  weights=1 / len(xdata2) * np.ones(len(xdata2)),\n                  label='N=100')\nax['weight'].set_xlabel('x bins [$V$]')\nax['weight'].set_ylabel('Counts / N')\nax['weight'].legend(fontsize='small')\nax['weight'].set_title('Weight = 1/N')\n\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: histogram, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.hist` / `matplotlib.pyplot.hist`\n#    - `matplotlib.axes.Axes.set_title`\n#    - `matplotlib.axes.Axes.set_xlabel`\n#    - `matplotlib.axes.Axes.set_ylabel`\n#    - `matplotlib.axes.Axes.legend`\n"
    },
    {
      "filename": "multiple_histograms_side_by_side.py",
      "title": "Multiple Histograms Side By Side",
      "code": "\"\"\"\n================================\nMultiple histograms side by side\n================================\n\nThis example plots horizontal histograms of different samples along\na categorical x-axis. Additionally, the histograms are plotted to\nbe symmetrical about their x-position, thus making them very similar\nto violin plots.\n\nTo make this highly specialized plot, we can't use the standard ``hist``\nmethod. Instead, we use ``barh`` to draw the horizontal bars directly. The\nvertical positions and lengths of the bars are computed via the\n``np.histogram`` function. The histograms for all the samples are\ncomputed using the same range (min and max values) and number of bins,\nso that the bins for each sample are in the same vertical positions.\n\nSelecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\nnumber_of_bins = 20\n\n# An example of three data sets to compare\nnumber_of_data_points = 387\nlabels = [\"A\", \"B\", \"C\"]\ndata_sets = [np.random.normal(0, 1, number_of_data_points),\n             np.random.normal(6, 1, number_of_data_points),\n             np.random.normal(-3, 1, number_of_data_points)]\n\n# Computed quantities to aid plotting\nhist_range = (np.min(data_sets), np.max(data_sets))\nbinned_data_sets = [\n    np.histogram(d, range=hist_range, bins=number_of_bins)[0]\n    for d in data_sets\n]\nbinned_maximums = np.max(binned_data_sets, axis=1)\nx_locations = np.arange(0, sum(binned_maximums), np.max(binned_maximums))\n\n# The bin_edges are the same for all of the histograms\nbin_edges = np.linspace(hist_range[0], hist_range[1], number_of_bins + 1)\nheights = np.diff(bin_edges)\ncenters = bin_edges[:-1] + heights / 2\n\n# Cycle through and plot each histogram\nfig, ax = plt.subplots()\nfor x_loc, binned_data in zip(x_locations, binned_data_sets):\n    lefts = x_loc - 0.5 * binned_data\n    ax.barh(centers, binned_data, height=heights, left=lefts)\n\nax.set_xticks(x_locations, labels)\n\nax.set_ylabel(\"Data values\")\nax.set_xlabel(\"Data sets\")\n\nplt.show()\n\n# %%\n#\n# .. tags::\n#\n#    domain: statistics\n#    plot-type: barh\n#    plot-type: histogram\n#    styling: position\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.barh` / `matplotlib.pyplot.barh`\n"
    },
    {
      "filename": "time_series_histogram.py",
      "title": "Time Series Histogram",
      "code": "\"\"\"\n=====================\nTime Series Histogram\n=====================\n\nThis example demonstrates how to efficiently visualize large numbers of time\nseries in a way that could potentially reveal hidden substructure and patterns\nthat are not immediately obvious, and display them in a visually appealing way.\n\nIn this example, we generate multiple sinusoidal \"signal\" series that are\nburied under a larger number of random walk \"noise/background\" series. For an\nunbiased Gaussian random walk with standard deviation of \u03c3, the RMS deviation\nfrom the origin after n steps is \u03c3*sqrt(n). So in order to keep the sinusoids\nvisible on the same scale as the random walks, we scale the amplitude by the\nrandom walk RMS. In addition, we also introduce a small random offset ``phi``\nto shift the sines left/right, and some additive random noise to shift\nindividual data points up/down to make the signal a bit more \"realistic\" (you\nwouldn't expect a perfect sine wave to appear in your data).\n\nThe first plot shows the typical way of visualizing multiple time series by\noverlaying them on top of each other with ``plt.plot`` and a small value of\n``alpha``. The second and third plots show how to reinterpret the data as a 2d\nhistogram, with optional interpolation between data points, by using\n``np.histogram2d`` and ``plt.pcolormesh``.\n\"\"\"\n\nimport time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axes = plt.subplots(nrows=3, figsize=(6, 8), layout='constrained')\n\n# Fix random state for reproducibility\nnp.random.seed(19680801)\n# Make some data; a 1D random walk + small fraction of sine waves\nnum_series = 1000\nnum_points = 100\nSNR = 0.10  # Signal to Noise Ratio\nx = np.linspace(0, 4 * np.pi, num_points)\n# Generate unbiased Gaussian random walks\nY = np.cumsum(np.random.randn(num_series, num_points), axis=-1)\n# Generate sinusoidal signals\nnum_signal = round(SNR * num_series)\nphi = (np.pi / 8) * np.random.randn(num_signal, 1)  # small random offset\nY[-num_signal:] = (\n    np.sqrt(np.arange(num_points))  # random walk RMS scaling factor\n    * (np.sin(x - phi)\n       + 0.05 * np.random.randn(num_signal, num_points))  # small random noise\n)\n\n\n# Plot series using `plot` and a small value of `alpha`. With this view it is\n# very difficult to observe the sinusoidal behavior because of how many\n# overlapping series there are. It also takes a bit of time to run because so\n# many individual artists need to be generated.\ntic = time.time()\naxes[0].plot(x, Y.T, color=\"C0\", alpha=0.1)\ntoc = time.time()\naxes[0].set_title(\"Line plot with alpha\")\nprint(f\"{toc-tic:.3f} sec. elapsed\")\n\n\n# Now we will convert the multiple time series into a histogram. Not only will\n# the hidden signal be more visible, but it is also a much quicker procedure.\ntic = time.time()\n# Linearly interpolate between the points in each time series\nnum_fine = 800\nx_fine = np.linspace(x.min(), x.max(), num_fine)\ny_fine = np.concatenate([np.interp(x_fine, x, y_row) for y_row in Y])\nx_fine = np.broadcast_to(x_fine, (num_series, num_fine)).ravel()\n\n\n# Plot (x, y) points in 2d histogram with log colorscale\n# It is pretty evident that there is some kind of structure under the noise\n# You can tune vmax to make signal more visible\ncmap = plt.colormaps[\"plasma\"]\ncmap = cmap.with_extremes(bad=cmap(0))\nh, xedges, yedges = np.histogram2d(x_fine, y_fine, bins=[400, 100])\npcm = axes[1].pcolormesh(xedges, yedges, h.T, cmap=cmap,\n                         norm=\"log\", vmax=1.5e2, rasterized=True)\nfig.colorbar(pcm, ax=axes[1], label=\"# points\", pad=0)\naxes[1].set_title(\"2d histogram and log color scale\")\n\n# Same data but on linear color scale\npcm = axes[2].pcolormesh(xedges, yedges, h.T, cmap=cmap,\n                         vmax=1.5e2, rasterized=True)\nfig.colorbar(pcm, ax=axes[2], label=\"# points\", pad=0)\naxes[2].set_title(\"2d histogram and linear color scale\")\n\ntoc = time.time()\nprint(f\"{toc-tic:.3f} sec. elapsed\")\nplt.show()\n\n# %%\n#\n# .. tags::\n#\n#    plot-type: histogram2d\n#    plot-type: pcolormesh\n#    purpose: storytelling\n#    styling: color\n#    component: colormap\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.pcolormesh` / `matplotlib.pyplot.pcolormesh`\n#    - `matplotlib.figure.Figure.colorbar`\n"
    },
    {
      "filename": "violinplot.py",
      "title": "Violinplot",
      "code": "\"\"\"\n==================\nViolin plot basics\n==================\n\nViolin plots are similar to histograms and box plots in that they show\nan abstract representation of the probability distribution of the\nsample. Rather than showing counts of data points that fall into bins\nor order statistics, violin plots use kernel density estimation (KDE) to\ncompute an empirical distribution of the sample. That computation\nis controlled by several parameters. This example demonstrates how to\nmodify the number of points at which the KDE is evaluated (``points``)\nand how to modify the bandwidth of the KDE (``bw_method``).\n\nFor more information on violin plots and KDE, the scikit-learn docs\nhave a great section: https://scikit-learn.org/stable/modules/density.html\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# fake data\nfs = 10  # fontsize\npos = [1, 2, 4, 5, 7, 8]\ndata = [np.random.normal(0, std, size=100) for std in pos]\n\nfig, axs = plt.subplots(nrows=2, ncols=6, figsize=(10, 4))\n\naxs[0, 0].violinplot(data, pos, points=20, widths=0.3,\n                     showmeans=True, showextrema=True, showmedians=True)\naxs[0, 0].set_title('Custom violin 1', fontsize=fs)\n\naxs[0, 1].violinplot(data, pos, points=40, widths=0.5,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method='silverman')\naxs[0, 1].set_title('Custom violin 2', fontsize=fs)\n\naxs[0, 2].violinplot(data, pos, points=60, widths=0.7, showmeans=True,\n                     showextrema=True, showmedians=True, bw_method=0.5)\naxs[0, 2].set_title('Custom violin 3', fontsize=fs)\n\naxs[0, 3].violinplot(data, pos, points=60, widths=0.7, showmeans=True,\n                     showextrema=True, showmedians=True, bw_method=0.5,\n                     quantiles=[[0.1], [], [], [0.175, 0.954], [0.75], [0.25]])\naxs[0, 3].set_title('Custom violin 4', fontsize=fs)\n\naxs[0, 4].violinplot(data[-1:], pos[-1:], points=60, widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5)\naxs[0, 4].set_title('Custom violin 5', fontsize=fs)\n\naxs[0, 5].violinplot(data[-1:], pos[-1:], points=60, widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5, side='low')\n\naxs[0, 5].violinplot(data[-1:], pos[-1:], points=60, widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5, side='high')\naxs[0, 5].set_title('Custom violin 6', fontsize=fs)\n\naxs[1, 0].violinplot(data, pos, points=80, orientation='horizontal', widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True)\naxs[1, 0].set_title('Custom violin 7', fontsize=fs)\n\naxs[1, 1].violinplot(data, pos, points=100, orientation='horizontal', widths=0.9,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method='silverman')\naxs[1, 1].set_title('Custom violin 8', fontsize=fs)\n\naxs[1, 2].violinplot(data, pos, points=200, orientation='horizontal', widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method=0.5)\naxs[1, 2].set_title('Custom violin 9', fontsize=fs)\n\naxs[1, 3].violinplot(data, pos, points=200, orientation='horizontal', widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[[0.1], [], [], [0.175, 0.954], [0.75], [0.25]],\n                     bw_method=0.5)\naxs[1, 3].set_title('Custom violin 10', fontsize=fs)\n\naxs[1, 4].violinplot(data[-1:], pos[-1:], points=200, orientation='horizontal',\n                     widths=1.1, showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5)\naxs[1, 4].set_title('Custom violin 11', fontsize=fs)\n\naxs[1, 5].violinplot(data[-1:], pos[-1:], points=200, orientation='horizontal',\n                     widths=1.1, showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5, side='low')\n\naxs[1, 5].violinplot(data[-1:], pos[-1:], points=200, orientation='horizontal',\n                     widths=1.1, showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5, side='high')\naxs[1, 5].set_title('Custom violin 12', fontsize=fs)\n\n\nfor ax in axs.flat:\n    ax.set_yticklabels([])\n\nfig.suptitle(\"Violin Plotting Examples\")\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\n# %%\n#\n# .. tags:: plot-type: violin, domain: statistics\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.violinplot` / `matplotlib.pyplot.violinplot`\n"
    }
  ],
  "style_sheets": [
    {
      "filename": "bmh.py",
      "title": "Bmh",
      "code": "\"\"\"\n========================================\nBayesian Methods for Hackers style sheet\n========================================\n\nThis example demonstrates the style used in the Bayesian Methods for Hackers\n[1]_ online book.\n\n.. [1] http://camdavidsonpilon.github.io/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nplt.style.use('bmh')\n\n\ndef plot_beta_hist(ax, a, b):\n    ax.hist(np.random.beta(a, b, size=10000),\n            histtype=\"stepfilled\", bins=25, alpha=0.8, density=True)\n\n\nfig, ax = plt.subplots()\nplot_beta_hist(ax, 10, 10)\nplot_beta_hist(ax, 4, 12)\nplot_beta_hist(ax, 50, 12)\nplot_beta_hist(ax, 6, 55)\nax.set_title(\"'bmh' style sheet\")\n\nplt.show()\n"
    },
    {
      "filename": "dark_background.py",
      "title": "Dark Background",
      "code": "\"\"\"\n===========================\nDark background style sheet\n===========================\n\nThis example demonstrates the \"dark_background\" style, which uses white for\nelements that are typically black (text, borders, etc). Note that not all plot\nelements default to colors defined by an rc parameter.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('dark_background')\n\nfig, ax = plt.subplots()\n\nL = 6\nx = np.linspace(0, L)\nncolors = len(plt.rcParams['axes.prop_cycle'])\nshift = np.linspace(0, L, ncolors, endpoint=False)\nfor s in shift:\n    ax.plot(x, np.sin(x + s), 'o-')\nax.set_xlabel('x-axis')\nax.set_ylabel('y-axis')\nax.set_title(\"'dark_background' style sheet\")\n\nplt.show()\n"
    },
    {
      "filename": "fivethirtyeight.py",
      "title": "Fivethirtyeight",
      "code": "\"\"\"\n===========================\nFiveThirtyEight style sheet\n===========================\n\nThis shows an example of the \"fivethirtyeight\" styling, which\ntries to replicate the styles from FiveThirtyEight.com.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('fivethirtyeight')\n\nx = np.linspace(0, 10)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\nax.plot(x, np.sin(x) + x + np.random.randn(50))\nax.plot(x, np.sin(x) + 0.5 * x + np.random.randn(50))\nax.plot(x, np.sin(x) + 2 * x + np.random.randn(50))\nax.plot(x, np.sin(x) - 0.5 * x + np.random.randn(50))\nax.plot(x, np.sin(x) - 2 * x + np.random.randn(50))\nax.plot(x, np.sin(x) + np.random.randn(50))\nax.set_title(\"'fivethirtyeight' style sheet\")\n\nplt.show()\n"
    },
    {
      "filename": "ggplot.py",
      "title": "Ggplot",
      "code": "\"\"\"\n==================\nggplot style sheet\n==================\n\nThis example demonstrates the \"ggplot\" style, which adjusts the style to\nemulate ggplot_ (a popular plotting package for R_).\n\nThese settings were shamelessly stolen from [1]_ (with permission).\n\n.. [1] https://everyhue.me/posts/sane-color-scheme-for-matplotlib/\n\n.. _ggplot: https://ggplot2.tidyverse.org/\n.. _R: https://www.r-project.org/\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('ggplot')\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, axs = plt.subplots(ncols=2, nrows=2)\nax1, ax2, ax3, ax4 = axs.flat\n\n# scatter plot (Note: `plt.scatter` doesn't use default colors)\nx, y = np.random.normal(size=(2, 200))\nax1.plot(x, y, 'o')\n\n# sinusoidal lines with colors from default color cycle\nL = 2*np.pi\nx = np.linspace(0, L)\nncolors = len(plt.rcParams['axes.prop_cycle'])\nshift = np.linspace(0, L, ncolors, endpoint=False)\nfor s in shift:\n    ax2.plot(x, np.sin(x + s), '-')\nax2.margins(0)\n\n# bar graphs\nx = np.arange(5)\ny1, y2 = np.random.randint(1, 25, size=(2, 5))\nwidth = 0.25\nax3.bar(x, y1, width)\nax3.bar(x + width, y2, width,\n        color=list(plt.rcParams['axes.prop_cycle'])[2]['color'])\nax3.set_xticks(x + width, labels=['a', 'b', 'c', 'd', 'e'])\n\n# circles with colors from default color cycle\nfor i, color in enumerate(plt.rcParams['axes.prop_cycle']):\n    xy = np.random.normal(size=2)\n    ax4.add_patch(plt.Circle(xy, radius=0.3, color=color['color']))\nax4.axis('equal')\nax4.margins(0)\n\nplt.show()\n"
    },
    {
      "filename": "grayscale.py",
      "title": "Grayscale",
      "code": "\"\"\"\n=====================\nGrayscale style sheet\n=====================\n\nThis example demonstrates the \"grayscale\" style sheet, which changes all colors\nthat are defined as `.rcParams` to grayscale. Note, however, that not all\nplot elements respect `.rcParams`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef color_cycle_example(ax):\n    L = 6\n    x = np.linspace(0, L)\n    ncolors = len(plt.rcParams['axes.prop_cycle'])\n    shift = np.linspace(0, L, ncolors, endpoint=False)\n    for s in shift:\n        ax.plot(x, np.sin(x + s), 'o-')\n\n\ndef image_and_patch_example(ax):\n    ax.imshow(np.random.random(size=(20, 20)), interpolation='none')\n    c = plt.Circle((5, 5), radius=5, label='patch')\n    ax.add_patch(c)\n\n\nplt.style.use('grayscale')\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\nfig.suptitle(\"'grayscale' style sheet\")\n\ncolor_cycle_example(ax1)\nimage_and_patch_example(ax2)\n\nplt.show()\n"
    },
    {
      "filename": "petroff10.py",
      "title": "Petroff10",
      "code": "\"\"\"\n=====================\nPetroff10 style sheet\n=====================\n\nThis example demonstrates the \"petroff10\" style, which implements the 10-color\nsequence developed by Matthew A. Petroff [1]_ for accessible data visualization.\nThe style balances aesthetics with accessibility considerations, making it\nsuitable for various types of plots while ensuring readability and distinction\nbetween data series.\n\n.. [1] https://arxiv.org/abs/2107.02270\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef colored_lines_example(ax):\n    t = np.linspace(-10, 10, 100)\n    nb_colors = len(plt.rcParams['axes.prop_cycle'])\n    shifts = np.linspace(-5, 5, nb_colors)\n    amplitudes = np.linspace(1, 1.5, nb_colors)\n    for t0, a in zip(shifts, amplitudes):\n        y = a / (1 + np.exp(-(t - t0)))\n        line, = ax.plot(t, y, '-')\n        point_indices = np.linspace(0, len(t) - 1, 20, dtype=int)\n        ax.plot(t[point_indices], y[point_indices], 'o', color=line.get_color())\n    ax.set_xlim(-10, 10)\n\n\ndef image_and_patch_example(ax):\n    ax.imshow(np.random.random(size=(20, 20)), interpolation='none')\n    c = plt.Circle((5, 5), radius=5, label='patch')\n    ax.add_patch(c)\n\nplt.style.use('petroff10')\nfig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(12, 5))\nfig.suptitle(\"'petroff10' style sheet\")\ncolored_lines_example(ax1)\nimage_and_patch_example(ax2)\nplt.show()\n"
    },
    {
      "filename": "plot_solarizedlight2.py",
      "title": "Plot Solarizedlight2",
      "code": "\"\"\"\n==========================\nSolarized Light stylesheet\n==========================\n\nThis shows an example of \"Solarized_Light\" styling, which\ntries to replicate the styles of:\n\n- https://ethanschoonover.com/solarized/\n- https://github.com/jrnold/ggthemes\n- http://www.pygal.org/en/stable/documentation/builtin_styles.html#light-solarized\n\nand work of:\n\n- https://github.com/tonysyu/mpltools\n\nusing all 8 accents of the color palette - starting with blue\n\nStill TODO:\n\n- Create alpha values for bar and stacked charts. .33 or .5\n- Apply Layout Rules\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.linspace(0, 10)\nwith plt.style.context('Solarize_Light2'):\n    plt.plot(x, np.sin(x) + x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 2 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 3 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 4 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 5 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 6 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 7 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 8 * x + np.random.randn(50))\n    # Number of accent colors in the color scheme\n    plt.title('8 Random Lines - Line')\n    plt.xlabel('x label', fontsize=14)\n    plt.ylabel('y label', fontsize=14)\n\nplt.show()\n"
    },
    {
      "filename": "style_sheets_reference.py",
      "title": "Style Sheets Reference",
      "code": "\"\"\"\n======================\nStyle sheets reference\n======================\n\nThis script demonstrates the different available style sheets on a\ncommon set of example plots: scatter plot, image, bar graph, patches,\nline plot and histogram.\n\nAny of these style sheets can be imported (i.e. activated) by its name.\nFor example for the ggplot style:\n\n>>> plt.style.use('ggplot')\n\nThe names of the available style sheets can be found\nin the list `matplotlib.style.available`\n(they are also printed in the corner of each plot below).\n\nSee more details in :ref:`Customizing Matplotlib\nusing style sheets<customizing-with-style-sheets>`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Rectangle\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef plot_scatter(ax, prng, nb_samples=100):\n    \"\"\"Scatter plot.\"\"\"\n    for mu, sigma, marker in [(-.5, 0.75, 'o'), (0.75, 1., 's')]:\n        x, y = prng.normal(loc=mu, scale=sigma, size=(2, nb_samples))\n        ax.plot(x, y, ls='none', marker=marker)\n    ax.set_xlabel('X-label')\n    ax.set_title('Axes title')\n    return ax\n\n\ndef plot_colored_lines(ax):\n    \"\"\"Plot lines with colors following the style color cycle.\"\"\"\n    t = np.linspace(-10, 10, 100)\n\n    def sigmoid(t, t0):\n        return 1 / (1 + np.exp(-(t - t0)))\n\n    nb_colors = len(plt.rcParams['axes.prop_cycle'])\n    shifts = np.linspace(-5, 5, nb_colors)\n    amplitudes = np.linspace(1, 1.5, nb_colors)\n    for t0, a in zip(shifts, amplitudes):\n        ax.plot(t, a * sigmoid(t, t0), '-')\n    ax.set_xlim(-10, 10)\n    return ax\n\n\ndef plot_bar_graphs(ax, prng, min_value=5, max_value=25, nb_samples=5):\n    \"\"\"Plot two bar graphs side by side, with letters as x-tick labels.\"\"\"\n    x = np.arange(nb_samples)\n    ya, yb = prng.randint(min_value, max_value, size=(2, nb_samples))\n    width = 0.25\n    ax.bar(x, ya, width)\n    ax.bar(x + width, yb, width, color='C2')\n    ax.set_xticks(x + width, labels=['a', 'b', 'c', 'd', 'e'])\n    return ax\n\n\ndef plot_colored_circles(ax, prng, nb_samples=15):\n    \"\"\"\n    Plot circle patches.\n\n    NB: draws a fixed amount of samples, rather than using the length of\n    the color cycle, because different styles may have different numbers\n    of colors.\n    \"\"\"\n    for sty_dict, j in zip(plt.rcParams['axes.prop_cycle'](),\n                           range(nb_samples)):\n        ax.add_patch(plt.Circle(prng.normal(scale=3, size=2),\n                                radius=1.0, color=sty_dict['color']))\n    ax.grid(visible=True)\n\n    # Add title for enabling grid\n    plt.title('ax.grid(True)', family='monospace', fontsize='small')\n\n    ax.set_xlim([-4, 8])\n    ax.set_ylim([-5, 6])\n    ax.set_aspect('equal', adjustable='box')  # to plot circles as circles\n    return ax\n\n\ndef plot_image_and_patch(ax, prng, size=(20, 20)):\n    \"\"\"Plot an image with random values and superimpose a circular patch.\"\"\"\n    values = prng.random_sample(size=size)\n    ax.imshow(values, interpolation='none')\n    c = plt.Circle((5, 5), radius=5, label='patch')\n    ax.add_patch(c)\n    # Remove ticks\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n\ndef plot_histograms(ax, prng, nb_samples=10000):\n    \"\"\"Plot 4 histograms and a text annotation.\"\"\"\n    params = ((10, 10), (4, 12), (50, 12), (6, 55))\n    for a, b in params:\n        values = prng.beta(a, b, size=nb_samples)\n        ax.hist(values, histtype=\"stepfilled\", bins=30,\n                alpha=0.8, density=True)\n\n    # Add a small annotation.\n    ax.annotate('Annotation', xy=(0.25, 4.25),\n                xytext=(0.9, 0.9), textcoords=ax.transAxes,\n                va=\"top\", ha=\"right\",\n                bbox=dict(boxstyle=\"round\", alpha=0.2),\n                arrowprops=dict(\n                          arrowstyle=\"->\",\n                          connectionstyle=\"angle,angleA=-95,angleB=35,rad=10\"),\n                )\n    return ax\n\n\ndef plot_figure(style_label=\"\"):\n    \"\"\"Setup and plot the demonstration figure with a given style.\"\"\"\n    # Use a dedicated RandomState instance to draw the same \"random\" values\n    # across the different figures.\n    prng = np.random.RandomState(96917002)\n\n    fig, axs = plt.subplots(ncols=6, nrows=1, num=style_label,\n                            figsize=(14.8, 2.8), layout='constrained')\n\n    # make a suptitle, in the same style for all subfigures,\n    # except those with dark backgrounds, which get a lighter color:\n    background_color = mcolors.rgb_to_hsv(\n        mcolors.to_rgb(plt.rcParams['figure.facecolor']))[2]\n    if background_color < 0.5:\n        title_color = [0.8, 0.8, 1]\n    else:\n        title_color = np.array([19, 6, 84]) / 256\n    fig.suptitle(style_label, x=0.01, ha='left', color=title_color,\n                 fontsize=14, fontfamily='DejaVu Sans', fontweight='normal')\n\n    plot_scatter(axs[0], prng)\n    plot_image_and_patch(axs[1], prng)\n    plot_bar_graphs(axs[2], prng)\n    plot_colored_lines(axs[3])\n    plot_histograms(axs[4], prng)\n    plot_colored_circles(axs[5], prng)\n\n    # add divider\n    rec = Rectangle((1 + 0.025, -2), 0.05, 16,\n                    clip_on=False, color='gray')\n\n    axs[4].add_artist(rec)\n\nif __name__ == \"__main__\":\n\n    # Set up a list of all available styles, in alphabetical order but\n    # the `default` and `classic` ones, which will be forced resp. in\n    # first and second position.\n    # styles with leading underscores are for internal use such as testing\n    # and plot types gallery. These are excluded here.\n    style_list = ['default', 'classic'] + sorted(\n        style for style in plt.style.available\n        if style != 'classic' and not style.startswith('_'))\n\n    # Plot a demonstration figure for every available style sheet.\n    for style_label in style_list:\n        with plt.rc_context({\"figure.max_open_warning\": len(style_list)}):\n            with plt.style.context(style_label):\n                plot_figure(style_label=style_label)\n\n    plt.show()\n"
    }
  ],
  "subplots_axes_and_figures": [
    {
      "filename": "align_labels_demo.py",
      "title": "Align Labels Demo",
      "code": "\"\"\"\n=======================\nAlign labels and titles\n=======================\n\nAligning xlabel, ylabel, and title using `.Figure.align_xlabels`,\n`.Figure.align_ylabels`, and `.Figure.align_titles`.\n\n`.Figure.align_labels` wraps the x and y label functions.\n\nNote that the xlabel \"XLabel1 1\" would normally be much closer to the\nx-axis, \"YLabel0 0\" would be much closer to the y-axis, and title\n\"Title0 0\" would be much closer to the top of their respective axes.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axs = plt.subplots(2, 2, layout='constrained')\n\nax = axs[0][0]\nax.plot(np.arange(0, 1e6, 1000))\nax.set_title('Title0 0')\nax.set_ylabel('YLabel0 0')\n\nax = axs[0][1]\nax.plot(np.arange(1., 0., -0.1) * 2000., np.arange(1., 0., -0.1))\nax.set_title('Title0 1')\nax.xaxis.tick_top()\nax.tick_params(axis='x', rotation=55)\n\n\nfor i in range(2):\n    ax = axs[1][i]\n    ax.plot(np.arange(1., 0., -0.1) * 2000., np.arange(1., 0., -0.1))\n    ax.set_ylabel('YLabel1 %d' % i)\n    ax.set_xlabel('XLabel1 %d' % i)\n    if i == 0:\n        ax.tick_params(axis='x', rotation=55)\n\nfig.align_labels()  # same as fig.align_xlabels(); fig.align_ylabels()\nfig.align_titles()\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: label\n#    component: title\n#    styling: position\n#    level: beginner\n"
    },
    {
      "filename": "auto_subplots_adjust.py",
      "title": "Auto Subplots Adjust",
      "code": "\"\"\"\n===========================================\nProgrammatically control subplot adjustment\n===========================================\n\n.. note::\n\n    This example is primarily intended to show some advanced concepts in\n    Matplotlib.\n\n    If you are only looking for having enough space for your labels, it is\n    almost always simpler and good enough to either set the subplot parameters\n    manually using `.Figure.subplots_adjust`, or use one of the automatic\n    layout mechanisms\n    (:ref:`constrainedlayout_guide` or\n    :ref:`tight_layout_guide`).\n\nThis example describes a user-defined way to read out Artist sizes and\nset the subplot parameters accordingly. Its main purpose is to illustrate\nsome advanced concepts like reading out text positions, working with\nbounding boxes and transforms and using\n:ref:`events <event-handling>`. But it can also serve as a starting\npoint if you want to automate the layouting and need more flexibility than\ntight layout and constrained layout.\n\nBelow, we collect the bounding boxes of all y-labels and move the left border\nof the subplot to the right so that it leaves enough room for the union of all\nthe bounding boxes.\n\nThere's one catch with calculating text bounding boxes:\nQuerying the text bounding boxes (`.Text.get_window_extent`) needs a\nrenderer (`.RendererBase` instance), to calculate the text size. This renderer\nis only available after the figure has been drawn (`.Figure.draw`).\n\nA solution to this is putting the adjustment logic in a draw callback.\nThis function is executed after the figure has been drawn. It can now check\nif the subplot leaves enough room for the text. If not, the subplot parameters\nare updated and second draw is triggered.\n\n.. redirect-from:: /gallery/pyplots/auto_subplots_adjust\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_yticks([2, 5, 7], labels=['really, really, really', 'long', 'labels'])\n\n\ndef on_draw(event):\n    bboxes = []\n    for label in ax.get_yticklabels():\n        # Bounding box in pixels\n        bbox_px = label.get_window_extent()\n        # Transform to relative figure coordinates. This is the inverse of\n        # transFigure.\n        bbox_fig = bbox_px.transformed(fig.transFigure.inverted())\n        bboxes.append(bbox_fig)\n    # the bbox that bounds all the bboxes, again in relative figure coords\n    bbox = mtransforms.Bbox.union(bboxes)\n    if fig.subplotpars.left < bbox.width:\n        # Move the subplot left edge more to the right\n        fig.subplots_adjust(left=1.1*bbox.width)  # pad a little\n        fig.canvas.draw()\n\n\nfig.canvas.mpl_connect('draw_event', on_draw)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.artist.Artist.get_window_extent`\n#    - `matplotlib.transforms.Bbox`\n#    - `matplotlib.transforms.BboxBase.transformed`\n#    - `matplotlib.transforms.BboxBase.union`\n#    - `matplotlib.transforms.Transform.inverted`\n#    - `matplotlib.figure.Figure.subplots_adjust`\n#    - `matplotlib.gridspec.SubplotParams`\n#    - `matplotlib.backend_bases.FigureCanvasBase.mpl_connect`\n#\n# .. tags::\n#\n#    component: subplot\n#    plot-type: line\n#    styling: position\n#    level: advanced\n"
    },
    {
      "filename": "axes_box_aspect.py",
      "title": "Axes Box Aspect",
      "code": "\"\"\"\n===============\nAxes box aspect\n===============\n\nThis demo shows how to set the aspect of an Axes box directly via\n`~.Axes.set_box_aspect`. The box aspect is the ratio between Axes height\nand Axes width in physical units, independent of the data limits.\nThis is useful to e.g. produce a square plot, independent of the data it\ncontains, or to have a usual plot with the same axes dimensions next to\nan image plot with fixed (data-)aspect.\n\nThe following lists a few use cases for `~.Axes.set_box_aspect`.\n\"\"\"\n\n# %%\n# A square Axes, independent of data\n# ----------------------------------\n#\n# Produce a square Axes, no matter what the data limits are.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig1, ax = plt.subplots()\n\nax.set_xlim(300, 400)\nax.set_box_aspect(1)\n\nplt.show()\n\n# %%\n# Shared square Axes\n# ------------------\n#\n# Produce shared subplots that are squared in size.\n#\nfig2, (ax, ax2) = plt.subplots(ncols=2, sharey=True)\n\nax.plot([1, 5], [0, 10])\nax2.plot([100, 500], [10, 15])\n\nax.set_box_aspect(1)\nax2.set_box_aspect(1)\n\nplt.show()\n\n# %%\n# Square twin Axes\n# ----------------\n#\n# Produce a square Axes, with a twin Axes. The twinned Axes takes over the\n# box aspect of the parent.\n#\n\nfig3, ax = plt.subplots()\n\nax2 = ax.twinx()\n\nax.plot([0, 10])\nax2.plot([12, 10])\n\nax.set_box_aspect(1)\n\nplt.show()\n\n\n# %%\n# Normal plot next to image\n# -------------------------\n#\n# When creating an image plot with fixed data aspect and the default\n# ``adjustable=\"box\"`` next to a normal plot, the Axes would be unequal in\n# height. `~.Axes.set_box_aspect` provides an easy solution to that by allowing\n# to have the normal plot's Axes use the images dimensions as box aspect.\n#\n# This example also shows that *constrained layout* interplays nicely with\n# a fixed box aspect.\n\nfig4, (ax, ax2) = plt.subplots(ncols=2, layout=\"constrained\")\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility\nim = np.random.rand(16, 27)\nax.imshow(im)\n\nax2.plot([23, 45])\nax2.set_box_aspect(im.shape[0]/im.shape[1])\n\nplt.show()\n\n# %%\n# Square joint/marginal plot\n# --------------------------\n#\n# It may be desirable to show marginal distributions next to a plot of joint\n# data. The following creates a square plot with the box aspect of the\n# marginal Axes being equal to the width- and height-ratios of the gridspec.\n# This ensures that all Axes align perfectly, independent on the size of the\n# figure.\n\nfig5, axs = plt.subplots(2, 2, sharex=\"col\", sharey=\"row\",\n                         gridspec_kw=dict(height_ratios=[1, 3],\n                                          width_ratios=[3, 1]))\naxs[0, 1].set_visible(False)\naxs[0, 0].set_box_aspect(1/3)\naxs[1, 0].set_box_aspect(1)\naxs[1, 1].set_box_aspect(3/1)\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility\nx, y = np.random.randn(2, 400) * [[.5], [180]]\naxs[1, 0].scatter(x, y)\naxs[0, 0].hist(x)\naxs[1, 1].hist(y, orientation=\"horizontal\")\n\nplt.show()\n\n# %%\n# Set data aspect with box aspect\n# -------------------------------\n#\n# When setting the box aspect, one may still set the data aspect as well.\n# Here we create an Axes with a box twice as long as it is tall and use\n# an \"equal\" data aspect for its contents, i.e. the circle actually\n# stays circular.\n\nfig6, ax = plt.subplots()\n\nax.add_patch(plt.Circle((5, 3), 1))\nax.set_aspect(\"equal\", adjustable=\"datalim\")\nax.set_box_aspect(0.5)\nax.autoscale()\n\nplt.show()\n\n# %%\n# Box aspect for many subplots\n# ----------------------------\n#\n# It is possible to pass the box aspect to an Axes at initialization. The\n# following creates a 2 by 3 subplot grid with all square Axes.\n\nfig7, axs = plt.subplots(2, 3, subplot_kw=dict(box_aspect=1),\n                         sharex=True, sharey=True, layout=\"constrained\")\n\nfor i, ax in enumerate(axs.flat):\n    ax.scatter(i % 3, -((i // 3) - 0.5)*200, c=[plt.cm.hsv(i / 6)], s=300)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.set_box_aspect`\n#\n# .. tags::\n#\n#    component: axes\n#    styling: size\n#    level: beginner\n"
    },
    {
      "filename": "axes_demo.py",
      "title": "Axes Demo",
      "code": "\"\"\"\n=========\nAxes Demo\n=========\n\nExample use of ``fig.add_axes`` to create inset Axes within the main plot Axes.\n\nPlease see also the :ref:`axes_grid_examples` section, and the following three\nexamples:\n\n- :doc:`/gallery/subplots_axes_and_figures/zoom_inset_axes`\n- :doc:`/gallery/axes_grid1/inset_locator_demo`\n- :doc:`/gallery/axes_grid1/inset_locator_demo2`\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility.\n\n# create some data to use for the plot\ndt = 0.001\nt = np.arange(0.0, 10.0, dt)\nr = np.exp(-t[:1000] / 0.05)  # impulse response\nx = np.random.randn(len(t))\ns = np.convolve(x, r)[:len(x)] * dt  # colored noise\n\nfig, main_ax = plt.subplots()\nmain_ax.plot(t, s)\nmain_ax.set_xlim(0, 1)\nmain_ax.set_ylim(1.1 * np.min(s), 2 * np.max(s))\nmain_ax.set_xlabel('time (s)')\nmain_ax.set_ylabel('current (nA)')\nmain_ax.set_title('Gaussian colored noise')\n\n# this is an inset Axes over the main Axes\nright_inset_ax = fig.add_axes([.65, .6, .2, .2], facecolor='k')\nright_inset_ax.hist(s, 400, density=True)\nright_inset_ax.set(title='Probability', xticks=[], yticks=[])\n\n# this is another inset Axes over the main Axes\nleft_inset_ax = fig.add_axes([.2, .6, .2, .2], facecolor='k')\nleft_inset_ax.plot(t[:len(r)], r)\nleft_inset_ax.set(title='Impulse response', xlim=(0, .2), xticks=[], yticks=[])\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: axes\n#    plot-type: line\n#    plot-type: histogram\n#    level: beginner\n"
    },
    {
      "filename": "axes_margins.py",
      "title": "Axes Margins",
      "code": "\"\"\"\n======================================================\nControlling view limits using margins and sticky_edges\n======================================================\n\nThe first figure in this example shows how to zoom in and out of a\nplot using `~.Axes.margins` instead of `~.Axes.set_xlim` and\n`~.Axes.set_ylim`. The second figure demonstrates the concept of\nedge \"stickiness\" introduced by certain methods and artists and how\nto effectively work around that.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n\ndef f(t):\n    return np.exp(-t) * np.cos(2*np.pi*t)\n\n\nt1 = np.arange(0.0, 3.0, 0.01)\n\nax1 = plt.subplot(212)\nax1.margins(0.05)           # Default margin is 0.05, value 0 means fit\nax1.plot(t1, f(t1))\n\nax2 = plt.subplot(221)\nax2.margins(2, 2)           # Values >0.0 zoom out\nax2.plot(t1, f(t1))\nax2.set_title('Zoomed out')\n\nax3 = plt.subplot(222)\nax3.margins(x=0, y=-0.25)   # Values in (-0.5, 0.0) zooms in to center\nax3.plot(t1, f(t1))\nax3.set_title('Zoomed in')\n\nplt.show()\n\n\n# %%\n#\n# On the \"stickiness\" of certain plotting methods\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# Some plotting functions make the axis limits \"sticky\" or immune to the will\n# of the `~.Axes.margins` methods. For instance, `~.Axes.imshow` and\n# `~.Axes.pcolor` expect the user to want the limits to be tight around the\n# pixels shown in the plot. If this behavior is not desired, you need to set\n# `~.Axes.use_sticky_edges` to `False`. Consider the following example:\n\ny, x = np.mgrid[:5, 1:6]\npoly_coords = [\n    (0.25, 2.75), (3.25, 2.75),\n    (2.25, 0.75), (0.25, 0.75)\n]\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\n# Here we set the stickiness of the Axes object...\n# ax1 we'll leave as the default, which uses sticky edges\n# and we'll turn off stickiness for ax2\nax2.use_sticky_edges = False\n\nfor ax, status in zip((ax1, ax2), ('Is', 'Is Not')):\n    cells = ax.pcolor(x, y, x+y, cmap='inferno', shading='auto')  # sticky\n    ax.add_patch(\n        Polygon(poly_coords, color='forestgreen', alpha=0.5)\n    )  # not sticky\n    ax.margins(x=0.1, y=0.05)\n    ax.set_aspect('equal')\n    ax.set_title(f'{status} Sticky')\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.margins` / `matplotlib.pyplot.margins`\n#    - `matplotlib.axes.Axes.use_sticky_edges`\n#    - `matplotlib.axes.Axes.pcolor` / `matplotlib.pyplot.pcolor`\n#    - `matplotlib.patches.Polygon`\n#\n# .. tags::\n#\n#    component: axes\n#    plot-type: line\n#    plot-type: imshow\n#    plot-type: pcolor\n#    level: beginner\n"
    },
    {
      "filename": "axes_props.py",
      "title": "Axes Props",
      "code": "\"\"\"\n===============\nAxes properties\n===============\n\nYou can control the axis tick and grid properties\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.grid(True, linestyle='-.')\nax.tick_params(labelcolor='r', labelsize='medium', width=3)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: ticks\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "axes_zoom_effect.py",
      "title": "Axes Zoom Effect",
      "code": "\"\"\"\n================\nAxes zoom effect\n================\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.transforms import (Bbox, TransformedBbox,\n                                   blended_transform_factory)\nfrom mpl_toolkits.axes_grid1.inset_locator import (BboxConnector,\n                                                   BboxConnectorPatch,\n                                                   BboxPatch)\n\n\ndef connect_bbox(bbox1, bbox2,\n                 loc1a, loc2a, loc1b, loc2b,\n                 prop_lines, prop_patches=None):\n    if prop_patches is None:\n        prop_patches = {\n            **prop_lines,\n            \"alpha\": prop_lines.get(\"alpha\", 1) * 0.2,\n            \"clip_on\": False,\n        }\n\n    c1 = BboxConnector(\n        bbox1, bbox2, loc1=loc1a, loc2=loc2a, clip_on=False, **prop_lines)\n    c2 = BboxConnector(\n        bbox1, bbox2, loc1=loc1b, loc2=loc2b, clip_on=False, **prop_lines)\n\n    bbox_patch1 = BboxPatch(bbox1, **prop_patches)\n    bbox_patch2 = BboxPatch(bbox2, **prop_patches)\n\n    p = BboxConnectorPatch(bbox1, bbox2,\n                           loc1a=loc1a, loc2a=loc2a, loc1b=loc1b, loc2b=loc2b,\n                           clip_on=False,\n                           **prop_patches)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\ndef zoom_effect01(ax1, ax2, xmin, xmax, **kwargs):\n    \"\"\"\n    Connect *ax1* and *ax2*. The *xmin*-to-*xmax* range in both Axes will\n    be marked.\n\n    Parameters\n    ----------\n    ax1\n        The main Axes.\n    ax2\n        The zoomed Axes.\n    xmin, xmax\n        The limits of the colored area in both plot Axes.\n    **kwargs\n        Arguments passed to the patch constructor.\n    \"\"\"\n\n    bbox = Bbox.from_extents(xmin, 0, xmax, 1)\n\n    mybbox1 = TransformedBbox(bbox, ax1.get_xaxis_transform())\n    mybbox2 = TransformedBbox(bbox, ax2.get_xaxis_transform())\n\n    prop_patches = {**kwargs, \"ec\": \"none\", \"alpha\": 0.2}\n\n    c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\n        mybbox1, mybbox2,\n        loc1a=3, loc2a=2, loc1b=4, loc2b=1,\n        prop_lines=kwargs, prop_patches=prop_patches)\n\n    ax1.add_patch(bbox_patch1)\n    ax2.add_patch(bbox_patch2)\n    ax2.add_patch(c1)\n    ax2.add_patch(c2)\n    ax2.add_patch(p)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\ndef zoom_effect02(ax1, ax2, **kwargs):\n    \"\"\"\n    ax1 : the main Axes\n    ax1 : the zoomed Axes\n\n    Similar to zoom_effect01.  The xmin & xmax will be taken from the\n    ax1.viewLim.\n    \"\"\"\n\n    tt = ax1.transScale + (ax1.transLimits + ax2.transAxes)\n    trans = blended_transform_factory(ax2.transData, tt)\n\n    mybbox1 = ax1.bbox\n    mybbox2 = TransformedBbox(ax1.viewLim, trans)\n\n    prop_patches = {**kwargs, \"ec\": \"none\", \"alpha\": 0.2}\n\n    c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\n        mybbox1, mybbox2,\n        loc1a=3, loc2a=2, loc1b=4, loc2b=1,\n        prop_lines=kwargs, prop_patches=prop_patches)\n\n    ax1.add_patch(bbox_patch1)\n    ax2.add_patch(bbox_patch2)\n    ax2.add_patch(c1)\n    ax2.add_patch(c2)\n    ax2.add_patch(p)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\naxs = plt.figure().subplot_mosaic([\n    [\"zoom1\", \"zoom2\"],\n    [\"main\", \"main\"],\n])\n\naxs[\"main\"].set(xlim=(0, 5))\nzoom_effect01(axs[\"zoom1\"], axs[\"main\"], 0.2, 0.8)\naxs[\"zoom2\"].set(xlim=(2, 3))\nzoom_effect02(axs[\"zoom2\"], axs[\"main\"])\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: subplot\n#    component: transform\n#    level: advanced\n"
    },
    {
      "filename": "axhspan_demo.py",
      "title": "Axhspan Demo",
      "code": "\"\"\"\n==============================\nDraw regions that span an Axes\n==============================\n\n`~.Axes.axhspan` and `~.Axes.axvspan` draw rectangles that span the Axes in either\nthe horizontal or vertical direction and are bounded in the other direction. They are\noften used to highlight data regions.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 3))\n\nnp.random.seed(19680801)\ns = 2.9 * np.convolve(np.random.randn(500), np.ones(30) / 30, mode='valid')\nax1.plot(s)\nax1.axhspan(-1, 1, alpha=0.1)\nax1.set(ylim=(-1.5, 1.5), title=\"axhspan\")\n\n\nmu = 8\nsigma = 2\nx = np.linspace(0, 16, 401)\ny = np.exp(-((x-mu)**2)/(2*sigma**2))\nax2.axvspan(mu-2*sigma, mu-sigma, color='0.95')\nax2.axvspan(mu-sigma, mu+sigma, color='0.9')\nax2.axvspan(mu+sigma, mu+2*sigma, color='0.95')\nax2.axvline(mu, color='darkgrey', linestyle='--')\nax2.plot(x, y)\nax2.set(title=\"axvspan\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.axhspan` / `matplotlib.pyplot.axhspan`\n#    - `matplotlib.axes.Axes.axvspan` / `matplotlib.pyplot.axvspan`\n#\n#\n# .. seealso::\n#\n#    `~.Axes.axhline`, `~.Axes.axvline`, `~.Axes.axline` draw infinite lines.\n#\n# .. tags::\n#\n#    styling: shape\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "axis_equal_demo.py",
      "title": "Axis Equal Demo",
      "code": "\"\"\"\n=======================\nEqual axis aspect ratio\n=======================\n\nHow to set and adjust plots with equal axis aspect ratios.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Plot circle of radius 3.\n\nan = np.linspace(0, 2 * np.pi, 100)\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[0, 0].set_title('not equal, looks like ellipse', fontsize=10)\n\naxs[0, 1].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[0, 1].axis('equal')\naxs[0, 1].set_title('equal, looks like circle', fontsize=10)\n\naxs[1, 0].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[1, 0].axis('equal')\naxs[1, 0].set(xlim=(-3, 3), ylim=(-3, 3))\naxs[1, 0].set_title('still a circle, even after changing limits', fontsize=10)\n\naxs[1, 1].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[1, 1].set_aspect('equal', 'box')\naxs[1, 1].set_title('still a circle, auto-adjusted data limits', fontsize=10)\n\nfig.tight_layout()\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: axes\n#    styling: size\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "axis_labels_demo.py",
      "title": "Axis Labels Demo",
      "code": "\"\"\"\n===================\nAxis label position\n===================\n\nChoose axis label position when calling `~.Axes.set_xlabel` and\n`~.Axes.set_ylabel` as well as for colorbar.\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nsc = ax.scatter([1, 2], [1, 2], c=[1, 2])\nax.set_ylabel('YLabel', loc='top')\nax.set_xlabel('XLabel', loc='left')\ncbar = fig.colorbar(sc)\ncbar.set_label(\"ZLabel\", loc='top')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: axis\n#    styling: position\n#    level: beginner\n"
    },
    {
      "filename": "broken_axis.py",
      "title": "Broken Axis",
      "code": "\"\"\"\n===========\nBroken axis\n===========\n\nBroken axis example, where the y-axis will have a portion cut out.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\npts = np.random.rand(30)*.2\n# Now let's make two outlier points which are far away from everything.\npts[[3, 14]] += .8\n\n# If we were to simply plot pts, we'd lose most of the interesting\n# details due to the outliers. So let's 'break' or 'cut-out' the y-axis\n# into two portions - use the top (ax1) for the outliers, and the bottom\n# (ax2) for the details of the majority of our data\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nfig.subplots_adjust(hspace=0.05)  # adjust space between Axes\n\n# plot the same data on both Axes\nax1.plot(pts)\nax2.plot(pts)\n\n# zoom-in / limit the view to different portions of the data\nax1.set_ylim(.78, 1.)  # outliers only\nax2.set_ylim(0, .22)  # most of the data\n\n# hide the spines between ax and ax2\nax1.spines.bottom.set_visible(False)\nax2.spines.top.set_visible(False)\nax1.xaxis.tick_top()\nax1.tick_params(labeltop=False)  # don't put tick labels at the top\nax2.xaxis.tick_bottom()\n\n# Now, let's turn towards the cut-out slanted lines.\n# We create line objects in axes coordinates, in which (0,0), (0,1),\n# (1,0), and (1,1) are the four corners of the Axes.\n# The slanted lines themselves are markers at those locations, such that the\n# lines keep their angle and position, independent of the Axes size or scale\n# Finally, we need to disable clipping.\n\nd = .5  # proportion of vertical to horizontal extent of the slanted line\nkwargs = dict(marker=[(-1, -d), (1, d)], markersize=12,\n              linestyle=\"none\", color='k', mec='k', mew=1, clip_on=False)\nax1.plot([0, 1], [0, 0], transform=ax1.transAxes, **kwargs)\nax2.plot([0, 1], [1, 1], transform=ax2.transAxes, **kwargs)\n\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: axis\n#    plot-type: line\n#    level: intermediate\n"
    },
    {
      "filename": "custom_figure_class.py",
      "title": "Custom Figure Class",
      "code": "\"\"\"\n========================\nCustom Figure subclasses\n========================\n\nYou can pass a `.Figure` subclass to `.pyplot.figure` if you want to change\nthe default behavior of the figure.\n\nThis example defines a `.Figure` subclass ``WatermarkFigure`` that accepts an\nadditional parameter ``watermark`` to display a custom watermark text. The\nfigure is created using the ``FigureClass`` parameter of `.pyplot.figure`.\nThe additional ``watermark`` parameter is passed on to the subclass\nconstructor.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.figure import Figure\n\n\nclass WatermarkFigure(Figure):\n    \"\"\"A figure with a text watermark.\"\"\"\n\n    def __init__(self, *args, watermark=None, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if watermark is not None:\n            bbox = dict(boxstyle='square', lw=3, ec='gray',\n                        fc=(0.9, 0.9, .9, .5), alpha=0.5)\n            self.text(0.5, 0.5, watermark,\n                      ha='center', va='center', rotation=30,\n                      fontsize=40, color='gray', alpha=0.5, bbox=bbox)\n\n\nx = np.linspace(-3, 3, 201)\ny = np.tanh(x) + 0.1 * np.cos(5 * x)\n\nplt.figure(FigureClass=WatermarkFigure, watermark='draft')\nplt.plot(x, y)\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.figure`\n#    - `matplotlib.figure.Figure`\n#    - `matplotlib.figure.Figure.text`\n#\n# .. tags::\n#\n#    component: figure\n#    plot-type: line\n#    level: intermediate\n#    purpose: showcase\n"
    },
    {
      "filename": "demo_constrained_layout.py",
      "title": "Demo Constrained Layout",
      "code": "\"\"\"\n===================================\nResize Axes with constrained layout\n===================================\n\n*Constrained layout* attempts to resize subplots in\na figure so that there are no overlaps between Axes objects and labels\non the Axes.\n\nSee :ref:`constrainedlayout_guide` for more details and\n:ref:`tight_layout_guide` for an alternative.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef example_plot(ax):\n    ax.plot([1, 2])\n    ax.set_xlabel('x-label', fontsize=12)\n    ax.set_ylabel('y-label', fontsize=12)\n    ax.set_title('Title', fontsize=14)\n\n\n# %%\n# If we don't use *constrained layout*, then labels overlap the Axes\n\nfig, axs = plt.subplots(nrows=2, ncols=2, layout=None)\n\nfor ax in axs.flat:\n    example_plot(ax)\n\n# %%\n# adding ``layout='constrained'`` automatically adjusts.\n\nfig, axs = plt.subplots(nrows=2, ncols=2, layout='constrained')\n\nfor ax in axs.flat:\n    example_plot(ax)\n\n# %%\n# Below is a more complicated example using nested gridspecs.\n\nfig = plt.figure(layout='constrained')\n\nimport matplotlib.gridspec as gridspec\n\ngs0 = gridspec.GridSpec(1, 2, figure=fig)\n\ngs1 = gridspec.GridSpecFromSubplotSpec(3, 1, subplot_spec=gs0[0])\nfor n in range(3):\n    ax = fig.add_subplot(gs1[n])\n    example_plot(ax)\n\n\ngs2 = gridspec.GridSpecFromSubplotSpec(2, 1, subplot_spec=gs0[1])\nfor n in range(2):\n    ax = fig.add_subplot(gs2[n])\n    example_plot(ax)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.gridspec.GridSpec`\n#    - `matplotlib.gridspec.GridSpecFromSubplotSpec`\n#\n# .. tags::\n#\n#    component: axes\n#    component: subplot\n#    styling: size\n#    level: beginner\n"
    },
    {
      "filename": "demo_tight_layout.py",
      "title": "Demo Tight Layout",
      "code": "\"\"\"\n=============================\nResize Axes with tight layout\n=============================\n\n`~.Figure.tight_layout` attempts to resize subplots in a figure so that there\nare no overlaps between Axes objects and labels on the Axes.\n\nSee :ref:`tight_layout_guide` for more details and\n:ref:`constrainedlayout_guide` for an alternative.\n\n\"\"\"\n\nimport itertools\nimport warnings\n\nimport matplotlib.pyplot as plt\n\nfontsizes = itertools.cycle([8, 16, 24, 32])\n\n\ndef example_plot(ax):\n    ax.plot([1, 2])\n    ax.set_xlabel('x-label', fontsize=next(fontsizes))\n    ax.set_ylabel('y-label', fontsize=next(fontsizes))\n    ax.set_title('Title', fontsize=next(fontsizes))\n\n\n# %%\n\nfig, ax = plt.subplots()\nexample_plot(ax)\nfig.tight_layout()\n\n# %%\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, ncols=2)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\nfig.tight_layout()\n\n# %%\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1)\nexample_plot(ax1)\nexample_plot(ax2)\nfig.tight_layout()\n\n# %%\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2)\nexample_plot(ax1)\nexample_plot(ax2)\nfig.tight_layout()\n\n# %%\n\nfig, axs = plt.subplots(nrows=3, ncols=3)\nfor ax in axs.flat:\n    example_plot(ax)\nfig.tight_layout()\n\n# %%\n\nplt.figure()\nax1 = plt.subplot(221)\nax2 = plt.subplot(223)\nax3 = plt.subplot(122)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nplt.tight_layout()\n\n# %%\n\nplt.figure()\nax1 = plt.subplot2grid((3, 3), (0, 0))\nax2 = plt.subplot2grid((3, 3), (0, 1), colspan=2)\nax3 = plt.subplot2grid((3, 3), (1, 0), colspan=2, rowspan=2)\nax4 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\nplt.tight_layout()\n\n# %%\n\nfig = plt.figure()\n\ngs1 = fig.add_gridspec(3, 1)\nax1 = fig.add_subplot(gs1[0])\nax2 = fig.add_subplot(gs1[1])\nax3 = fig.add_subplot(gs1[2])\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\ngs1.tight_layout(fig, rect=[None, None, 0.45, None])\n\ngs2 = fig.add_gridspec(2, 1)\nax4 = fig.add_subplot(gs2[0])\nax5 = fig.add_subplot(gs2[1])\nexample_plot(ax4)\nexample_plot(ax5)\nwith warnings.catch_warnings():\n    # gs2.tight_layout cannot handle the subplots from the first gridspec\n    # (gs1), so it will raise a warning. We are going to match the gridspecs\n    # manually so we can filter the warning away.\n    warnings.simplefilter(\"ignore\", UserWarning)\n    gs2.tight_layout(fig, rect=[0.45, None, None, None])\n\n# now match the top and bottom of two gridspecs.\ntop = min(gs1.top, gs2.top)\nbottom = max(gs1.bottom, gs2.bottom)\n\ngs1.update(top=top, bottom=bottom)\ngs2.update(top=top, bottom=bottom)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure.tight_layout` /\n#      `matplotlib.pyplot.tight_layout`\n#    - `matplotlib.figure.Figure.add_gridspec`\n#    - `matplotlib.figure.Figure.add_subplot`\n#    - `matplotlib.pyplot.subplot2grid`\n#\n# .. tags::\n#\n#    component: axes\n#    component: subplot\n#    styling: size\n#    level: beginner\n"
    },
    {
      "filename": "fahrenheit_celsius_scales.py",
      "title": "Fahrenheit Celsius Scales",
      "code": "\"\"\"\n=================================\nDifferent scales on the same Axes\n=================================\n\nDemo of how to display two scales on the left and right y-axis.\n\nThis example uses the Fahrenheit and Celsius scales.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef fahrenheit2celsius(temp):\n    \"\"\"\n    Returns temperature in Celsius given Fahrenheit temperature.\n    \"\"\"\n    return (5. / 9.) * (temp - 32)\n\n\ndef make_plot():\n\n    # Define a closure function to register as a callback\n    def convert_ax_c_to_celsius(ax_f):\n        \"\"\"\n        Update second axis according to first axis.\n        \"\"\"\n        y1, y2 = ax_f.get_ylim()\n        ax_c.set_ylim(fahrenheit2celsius(y1), fahrenheit2celsius(y2))\n        ax_c.figure.canvas.draw()\n\n    fig, ax_f = plt.subplots()\n    ax_c = ax_f.twinx()\n\n    # automatically update ylim of ax2 when ylim of ax1 changes.\n    ax_f.callbacks.connect(\"ylim_changed\", convert_ax_c_to_celsius)\n    ax_f.plot(np.linspace(-40, 120, 100))\n    ax_f.set_xlim(0, 100)\n\n    ax_f.set_title('Two scales: Fahrenheit and Celsius')\n    ax_f.set_ylabel('Fahrenheit')\n    ax_c.set_ylabel('Celsius')\n\n    plt.show()\n\nmake_plot()\n\n# %%\n# .. tags::\n#\n#    component: axes\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "figure_size_units.py",
      "title": "Figure Size Units",
      "code": "\"\"\"\n==============================\nFigure size in different units\n==============================\n\nThe native figure size unit in Matplotlib is inches, deriving from print\nindustry standards. However, users may need to specify their figures in other\nunits like centimeters or pixels. This example illustrates how to do this\nefficiently.\n\"\"\"\n\n# sphinx_gallery_thumbnail_number = 2\n\nimport matplotlib.pyplot as plt\n\ntext_kwargs = dict(ha='center', va='center', fontsize=28, color='C1')\n\n# %%\n# Figure size in inches (default)\n# -------------------------------\n#\nplt.subplots(figsize=(6, 2))\nplt.text(0.5, 0.5, '6 inches x 2 inches', **text_kwargs)\nplt.show()\n\n\n# %%\n# Figure size in centimeter\n# -------------------------\n# Multiplying centimeter-based numbers with a conversion factor from cm to\n# inches, gives the right numbers. Naming the conversion factor ``cm`` makes\n# the conversion almost look like appending a unit to the number, which is\n# nicely readable.\n#\ncm = 1/2.54  # centimeters in inches\nplt.subplots(figsize=(15*cm, 5*cm))\nplt.text(0.5, 0.5, '15cm x 5cm', **text_kwargs)\nplt.show()\n\n\n# %%\n# Figure size in pixel\n# --------------------\n# Similarly, one can use a conversion from pixels.\n#\n# Note that you could break this if you use `~.pyplot.savefig` with a\n# different explicit dpi value.\n#\npx = 1/plt.rcParams['figure.dpi']  # pixel in inches\nplt.subplots(figsize=(600*px, 200*px))\nplt.text(0.5, 0.5, '600px x 200px', **text_kwargs)\nplt.show()\n\n# %%\n# Quick interactive work is usually rendered to the screen, making pixels a\n# good size of unit. But defining the conversion factor may feel a little\n# tedious for quick iterations.\n#\n# Because of the default ``rcParams['figure.dpi'] = 100``, one can mentally\n# divide the needed pixel value by 100 [#]_:\n#\nplt.subplots(figsize=(6, 2))\nplt.text(0.5, 0.5, '600px x 200px', **text_kwargs)\nplt.show()\n\n# %%\n# .. [#] Unfortunately, this does not work well for the ``matplotlib inline``\n#        backend in Jupyter because that backend saves the figure\n#        with ``bbox_inches='tight'``, which crops the figure and makes the\n#        actual size unpredictable.\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.figure`\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.pyplot.subplot_mosaic`\n#\n# .. tags::\n#\n#    component: figure\n#    styling: size\n#    level: beginner\n"
    },
    {
      "filename": "figure_title.py",
      "title": "Figure Title",
      "code": "\"\"\"\n=============================================\nFigure labels: suptitle, supxlabel, supylabel\n=============================================\n\nEach Axes can have a title (or actually three - one each with *loc* \"left\",\n\"center\", and \"right\"), but is sometimes desirable to give a whole figure\n(or `.SubFigure`) an overall title, using `.Figure.suptitle`.\n\nWe can also add figure-level x- and y-labels using `.Figure.supxlabel` and\n`.Figure.supylabel`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\n\nx = np.linspace(0.0, 5.0, 501)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, layout='constrained', sharey=True)\nax1.plot(x, np.cos(6*x) * np.exp(-x))\nax1.set_title('damped')\nax1.set_xlabel('time (s)')\nax1.set_ylabel('amplitude')\n\nax2.plot(x, np.cos(6*x))\nax2.set_xlabel('time (s)')\nax2.set_title('undamped')\n\nfig.suptitle('Different types of oscillations', fontsize=16)\n\n# %%\n# A global x- or y-label can be set using the `.Figure.supxlabel` and\n# `.Figure.supylabel` methods.\n\n\nwith get_sample_data('Stocks.csv') as file:\n    stocks = np.genfromtxt(\n        file, delimiter=',', names=True, dtype=None,\n        converters={0: lambda x: np.datetime64(x, 'D')}, skip_header=1)\n\nfig, axs = plt.subplots(4, 2, figsize=(9, 5), layout='constrained',\n                        sharex=True, sharey=True)\nfor nn, ax in enumerate(axs.flat):\n    column_name = stocks.dtype.names[1+nn]\n    y = stocks[column_name]\n    line, = ax.plot(stocks['Date'], y / np.nanmax(y), lw=2.5)\n    ax.set_title(column_name, fontsize='small', loc='left')\nfig.supxlabel('Year')\nfig.supylabel('Stock price relative to max')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: figure\n#    component: title\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "ganged_plots.py",
      "title": "Ganged Plots",
      "code": "\"\"\"\n=================\nAdjacent subplots\n=================\n\nTo create plots that share a common axis (visually) you can set the hspace\nbetween the subplots to zero. Passing sharex=True when creating the subplots\nwill automatically turn off all x ticks and labels except those on the bottom\naxis.\n\nIn this example the plots share a common x-axis, but you can follow the same\nlogic to supply a common y-axis.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\n\ns1 = np.sin(2 * np.pi * t)\ns2 = np.exp(-t)\ns3 = s1 * s2\n\nfig, axs = plt.subplots(3, 1, sharex=True)\n# Remove vertical space between Axes\nfig.subplots_adjust(hspace=0)\n\n# Plot each graph, and manually set the y tick values\naxs[0].plot(t, s1)\naxs[0].set_yticks(np.arange(-0.9, 1.0, 0.4))\naxs[0].set_ylim(-1, 1)\n\naxs[1].plot(t, s2)\naxs[1].set_yticks(np.arange(0.1, 1.0, 0.2))\naxs[1].set_ylim(0, 1)\n\naxs[2].plot(t, s3)\naxs[2].set_yticks(np.arange(-0.9, 1.0, 0.4))\naxs[2].set_ylim(-1, 1)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: subplot\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "geo_demo.py",
      "title": "Geo Demo",
      "code": "\"\"\"\n======================\nGeographic Projections\n======================\n\nThis shows 4 possible geographic projections.  Cartopy_ supports more\nprojections.\n\n.. _Cartopy: https://cartopy.readthedocs.io\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n# %%\n\nplt.figure()\nplt.subplot(projection=\"aitoff\")\nplt.title(\"Aitoff\")\nplt.grid(True)\n\n# %%\n\nplt.figure()\nplt.subplot(projection=\"hammer\")\nplt.title(\"Hammer\")\nplt.grid(True)\n\n# %%\n\nplt.figure()\nplt.subplot(projection=\"lambert\")\nplt.title(\"Lambert\")\nplt.grid(True)\n\n# %%\n\nplt.figure()\nplt.subplot(projection=\"mollweide\")\nplt.title(\"Mollweide\")\nplt.grid(True)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    plot-type: specialty\n#    component: projection\n#    domain: cartography\n"
    },
    {
      "filename": "gridspec_and_subplots.py",
      "title": "Gridspec And Subplots",
      "code": "\"\"\"\n================================================\nCombine two subplots using subplots and GridSpec\n================================================\n\nSometimes we want to combine two subplots in an Axes layout created with\n`~.Figure.subplots`.  We can get the `~.gridspec.GridSpec` from the Axes\nand then remove the covered Axes and fill the gap with a new bigger Axes.\nHere we create a layout with the bottom two Axes in the last column combined.\n\nTo start with this layout (rather than removing the overlapping Axes) use\n`~.pyplot.subplot_mosaic`.\n\nSee also :ref:`arranging_axes`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(ncols=3, nrows=3)\ngs = axs[1, 2].get_gridspec()\n# remove the underlying Axes\nfor ax in axs[1:, -1]:\n    ax.remove()\naxbig = fig.add_subplot(gs[1:, -1])\naxbig.annotate('Big Axes \\nGridSpec[1:, -1]', (0.1, 0.5),\n               xycoords='axes fraction', va='center')\n\nfig.tight_layout()\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: subplot\n#    level: beginner\n"
    },
    {
      "filename": "gridspec_customization.py",
      "title": "Gridspec Customization",
      "code": "\"\"\"\n========================================\nGridSpec with variable sizes and spacing\n========================================\n\nThis example demonstrates the use of `.GridSpec` to generate subplots,\nthe control of the relative sizes of subplots with *width_ratios* and\n*height_ratios*, and the control of the spacing around and between subplots\nusing subplot params (*left*, *right*, *bottom*, *top*, *wspace*, and\n*hspace*).\n\n.. redirect-from:: /gallery/userdemo/demo_gridspec03\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.gridspec import GridSpec\n\n\ndef annotate_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\n\nfig = plt.figure()\nfig.suptitle(\"Controlling subplot sizes with width_ratios and height_ratios\")\n\ngs = GridSpec(2, 2, width_ratios=[1, 2], height_ratios=[4, 1])\nax1 = fig.add_subplot(gs[0])\nax2 = fig.add_subplot(gs[1])\nax3 = fig.add_subplot(gs[2])\nax4 = fig.add_subplot(gs[3])\n\nannotate_axes(fig)\n\n# %%\n\nfig = plt.figure()\nfig.suptitle(\"Controlling spacing around and between subplots\")\n\ngs1 = GridSpec(3, 3, left=0.05, right=0.48, wspace=0.05)\nax1 = fig.add_subplot(gs1[:-1, :])\nax2 = fig.add_subplot(gs1[-1, :-1])\nax3 = fig.add_subplot(gs1[-1, -1])\n\ngs2 = GridSpec(3, 3, left=0.55, right=0.98, hspace=0.05)\nax4 = fig.add_subplot(gs2[:, :-1])\nax5 = fig.add_subplot(gs2[:-1, -1])\nax6 = fig.add_subplot(gs2[-1, -1])\n\nannotate_axes(fig)\n\nplt.show()\n"
    },
    {
      "filename": "gridspec_multicolumn.py",
      "title": "Gridspec Multicolumn",
      "code": "\"\"\"\n=============================================\nGridspec for multi-column/row subplot layouts\n=============================================\n\n`.GridSpec` is a flexible way to layout\nsubplot grids.  Here is an example with a 3x3 grid, and\naxes spanning all three columns, two columns, and two rows.\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.gridspec import GridSpec\n\n\ndef format_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\nfig = plt.figure(layout=\"constrained\")\n\ngs = GridSpec(3, 3, figure=fig)\nax1 = fig.add_subplot(gs[0, :])\n# identical to ax1 = plt.subplot(gs.new_subplotspec((0, 0), colspan=3))\nax2 = fig.add_subplot(gs[1, :-1])\nax3 = fig.add_subplot(gs[1:, -1])\nax4 = fig.add_subplot(gs[-1, 0])\nax5 = fig.add_subplot(gs[-1, -2])\n\nfig.suptitle(\"GridSpec\")\nformat_axes(fig)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: subplot\n#    level: intermediate\n"
    },
    {
      "filename": "gridspec_nested.py",
      "title": "Gridspec Nested",
      "code": "\"\"\"\n================\nNested Gridspecs\n================\n\nGridSpecs can be nested, so that a subplot from a parent GridSpec can\nset the position for a nested grid of subplots.\n\nNote that the same functionality can be achieved more directly with\n`~.Figure.subfigures`; see\n:doc:`/gallery/subplots_axes_and_figures/subfigures`.\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nimport matplotlib.gridspec as gridspec\n\n\ndef format_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\n\n# gridspec inside gridspec\nfig = plt.figure()\n\ngs0 = gridspec.GridSpec(1, 2, figure=fig)\n\ngs00 = gridspec.GridSpecFromSubplotSpec(3, 3, subplot_spec=gs0[0])\n\nax1 = fig.add_subplot(gs00[:-1, :])\nax2 = fig.add_subplot(gs00[-1, :-1])\nax3 = fig.add_subplot(gs00[-1, -1])\n\n# the following syntax does the same as the GridSpecFromSubplotSpec call above:\ngs01 = gs0[1].subgridspec(3, 3)\n\nax4 = fig.add_subplot(gs01[:, :-1])\nax5 = fig.add_subplot(gs01[:-1, -1])\nax6 = fig.add_subplot(gs01[-1, -1])\n\nplt.suptitle(\"GridSpec Inside GridSpec\")\nformat_axes(fig)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: subplot\n#    level: intermediate\n"
    },
    {
      "filename": "invert_axes.py",
      "title": "Invert Axes",
      "code": "\"\"\"\n=============\nInverted axis\n=============\n\nThis example demonstrates two ways to invert the direction of an axis:\n\n- If you want to set *explicit axis limits* anyway, e.g. via `~.Axes.set_xlim`, you\n  can swap the limit values: ``set_xlim(4, 0)`` instead of ``set_xlim(0, 4)``.\n- Use `.Axis.set_inverted` if you only want to invert the axis *without modifying\n  the limits*, i.e. keep existing limits or existing autoscaling behavior.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0.01, 4.0, 0.01)\ny = np.exp(-x)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6.4,  4), layout=\"constrained\")\nfig.suptitle('Inverted axis with ...')\n\nax1.plot(x, y)\nax1.set_xlim(4, 0)   # inverted fixed limits\nax1.set_title('fixed limits: set_xlim(4, 0)')\nax1.set_xlabel('decreasing x \u27f6')\nax1.grid(True)\n\nax2.plot(x, y)\nax2.xaxis.set_inverted(True)  # inverted axis with autoscaling\nax2.set_title('autoscaling: set_inverted(True)')\nax2.set_xlabel('decreasing x \u27f6')\nax2.grid(True)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: axis\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "multiple_figs_demo.py",
      "title": "Multiple Figs Demo",
      "code": "\"\"\"\n=================================\nManage multiple figures in pyplot\n=================================\n\n`matplotlib.pyplot` uses the concept of a *current figure* and *current Axes*.\nFigures are identified via a figure number that is passed to `~.pyplot.figure`.\nThe figure with the given number is set as *current figure*. Additionally, if\nno figure with the number exists, a new one is created.\n\n.. note::\n\n    We discourage working with multiple figures through the implicit pyplot\n    interface because managing the *current figure* is cumbersome and\n    error-prone. Instead, we recommend using the explicit approach and call\n    methods on Figure and Axes instances. See :ref:`api_interfaces` for an\n    explanation of the trade-offs between the implicit and explicit interfaces.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns1 = np.sin(2*np.pi*t)\ns2 = np.sin(4*np.pi*t)\n\n# %%\n# Create figure 1\n\nplt.figure(1)\nplt.subplot(211)\nplt.plot(t, s1)\nplt.subplot(212)\nplt.plot(t, 2*s1)\n\n# %%\n# Create figure 2\n\nplt.figure(2)\nplt.plot(t, s2)\n\n# %%\n# Now switch back to figure 1 and make some changes\n\nplt.figure(1)\nplt.subplot(211)\nplt.plot(t, s2, 's')\nax = plt.gca()\nax.set_xticklabels([])\n\nplt.show()\n\n# %%\n# .. tags:: component: figure, plot-type: line\n"
    },
    {
      "filename": "secondary_axis.py",
      "title": "Secondary Axis",
      "code": "\"\"\"\n==============\nSecondary Axis\n==============\n\nSometimes we want a secondary axis on a plot, for instance to convert\nradians to degrees on the same plot.  We can do this by making a child\naxes with only one axis visible via `.axes.Axes.secondary_xaxis` and\n`.axes.Axes.secondary_yaxis`.  This secondary axis can have a different scale\nthan the main axis by providing both a forward and an inverse conversion\nfunction in a tuple to the *functions* keyword argument:\n\"\"\"\n\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\nfig, ax = plt.subplots(layout='constrained')\nx = np.arange(0, 360, 1)\ny = np.sin(2 * x * np.pi / 180)\nax.plot(x, y)\nax.set_xlabel('angle [degrees]')\nax.set_ylabel('signal')\nax.set_title('Sine wave')\n\n\ndef deg2rad(x):\n    return x * np.pi / 180\n\n\ndef rad2deg(x):\n    return x * 180 / np.pi\n\n\nsecax = ax.secondary_xaxis('top', functions=(deg2rad, rad2deg))\nsecax.set_xlabel('angle [rad]')\nplt.show()\n\n# %%\n# By default, the secondary axis is drawn in the Axes coordinate space.\n# We can also provide a custom transform to place it in a different\n# coordinate space. Here we put the axis at Y = 0 in data coordinates.\n\nfig, ax = plt.subplots(layout='constrained')\nx = np.arange(0, 10)\nnp.random.seed(19680801)\ny = np.random.randn(len(x))\nax.plot(x, y)\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_title('Random data')\n\n# Pass ax.transData as a transform to place the axis relative to our data\nsecax = ax.secondary_xaxis(0, transform=ax.transData)\nsecax.set_xlabel('Axis at Y = 0')\nplt.show()\n\n# %%\n# Here is the case of converting from wavenumber to wavelength in a\n# log-log scale.\n#\n# .. note::\n#\n#   In this case, the xscale of the parent is logarithmic, so the child is\n#   made logarithmic as well.\n\nfig, ax = plt.subplots(layout='constrained')\nx = np.arange(0.02, 1, 0.02)\nnp.random.seed(19680801)\ny = np.random.randn(len(x)) ** 2\nax.loglog(x, y)\nax.set_xlabel('f [Hz]')\nax.set_ylabel('PSD')\nax.set_title('Random spectrum')\n\n\ndef one_over(x):\n    \"\"\"Vectorized 1/x, treating x==0 manually\"\"\"\n    x = np.array(x, float)\n    near_zero = np.isclose(x, 0)\n    x[near_zero] = np.inf\n    x[~near_zero] = 1 / x[~near_zero]\n    return x\n\n\n# the function \"1/x\" is its own inverse\ninverse = one_over\n\n\nsecax = ax.secondary_xaxis('top', functions=(one_over, inverse))\nsecax.set_xlabel('period [s]')\nplt.show()\n\n# %%\n# Sometime we want to relate the axes in a transform that is ad-hoc from the data, and\n# is derived empirically. Or, one axis could be a complicated nonlinear function of the\n# other. In these cases we can set the forward and inverse transform functions to be\n# linear interpolations from the one set of independent variables to the other.\n#\n# .. note::\n#\n#   In order to properly handle the data margins, the mapping functions\n#   (``forward`` and ``inverse`` in this example) need to be defined beyond the\n#   nominal plot limits. This condition can be enforced by extending the\n#   interpolation beyond the plotted values, both to the left and the right,\n#   see ``x1n`` and ``x2n`` below.\n\nfig, ax = plt.subplots(layout='constrained')\nx1_vals = np.arange(2, 11, 0.4)\n# second independent variable is a nonlinear function of the other.\nx2_vals = x1_vals ** 2\nydata = 50.0 + 20 * np.random.randn(len(x1_vals))\nax.plot(x1_vals, ydata, label='Plotted data')\nax.plot(x1_vals, x2_vals, label=r'$x_2 = x_1^2$')\nax.set_xlabel(r'$x_1$')\nax.legend()\n\n# the forward and inverse functions must be defined on the complete visible axis range\nx1n = np.linspace(0, 20, 201)\nx2n = x1n**2\n\n\ndef forward(x):\n    return np.interp(x, x1n, x2n)\n\n\ndef inverse(x):\n    return np.interp(x, x2n, x1n)\n\n# use axvline to prove that the derived secondary axis is correctly plotted\nax.axvline(np.sqrt(40), color=\"grey\", ls=\"--\")\nax.axvline(10, color=\"grey\", ls=\"--\")\nsecax = ax.secondary_xaxis('top', functions=(forward, inverse))\nsecax.set_xticks([10, 20, 40, 60, 80, 100])\nsecax.set_xlabel(r'$x_2$')\n\nplt.show()\n\n# %%\n# A final example translates np.datetime64 to yearday on the x axis and\n# from Celsius to Fahrenheit on the y axis.  Note the addition of a\n# third y axis, and that it can be placed using a float for the\n# location argument\n\ndates = [datetime.datetime(2018, 1, 1) + datetime.timedelta(hours=k * 6)\n         for k in range(240)]\ntemperature = np.random.randn(len(dates)) * 4 + 6.7\nfig, ax = plt.subplots(layout='constrained')\n\nax.plot(dates, temperature)\nax.set_ylabel(r'$T\\ [^oC]$')\nax.xaxis.set_tick_params(rotation=70)\n\n\ndef date2yday(x):\n    \"\"\"Convert matplotlib datenum to days since 2018-01-01.\"\"\"\n    y = x - mdates.date2num(datetime.datetime(2018, 1, 1))\n    return y\n\n\ndef yday2date(x):\n    \"\"\"Return a matplotlib datenum for *x* days after 2018-01-01.\"\"\"\n    y = x + mdates.date2num(datetime.datetime(2018, 1, 1))\n    return y\n\n\nsecax_x = ax.secondary_xaxis('top', functions=(date2yday, yday2date))\nsecax_x.set_xlabel('yday [2018]')\n\n\ndef celsius_to_fahrenheit(x):\n    return x * 1.8 + 32\n\n\ndef fahrenheit_to_celsius(x):\n    return (x - 32) / 1.8\n\n\nsecax_y = ax.secondary_yaxis(\n    'right', functions=(celsius_to_fahrenheit, fahrenheit_to_celsius))\nsecax_y.set_ylabel(r'$T\\ [^oF]$')\n\n\ndef celsius_to_anomaly(x):\n    return (x - np.mean(temperature))\n\n\ndef anomaly_to_celsius(x):\n    return (x + np.mean(temperature))\n\n\n# use of a float for the position:\nsecax_y2 = ax.secondary_yaxis(\n    1.2, functions=(celsius_to_anomaly, anomaly_to_celsius))\nsecax_y2.set_ylabel(r'$T - \\overline{T}\\ [^oC]$')\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.secondary_xaxis`\n#    - `matplotlib.axes.Axes.secondary_yaxis`\n#\n# .. tags::\n#\n#    component: axis\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "share_axis_lims_views.py",
      "title": "Share Axis Lims Views",
      "code": "\"\"\"\n===========================\nShare axis limits and views\n===========================\n\nIt's common to make two or more plots which share an axis, e.g., two subplots\nwith time as a common axis.  When you pan and zoom around on one, you want the\nother to move around with you.  To facilitate this, matplotlib Axes support a\n``sharex`` and ``sharey`` attribute.  When you create a `~.pyplot.subplot` or\n`~.pyplot.axes`, you can pass in a keyword indicating what Axes you want to\nshare with.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0, 10, 0.01)\n\nax1 = plt.subplot(211)\nax1.plot(t, np.sin(2*np.pi*t))\n\nax2 = plt.subplot(212, sharex=ax1)\nax2.plot(t, np.sin(4*np.pi*t))\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: axis\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "shared_axis_demo.py",
      "title": "Shared Axis Demo",
      "code": "\"\"\"\n===========\nShared axis\n===========\n\nYou can share the x- or y-axis limits for one axis with another by\npassing an `~.axes.Axes` instance as a *sharex* or *sharey* keyword argument.\n\nChanging the axis limits on one Axes will be reflected automatically\nin the other, and vice-versa, so when you navigate with the toolbar\nthe Axes will follow each other on their shared axis.  Ditto for\nchanges in the axis scaling (e.g., log vs. linear).  However, it is\npossible to have differences in tick labeling, e.g., you can selectively\nturn off the tick labels on one Axes.\n\nThe example below shows how to customize the tick labels on the\nvarious axes.  Shared axes share the tick locator, tick formatter,\nview limits, and transformation (e.g., log, linear).  But the ticklabels\nthemselves do not share properties.  This is a feature and not a bug,\nbecause you may want to make the tick labels smaller on the upper\naxes, e.g., in the example below.\n\nIf you want to turn off the ticklabels for a given Axes (e.g., on\nsubplot(211) or subplot(212)), you cannot do the standard trick::\n\n   setp(ax2, xticklabels=[])\n\nbecause this changes the tick Formatter, which is shared among all\nAxes.  But you can alter the visibility of the labels, which is a\nproperty::\n\n  setp(ax2.get_xticklabels(), visible=False)\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.01, 5.0, 0.01)\ns1 = np.sin(2 * np.pi * t)\ns2 = np.exp(-t)\ns3 = np.sin(4 * np.pi * t)\n\nax1 = plt.subplot(311)\nplt.plot(t, s1)\nplt.tick_params('x', labelsize=6)\n\n# share x only\nax2 = plt.subplot(312, sharex=ax1)\nplt.plot(t, s2)\n# make these tick labels invisible\nplt.tick_params('x', labelbottom=False)\n\n# share x and y\nax3 = plt.subplot(313, sharex=ax1, sharey=ax1)\nplt.plot(t, s3)\nplt.xlim(0.01, 5.0)\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: axis\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "subfigures.py",
      "title": "Subfigures",
      "code": "\"\"\"\n=================\nFigure subfigures\n=================\n\nSometimes it is desirable to have a figure with two different layouts in it.\nThis can be achieved with\n:doc:`nested gridspecs</gallery/subplots_axes_and_figures/gridspec_nested>`,\nbut having a virtual figure with its own artists is helpful, so\nMatplotlib also has \"subfigures\", accessed by calling\n`matplotlib.figure.Figure.add_subfigure` in a way that is analogous to\n`matplotlib.figure.Figure.add_subplot`, or\n`matplotlib.figure.Figure.subfigures` to make an array of subfigures.  Note\nthat subfigures can also have their own child subfigures.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef example_plot(ax, fontsize=12, hide_labels=False):\n    pc = ax.pcolormesh(np.random.randn(30, 30), vmin=-2.5, vmax=2.5)\n    if not hide_labels:\n        ax.set_xlabel('x-label', fontsize=fontsize)\n        ax.set_ylabel('y-label', fontsize=fontsize)\n        ax.set_title('Title', fontsize=fontsize)\n    return pc\n\nnp.random.seed(19680808)\n# gridspec inside gridspec\nfig = plt.figure(layout='constrained', figsize=(10, 4))\nsubfigs = fig.subfigures(1, 2, wspace=0.07)\n\naxsLeft = subfigs[0].subplots(1, 2, sharey=True)\nsubfigs[0].set_facecolor('0.75')\nfor ax in axsLeft:\n    pc = example_plot(ax)\nsubfigs[0].suptitle('Left plots', fontsize='x-large')\nsubfigs[0].colorbar(pc, shrink=0.6, ax=axsLeft, location='bottom')\n\naxsRight = subfigs[1].subplots(3, 1, sharex=True)\nfor nn, ax in enumerate(axsRight):\n    pc = example_plot(ax, hide_labels=True)\n    if nn == 2:\n        ax.set_xlabel('xlabel')\n    if nn == 1:\n        ax.set_ylabel('ylabel')\n\nsubfigs[1].set_facecolor('0.85')\nsubfigs[1].colorbar(pc, shrink=0.6, ax=axsRight)\nsubfigs[1].suptitle('Right plots', fontsize='x-large')\n\nfig.suptitle('Figure suptitle', fontsize='xx-large')\n\nplt.show()\n\n# %%\n# It is possible to mix subplots and subfigures using\n# `matplotlib.figure.Figure.add_subfigure`.  This requires getting\n# the gridspec that the subplots are laid out on.\n\nfig, axs = plt.subplots(2, 3, layout='constrained', figsize=(10, 4))\ngridspec = axs[0, 0].get_subplotspec().get_gridspec()\n\n# clear the left column for the subfigure:\nfor a in axs[:, 0]:\n    a.remove()\n\n# plot data in remaining Axes:\nfor a in axs[:, 1:].flat:\n    a.plot(np.arange(10))\n\n# make the subfigure in the empty gridspec slots:\nsubfig = fig.add_subfigure(gridspec[:, 0])\n\naxsLeft = subfig.subplots(1, 2, sharey=True)\nsubfig.set_facecolor('0.75')\nfor ax in axsLeft:\n    pc = example_plot(ax)\nsubfig.suptitle('Left plots', fontsize='x-large')\nsubfig.colorbar(pc, shrink=0.6, ax=axsLeft, location='bottom')\n\nfig.suptitle('Figure suptitle', fontsize='xx-large')\nplt.show()\n\n# %%\n# Subfigures can have different widths and heights.  This is exactly the\n# same example as the first example, but *width_ratios* has been changed:\n\nfig = plt.figure(layout='constrained', figsize=(10, 4))\nsubfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[2, 1])\n\naxsLeft = subfigs[0].subplots(1, 2, sharey=True)\nsubfigs[0].set_facecolor('0.75')\nfor ax in axsLeft:\n    pc = example_plot(ax)\nsubfigs[0].suptitle('Left plots', fontsize='x-large')\nsubfigs[0].colorbar(pc, shrink=0.6, ax=axsLeft, location='bottom')\n\naxsRight = subfigs[1].subplots(3, 1, sharex=True)\nfor nn, ax in enumerate(axsRight):\n    pc = example_plot(ax, hide_labels=True)\n    if nn == 2:\n        ax.set_xlabel('xlabel')\n    if nn == 1:\n        ax.set_ylabel('ylabel')\n\nsubfigs[1].set_facecolor('0.85')\nsubfigs[1].colorbar(pc, shrink=0.6, ax=axsRight)\nsubfigs[1].suptitle('Right plots', fontsize='x-large')\n\nfig.suptitle('Figure suptitle', fontsize='xx-large')\n\nplt.show()\n\n# %%\n# Subfigures can be also be nested:\n\nfig = plt.figure(layout='constrained', figsize=(10, 8))\n\nfig.suptitle('fig')\n\nsubfigs = fig.subfigures(1, 2, wspace=0.07)\n\nsubfigs[0].set_facecolor('coral')\nsubfigs[0].suptitle('subfigs[0]')\n\nsubfigs[1].set_facecolor('coral')\nsubfigs[1].suptitle('subfigs[1]')\n\nsubfigsnest = subfigs[0].subfigures(2, 1, height_ratios=[1, 1.4])\nsubfigsnest[0].suptitle('subfigsnest[0]')\nsubfigsnest[0].set_facecolor('r')\naxsnest0 = subfigsnest[0].subplots(1, 2, sharey=True)\nfor nn, ax in enumerate(axsnest0):\n    pc = example_plot(ax, hide_labels=True)\nsubfigsnest[0].colorbar(pc, ax=axsnest0)\n\nsubfigsnest[1].suptitle('subfigsnest[1]')\nsubfigsnest[1].set_facecolor('g')\naxsnest1 = subfigsnest[1].subplots(3, 1, sharex=True)\n\naxsRight = subfigs[1].subplots(2, 2)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: figure\n#    plot-type: pcolormesh\n#    level: intermediate\n"
    },
    {
      "filename": "subplot.py",
      "title": "Subplot",
      "code": "\"\"\"\n=================\nMultiple subplots\n=================\n\nSimple demo with multiple subplots.\n\nFor more options, see :doc:`/gallery/subplots_axes_and_figures/subplots_demo`.\n\n.. redirect-from:: /gallery/subplots_axes_and_figures/subplot_demo\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create some fake data.\nx1 = np.linspace(0.0, 5.0)\ny1 = np.cos(2 * np.pi * x1) * np.exp(-x1)\nx2 = np.linspace(0.0, 2.0)\ny2 = np.cos(2 * np.pi * x2)\n\n# %%\n# `~.pyplot.subplots()` is the recommended method to generate simple subplot\n# arrangements:\n\nfig, (ax1, ax2) = plt.subplots(2, 1)\nfig.suptitle('A tale of 2 subplots')\n\nax1.plot(x1, y1, 'o-')\nax1.set_ylabel('Damped oscillation')\n\nax2.plot(x2, y2, '.-')\nax2.set_xlabel('time (s)')\nax2.set_ylabel('Undamped')\n\nplt.show()\n\n# %%\n# Subplots can also be generated one at a time using `~.pyplot.subplot()`:\n\nplt.subplot(2, 1, 1)\nplt.plot(x1, y1, 'o-')\nplt.title('A tale of 2 subplots')\nplt.ylabel('Damped oscillation')\n\nplt.subplot(2, 1, 2)\nplt.plot(x2, y2, '.-')\nplt.xlabel('time (s)')\nplt.ylabel('Undamped')\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: subplot\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "subplot2grid.py",
      "title": "Subplot2Grid",
      "code": "\"\"\"\n============\nsubplot2grid\n============\n\nThis example demonstrates the use of `.pyplot.subplot2grid` to generate\nsubplots.  Using `.GridSpec`, as demonstrated in\n:doc:`/gallery/subplots_axes_and_figures/gridspec_customization` is\ngenerally preferred.\n\n.. redirect-from:: /gallery/userdemo/demo_gridspec01\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef annotate_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\n\nfig = plt.figure()\nax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3)\nax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)\nax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)\nax4 = plt.subplot2grid((3, 3), (2, 0))\nax5 = plt.subplot2grid((3, 3), (2, 1))\n\nannotate_axes(fig)\n\nplt.show()\n"
    },
    {
      "filename": "subplots_adjust.py",
      "title": "Subplots Adjust",
      "code": "\"\"\"\n=============================\nSubplots spacings and margins\n=============================\n\nAdjusting the spacing of margins and subplots using `.pyplot.subplots_adjust`.\n\n.. note::\n   There is also a tool window to adjust the margins and spacings of displayed\n   figures interactively.  It can be opened via the toolbar or by calling\n   `.pyplot.subplot_tool`.\n\n.. redirect-from:: /gallery/subplots_axes_and_figures/subplot_toolbar\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nplt.subplot(211)\nplt.imshow(np.random.random((100, 100)))\nplt.subplot(212)\nplt.imshow(np.random.random((100, 100)))\n\nplt.subplots_adjust(bottom=0.1, right=0.8, top=0.9)\ncax = plt.axes((0.85, 0.1, 0.075, 0.8))\nplt.colorbar(cax=cax)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: subplot\n#    plot-type: imshow\n#    level: beginner\n"
    },
    {
      "filename": "subplots_demo.py",
      "title": "Subplots Demo",
      "code": "\"\"\"\n===============================================\nCreate multiple subplots using ``plt.subplots``\n===============================================\n\n`.pyplot.subplots` creates a figure and a grid of subplots with a single call,\nwhile providing reasonable control over how the individual plots are created.\nFor more advanced use cases you can use `.GridSpec` for a more general subplot\nlayout or `.Figure.add_subplot` for adding subplots at arbitrary locations\nwithin the figure.\n\"\"\"\n\n# sphinx_gallery_thumbnail_number = 11\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Some example data to display\nx = np.linspace(0, 2 * np.pi, 400)\ny = np.sin(x ** 2)\n\n# %%\n# A figure with just one subplot\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# ``subplots()`` without arguments returns a `.Figure` and a single\n# `~.axes.Axes`.\n#\n# This is actually the simplest and recommended way of creating a single\n# Figure and Axes.\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_title('A single plot')\n\n# %%\n# Stacking subplots in one direction\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# The first two optional arguments of `.pyplot.subplots` define the number of\n# rows and columns of the subplot grid.\n#\n# When stacking in one direction only, the returned ``axs`` is a 1D numpy array\n# containing the list of created Axes.\n\nfig, axs = plt.subplots(2)\nfig.suptitle('Vertically stacked subplots')\naxs[0].plot(x, y)\naxs[1].plot(x, -y)\n\n# %%\n# If you are creating just a few Axes, it's handy to unpack them immediately to\n# dedicated variables for each Axes. That way, we can use ``ax1`` instead of\n# the more verbose ``axs[0]``.\n\nfig, (ax1, ax2) = plt.subplots(2)\nfig.suptitle('Vertically stacked subplots')\nax1.plot(x, y)\nax2.plot(x, -y)\n\n# %%\n# To obtain side-by-side subplots, pass parameters ``1, 2`` for one row and two\n# columns.\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.suptitle('Horizontally stacked subplots')\nax1.plot(x, y)\nax2.plot(x, -y)\n\n# %%\n# Stacking subplots in two directions\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n#\n# When stacking in two directions, the returned ``axs`` is a 2D NumPy array.\n#\n# If you have to set parameters for each subplot it's handy to iterate over\n# all subplots in a 2D grid using ``for ax in axs.flat:``.\n\nfig, axs = plt.subplots(2, 2)\naxs[0, 0].plot(x, y)\naxs[0, 0].set_title('Axis [0, 0]')\naxs[0, 1].plot(x, y, 'tab:orange')\naxs[0, 1].set_title('Axis [0, 1]')\naxs[1, 0].plot(x, -y, 'tab:green')\naxs[1, 0].set_title('Axis [1, 0]')\naxs[1, 1].plot(x, -y, 'tab:red')\naxs[1, 1].set_title('Axis [1, 1]')\n\nfor ax in axs.flat:\n    ax.set(xlabel='x-label', ylabel='y-label')\n\n# Hide x labels and tick labels for top plots and y ticks for right plots.\nfor ax in axs.flat:\n    ax.label_outer()\n\n# %%\n# You can use tuple-unpacking also in 2D to assign all subplots to dedicated\n# variables:\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nfig.suptitle('Sharing x per column, y per row')\nax1.plot(x, y)\nax2.plot(x, y**2, 'tab:orange')\nax3.plot(x, -y, 'tab:green')\nax4.plot(x, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\n# %%\n# Sharing axes\n# \"\"\"\"\"\"\"\"\"\"\"\"\n#\n# By default, each Axes is scaled individually. Thus, if the ranges are\n# different the tick values of the subplots do not align.\n\nfig, (ax1, ax2) = plt.subplots(2)\nfig.suptitle('Axes values are scaled individually by default')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\n# %%\n# You can use *sharex* or *sharey* to align the horizontal or vertical axis.\n\nfig, (ax1, ax2) = plt.subplots(2, sharex=True)\nfig.suptitle('Aligning x-axis using sharex')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\n# %%\n# Setting *sharex* or *sharey* to ``True`` enables global sharing across the\n# whole grid, i.e. also the y-axes of vertically stacked subplots have the\n# same scale when using ``sharey=True``.\n\nfig, axs = plt.subplots(3, sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\n# %%\n# For subplots that are sharing axes one set of tick labels is enough. Tick\n# labels of inner Axes are automatically removed by *sharex* and *sharey*.\n# Still there remains an unused empty space between the subplots.\n#\n# To precisely control the positioning of the subplots, one can explicitly\n# create a `.GridSpec` with `.Figure.add_gridspec`, and then call its\n# `~.GridSpecBase.subplots` method.  For example, we can reduce the height\n# between vertical subplots using ``add_gridspec(hspace=0)``.\n#\n# `.label_outer` is a handy method to remove labels and ticks from subplots\n# that are not at the edge of the grid.\n\nfig = plt.figure()\ngs = fig.add_gridspec(3, hspace=0)\naxs = gs.subplots(sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\n# Hide x labels and tick labels for all but bottom plot.\nfor ax in axs:\n    ax.label_outer()\n\n# %%\n# Apart from ``True`` and ``False``, both *sharex* and *sharey* accept the\n# values 'row' and 'col' to share the values only per row or column.\n\nfig = plt.figure()\ngs = fig.add_gridspec(2, 2, hspace=0, wspace=0)\n(ax1, ax2), (ax3, ax4) = gs.subplots(sharex='col', sharey='row')\nfig.suptitle('Sharing x per column, y per row')\nax1.plot(x, y)\nax2.plot(x, y**2, 'tab:orange')\nax3.plot(x + 1, -y, 'tab:green')\nax4.plot(x + 2, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\n# %%\n# If you want a more complex sharing structure, you can first create the\n# grid of Axes with no sharing, and then call `.axes.Axes.sharex` or\n# `.axes.Axes.sharey` to add sharing info a posteriori.\n\nfig, axs = plt.subplots(2, 2)\naxs[0, 0].plot(x, y)\naxs[0, 0].set_title(\"main\")\naxs[1, 0].plot(x, y**2)\naxs[1, 0].set_title(\"shares x with main\")\naxs[1, 0].sharex(axs[0, 0])\naxs[0, 1].plot(x + 1, y + 1)\naxs[0, 1].set_title(\"unrelated\")\naxs[1, 1].plot(x + 2, y + 2)\naxs[1, 1].set_title(\"also unrelated\")\nfig.tight_layout()\n\n# %%\n# Polar Axes\n# \"\"\"\"\"\"\"\"\"\"\n#\n# The parameter *subplot_kw* of `.pyplot.subplots` controls the subplot\n# properties (see also `.Figure.add_subplot`). In particular, this can be used\n# to create a grid of polar Axes.\n\nfig, (ax1, ax2) = plt.subplots(1, 2, subplot_kw=dict(projection='polar'))\nax1.plot(x, y)\nax2.plot(x, y ** 2)\n\nplt.show()\n\n# %%\n# .. tags::\n#\n#    component: subplot,\n#    component: axes,\n#    component: axis\n#    plot-type: line,\n#    plot-type: polar\n#    level: beginner\n#    purpose: showcase\n"
    },
    {
      "filename": "two_scales.py",
      "title": "Two Scales",
      "code": "\"\"\"\n===========================\nPlots with different scales\n===========================\n\nTwo plots on the same Axes with different left and right scales.\n\nThe trick is to use *two different Axes* that share the same *x* axis.\nYou can use separate `matplotlib.ticker` formatters and locators as\ndesired since the two Axes are independent.\n\nSuch Axes are generated by calling the `.Axes.twinx` method. Likewise,\n`.Axes.twiny` is available to generate Axes that share a *y* axis but\nhave different top and bottom scales.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create some mock data\nt = np.arange(0.01, 10.0, 0.01)\ndata1 = np.exp(t)\ndata2 = np.sin(2 * np.pi * t)\n\nfig, ax1 = plt.subplots()\n\ncolor = 'tab:red'\nax1.set_xlabel('time (s)')\nax1.set_ylabel('exp', color=color)\nax1.plot(t, data1, color=color)\nax1.tick_params(axis='y', labelcolor=color)\n\nax2 = ax1.twinx()  # instantiate a second Axes that shares the same x-axis\n\ncolor = 'tab:blue'\nax2.set_ylabel('sin', color=color)  # we already handled the x-label with ax1\nax2.plot(t, data2, color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfig.tight_layout()  # otherwise the right y-label is slightly clipped\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.twinx` / `matplotlib.pyplot.twinx`\n#    - `matplotlib.axes.Axes.twiny` / `matplotlib.pyplot.twiny`\n#    - `matplotlib.axes.Axes.tick_params` / `matplotlib.pyplot.tick_params`\n#\n# .. tags::\n#\n#    component: axes\n#    plot-type: line\n#    level: beginner\n"
    },
    {
      "filename": "zoom_inset_axes.py",
      "title": "Zoom Inset Axes",
      "code": "\"\"\"\n======================\nZoom region inset Axes\n======================\n\nExample of an inset Axes and a rectangle showing where the zoom is located.\n\"\"\"\n\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom matplotlib import pyplot as plt\n\nfig, ax = plt.subplots()\n\n# make data\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\nZ2 = np.zeros((150, 150))\nny, nx = Z.shape\nZ2[30:30+ny, 30:30+nx] = Z\nextent = (-3, 4, -4, 3)\n\nax.imshow(Z2, extent=extent, origin=\"lower\")\n\n# inset Axes....\nx1, x2, y1, y2 = -1.5, -0.9, -2.5, -1.9  # subregion of the original image\naxins = ax.inset_axes(\n    [0.5, 0.5, 0.47, 0.47],\n    xlim=(x1, x2), ylim=(y1, y2), xticklabels=[], yticklabels=[])\naxins.imshow(Z2, extent=extent, origin=\"lower\")\n\nax.indicate_inset_zoom(axins, edgecolor=\"black\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.inset_axes`\n#    - `matplotlib.axes.Axes.indicate_inset_zoom`\n#    - `matplotlib.axes.Axes.imshow`\n#\n# .. tags::\n#\n#    component: axes\n#    plot-type: imshow\n#    level: intermediate\n"
    }
  ],
  "text_labels_and_annotations": [
    {
      "filename": "accented_text.py",
      "title": "Accented Text",
      "code": "r\"\"\"\n=============\nAccented text\n=============\n\nMatplotlib supports accented characters via TeX mathtext or Unicode.\n\nUsing mathtext, the following accents are provided: \\\\hat, \\\\breve, \\\\grave,\n\\\\bar, \\\\acute, \\\\tilde, \\\\vec, \\\\dot, \\\\ddot.  All of them have the same\nsyntax, e.g. \\\\bar{o} yields \"o overbar\", \\\\ddot{o} yields \"o umlaut\".\nShortcuts such as \\\\\"o \\\\'e \\\\`e \\\\~n \\\\.x \\\\^y are also supported.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n# Mathtext demo\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_title(r'$\\ddot{o}\\acute{e}\\grave{e}\\hat{O}'\n             r'\\breve{i}\\bar{A}\\tilde{n}\\vec{q}$', fontsize=20)\n\n# Shorthand is also supported and curly braces are optional\nax.set_xlabel(r\"\"\"$\\\"o\\ddot o \\'e\\`e\\~n\\.x\\^y$\"\"\", fontsize=20)\nax.text(4, 0.5, r\"$F=m\\ddot{x}$\")\nfig.tight_layout()\n\n# %%\n# You can also use Unicode characters directly in strings.\nfig, ax = plt.subplots()\nax.set_title(\"GISCARD CHAHUT\u00c9 \u00c0 L'ASSEMBL\u00c9E\")\nax.set_xlabel(\"LE COUP DE D\u00c9 DE DE GAULLE\")\nax.set_ylabel('Andr\u00e9 was here!')\nax.text(0.2, 0.8, 'Institut f\u00fcr Festk\u00f6rperphysik', rotation=45)\nax.text(0.4, 0.2, 'AVA (check kerning)')\n\nplt.show()\n"
    },
    {
      "filename": "align_ylabels.py",
      "title": "Align Ylabels",
      "code": "\"\"\"\n==============\nAlign y-labels\n==============\n\nTwo methods are shown here, one using a short call to `.Figure.align_ylabels`\nand the second a manual way to align the labels.\n\n.. redirect-from:: /gallery/pyplots/align_ylabels\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef make_plot(axs):\n    box = dict(facecolor='yellow', pad=5, alpha=0.2)\n\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n    ax1 = axs[0, 0]\n    ax1.plot(2000*np.random.rand(10))\n    ax1.set_title('ylabels not aligned')\n    ax1.set_ylabel('misaligned 1', bbox=box)\n    ax1.set_ylim(0, 2000)\n\n    ax3 = axs[1, 0]\n    ax3.set_ylabel('misaligned 2', bbox=box)\n    ax3.plot(np.random.rand(10))\n\n    ax2 = axs[0, 1]\n    ax2.set_title('ylabels aligned')\n    ax2.plot(2000*np.random.rand(10))\n    ax2.set_ylabel('aligned 1', bbox=box)\n    ax2.set_ylim(0, 2000)\n\n    ax4 = axs[1, 1]\n    ax4.plot(np.random.rand(10))\n    ax4.set_ylabel('aligned 2', bbox=box)\n\n\n# Plot 1:\nfig, axs = plt.subplots(2, 2)\nfig.subplots_adjust(left=0.2, wspace=0.6)\nmake_plot(axs)\n\n# just align the last column of Axes:\nfig.align_ylabels(axs[:, 1])\nplt.show()\n\n# %%\n#\n# .. seealso::\n#     `.Figure.align_ylabels` and `.Figure.align_labels` for a direct method\n#     of doing the same thing.\n#     Also :doc:`/gallery/subplots_axes_and_figures/align_labels_demo`\n#\n#\n# Or we can manually align the axis labels between subplots manually using the\n# `~.Axis.set_label_coords` method of the y-axis object.  Note this requires\n# we know a good offset value which is hardcoded.\n\nfig, axs = plt.subplots(2, 2)\nfig.subplots_adjust(left=0.2, wspace=0.6)\n\nmake_plot(axs)\n\nlabelx = -0.3  # axes coords\n\nfor j in range(2):\n    axs[j, 1].yaxis.set_label_coords(labelx, 0.5)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure.align_ylabels`\n#    - `matplotlib.axis.Axis.set_label_coords`\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.axes.Axes.set_title`\n#    - `matplotlib.axes.Axes.set_ylabel`\n#    - `matplotlib.axes.Axes.set_ylim`\n"
    },
    {
      "filename": "angle_annotation.py",
      "title": "Angle Annotation",
      "code": "\"\"\"\n===========================\nScale invariant angle label\n===========================\n\nThis example shows how to create a scale invariant angle annotation. It is\noften useful to mark angles between lines or inside shapes with a circular arc.\nWhile Matplotlib provides an `~.patches.Arc`, an inherent problem when directly\nusing it for such purposes is that an arc being circular in data space is not\nnecessarily circular in display space. Also, the arc's radius is often best\ndefined in a coordinate system which is independent of the actual data\ncoordinates - at least if you want to be able to freely zoom into your plot\nwithout the annotation growing to infinity.\n\nThis calls for a solution where the arc's center is defined in data space, but\nits radius in a physical unit like points or pixels, or as a ratio of the Axes\ndimension. The following ``AngleAnnotation`` class provides such solution.\n\nThe example below serves two purposes:\n\n* It provides a ready-to-use solution for the problem of easily drawing angles\n  in graphs.\n* It shows how to subclass a Matplotlib artist to enhance its functionality, as\n  well as giving a hands-on example on how to use Matplotlib's :ref:`transform\n  system <transforms_tutorial>`.\n\nIf mainly interested in the former, you may copy the below class and jump to\nthe :ref:`angle-annotation-usage` section.\n\"\"\"\n\n# %%\n# AngleAnnotation class\n# ---------------------\n# The essential idea here is to subclass `~.patches.Arc` and set its transform\n# to the `~.transforms.IdentityTransform`, making the parameters of the arc\n# defined in pixel space.\n# We then override the ``Arc``'s attributes ``_center``, ``theta1``,\n# ``theta2``, ``width`` and ``height`` and make them properties, coupling to\n# internal methods that calculate the respective parameters each time the\n# attribute is accessed and thereby ensuring that the arc in pixel space stays\n# synchronized with the input points and size.\n# For example, each time the arc's drawing method would query its ``_center``\n# attribute, instead of receiving the same number all over again, it will\n# instead receive the result of the ``get_center_in_pixels`` method we defined\n# in the subclass. This method transforms the center in data coordinates to\n# pixels via the Axes transform ``ax.transData``. The size and the angles are\n# calculated in a similar fashion, such that the arc changes its shape\n# automatically when e.g. zooming or panning interactively.\n#\n# The functionality of this class allows to annotate the arc with a text. This\n# text is a `~.text.Annotation` stored in an attribute ``text``. Since the\n# arc's position and radius are defined only at draw time, we need to update\n# the text's position accordingly. This is done by reimplementing the ``Arc``'s\n# ``draw()`` method to let it call an updating method for the text.\n#\n# The arc and the text will be added to the provided Axes at instantiation: it\n# is hence not strictly necessary to keep a reference to it.\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Arc\nfrom matplotlib.transforms import Bbox, IdentityTransform, TransformedBbox\n\n\nclass AngleAnnotation(Arc):\n    \"\"\"\n    Draws an arc between two vectors which appears circular in display space.\n    \"\"\"\n    def __init__(self, xy, p1, p2, size=75, unit=\"points\", ax=None,\n                 text=\"\", textposition=\"inside\", text_kw=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy, p1, p2 : tuple or array of two floats\n            Center position and two points. Angle annotation is drawn between\n            the two vectors connecting *p1* and *p2* with *xy*, respectively.\n            Units are data coordinates.\n\n        size : float\n            Diameter of the angle annotation in units specified by *unit*.\n\n        unit : str\n            One of the following strings to specify the unit of *size*:\n\n            * \"pixels\": pixels\n            * \"points\": points, use points instead of pixels to not have a\n              dependence on the DPI\n            * \"axes width\", \"axes height\": relative units of Axes width, height\n            * \"axes min\", \"axes max\": minimum or maximum of relative Axes\n              width, height\n\n        ax : `matplotlib.axes.Axes`\n            The Axes to add the angle annotation to.\n\n        text : str\n            The text to mark the angle with.\n\n        textposition : {\"inside\", \"outside\", \"edge\"}\n            Whether to show the text in- or outside the arc. \"edge\" can be used\n            for custom positions anchored at the arc's edge.\n\n        text_kw : dict\n            Dictionary of arguments passed to the Annotation.\n\n        **kwargs\n            Further parameters are passed to `matplotlib.patches.Arc`. Use this\n            to specify, color, linewidth etc. of the arc.\n\n        \"\"\"\n        self.ax = ax or plt.gca()\n        self._xydata = xy  # in data coordinates\n        self.vec1 = p1\n        self.vec2 = p2\n        self.size = size\n        self.unit = unit\n        self.textposition = textposition\n\n        super().__init__(self._xydata, size, size, angle=0.0,\n                         theta1=self.theta1, theta2=self.theta2, **kwargs)\n\n        self.set_transform(IdentityTransform())\n        self.ax.add_patch(self)\n\n        self.kw = dict(ha=\"center\", va=\"center\",\n                       xycoords=IdentityTransform(),\n                       xytext=(0, 0), textcoords=\"offset points\",\n                       annotation_clip=True)\n        self.kw.update(text_kw or {})\n        self.text = ax.annotate(text, xy=self._center, **self.kw)\n\n    def get_size(self):\n        factor = 1.\n        if self.unit == \"points\":\n            factor = self.ax.figure.dpi / 72.\n        elif self.unit[:4] == \"axes\":\n            b = TransformedBbox(Bbox.unit(), self.ax.transAxes)\n            dic = {\"max\": max(b.width, b.height),\n                   \"min\": min(b.width, b.height),\n                   \"width\": b.width, \"height\": b.height}\n            factor = dic[self.unit[5:]]\n        return self.size * factor\n\n    def set_size(self, size):\n        self.size = size\n\n    def get_center_in_pixels(self):\n        \"\"\"return center in pixels\"\"\"\n        return self.ax.transData.transform(self._xydata)\n\n    def set_center(self, xy):\n        \"\"\"set center in data coordinates\"\"\"\n        self._xydata = xy\n\n    def get_theta(self, vec):\n        vec_in_pixels = self.ax.transData.transform(vec) - self._center\n        return np.rad2deg(np.arctan2(vec_in_pixels[1], vec_in_pixels[0]))\n\n    def get_theta1(self):\n        return self.get_theta(self.vec1)\n\n    def get_theta2(self):\n        return self.get_theta(self.vec2)\n\n    def set_theta(self, angle):\n        pass\n\n    # Redefine attributes of the Arc to always give values in pixel space\n    _center = property(get_center_in_pixels, set_center)\n    theta1 = property(get_theta1, set_theta)\n    theta2 = property(get_theta2, set_theta)\n    width = property(get_size, set_size)\n    height = property(get_size, set_size)\n\n    # The following two methods are needed to update the text position.\n    def draw(self, renderer):\n        self.update_text()\n        super().draw(renderer)\n\n    def update_text(self):\n        c = self._center\n        s = self.get_size()\n        angle_span = (self.theta2 - self.theta1) % 360\n        angle = np.deg2rad(self.theta1 + angle_span / 2)\n        r = s / 2\n        if self.textposition == \"inside\":\n            r = s / np.interp(angle_span, [60, 90, 135, 180],\n                                          [3.3, 3.5, 3.8, 4])\n        self.text.xy = c + r * np.array([np.cos(angle), np.sin(angle)])\n        if self.textposition == \"outside\":\n            def R90(a, r, w, h):\n                if a < np.arctan(h/2/(r+w/2)):\n                    return np.sqrt((r+w/2)**2 + (np.tan(a)*(r+w/2))**2)\n                else:\n                    c = np.sqrt((w/2)**2+(h/2)**2)\n                    T = np.arcsin(c * np.cos(np.pi/2 - a + np.arcsin(h/2/c))/r)\n                    xy = r * np.array([np.cos(a + T), np.sin(a + T)])\n                    xy += np.array([w/2, h/2])\n                    return np.sqrt(np.sum(xy**2))\n\n            def R(a, r, w, h):\n                aa = (a % (np.pi/4))*((a % (np.pi/2)) <= np.pi/4) + \\\n                     (np.pi/4 - (a % (np.pi/4)))*((a % (np.pi/2)) >= np.pi/4)\n                return R90(aa, r, *[w, h][::int(np.sign(np.cos(2*a)))])\n\n            bbox = self.text.get_window_extent()\n            X = R(angle, r, bbox.width, bbox.height)\n            trans = self.ax.figure.dpi_scale_trans.inverted()\n            offs = trans.transform(((X-s/2), 0))[0] * 72\n            self.text.set_position([offs*np.cos(angle), offs*np.sin(angle)])\n\n\n# %%\n# .. _angle-annotation-usage:\n#\n# Usage\n# -----\n#\n# Required arguments to ``AngleAnnotation`` are the center of the arc, *xy*,\n# and two points, such that the arc spans between the two vectors connecting\n# *p1* and *p2* with *xy*, respectively. Those are given in data coordinates.\n# Further arguments are the *size* of the arc and its *unit*. Additionally, a\n# *text* can be specified, that will be drawn either in- or outside of the arc,\n# according to the value of *textposition*. Usage of those arguments is shown\n# below.\n\nfig, ax = plt.subplots()\nfig.canvas.draw()  # Need to draw the figure to define renderer\nax.set_title(\"AngleLabel example\")\n\n# Plot two crossing lines and label each angle between them with the above\n# ``AngleAnnotation`` tool.\ncenter = (4.5, 650)\np1 = [(2.5, 710), (6.0, 605)]\np2 = [(3.0, 275), (5.5, 900)]\nline1, = ax.plot(*zip(*p1))\nline2, = ax.plot(*zip(*p2))\npoint, = ax.plot(*center, marker=\"o\")\n\nam1 = AngleAnnotation(center, p1[1], p2[1], ax=ax, size=75, text=r\"$\\alpha$\")\nam2 = AngleAnnotation(center, p2[1], p1[0], ax=ax, size=35, text=r\"$\\beta$\")\nam3 = AngleAnnotation(center, p1[0], p2[0], ax=ax, size=75, text=r\"$\\gamma$\")\nam4 = AngleAnnotation(center, p2[0], p1[1], ax=ax, size=35, text=r\"$\\theta$\")\n\n\n# Showcase some styling options for the angle arc, as well as the text.\np = [(6.0, 400), (5.3, 410), (5.6, 300)]\nax.plot(*zip(*p))\nam5 = AngleAnnotation(p[1], p[0], p[2], ax=ax, size=40, text=r\"$\\Phi$\",\n                      linestyle=\"--\", color=\"gray\", textposition=\"outside\",\n                      text_kw=dict(fontsize=16, color=\"gray\"))\n\n\n# %%\n# ``AngleLabel`` options\n# ----------------------\n#\n# The *textposition* and *unit* keyword arguments may be used to modify the\n# location of the text label, as shown below:\n\n\n# Helper function to draw angle easily.\ndef plot_angle(ax, pos, angle, length=0.95, acol=\"C0\", **kwargs):\n    vec2 = np.array([np.cos(np.deg2rad(angle)), np.sin(np.deg2rad(angle))])\n    xy = np.c_[[length, 0], [0, 0], vec2*length].T + np.array(pos)\n    ax.plot(*xy.T, color=acol)\n    return AngleAnnotation(pos, xy[0], xy[2], ax=ax, **kwargs)\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, sharex=True)\nfig.suptitle(\"AngleLabel keyword arguments\")\nfig.canvas.draw()  # Need to draw the figure to define renderer\n\n# Showcase different text positions.\nax1.margins(y=0.4)\nax1.set_title(\"textposition\")\nkw = dict(size=75, unit=\"points\", text=r\"$60\u00b0$\")\n\nam6 = plot_angle(ax1, (2.0, 0), 60, textposition=\"inside\", **kw)\nam7 = plot_angle(ax1, (3.5, 0), 60, textposition=\"outside\", **kw)\nam8 = plot_angle(ax1, (5.0, 0), 60, textposition=\"edge\",\n                 text_kw=dict(bbox=dict(boxstyle=\"round\", fc=\"w\")), **kw)\nam9 = plot_angle(ax1, (6.5, 0), 60, textposition=\"edge\",\n                 text_kw=dict(xytext=(30, 20), arrowprops=dict(arrowstyle=\"->\",\n                              connectionstyle=\"arc3,rad=-0.2\")), **kw)\n\nfor x, text in zip([2.0, 3.5, 5.0, 6.5], ['\"inside\"', '\"outside\"', '\"edge\"',\n                                          '\"edge\", custom arrow']):\n    ax1.annotate(text, xy=(x, 0), xycoords=ax1.get_xaxis_transform(),\n                 bbox=dict(boxstyle=\"round\", fc=\"w\"), ha=\"left\", fontsize=8,\n                 annotation_clip=True)\n\n# Showcase different size units. The effect of this can best be observed\n# by interactively changing the figure size\nax2.margins(y=0.4)\nax2.set_title(\"unit\")\nkw = dict(text=r\"$60\u00b0$\", textposition=\"outside\")\n\nam10 = plot_angle(ax2, (2.0, 0), 60, size=50, unit=\"pixels\", **kw)\nam11 = plot_angle(ax2, (3.5, 0), 60, size=50, unit=\"points\", **kw)\nam12 = plot_angle(ax2, (5.0, 0), 60, size=0.25, unit=\"axes min\", **kw)\nam13 = plot_angle(ax2, (6.5, 0), 60, size=0.25, unit=\"axes max\", **kw)\n\nfor x, text in zip([2.0, 3.5, 5.0, 6.5], ['\"pixels\"', '\"points\"',\n                                          '\"axes min\"', '\"axes max\"']):\n    ax2.annotate(text, xy=(x, 0), xycoords=ax2.get_xaxis_transform(),\n                 bbox=dict(boxstyle=\"round\", fc=\"w\"), ha=\"left\", fontsize=8,\n                 annotation_clip=True)\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches.Arc`\n#    - `matplotlib.axes.Axes.annotate` / `matplotlib.pyplot.annotate`\n#    - `matplotlib.text.Annotation`\n#    - `matplotlib.transforms.IdentityTransform`\n#    - `matplotlib.transforms.TransformedBbox`\n#    - `matplotlib.transforms.Bbox`\n"
    },
    {
      "filename": "angles_on_bracket_arrows.py",
      "title": "Angles On Bracket Arrows",
      "code": "\"\"\"\n===================================\nAngle annotations on bracket arrows\n===================================\n\nThis example shows how to add angle annotations to bracket arrow styles\ncreated using `.FancyArrowPatch`. *angleA* and *angleB* are measured from a\nvertical line as positive (to the left) or negative (to the right). Blue\n`.FancyArrowPatch` arrows indicate the directions of *angleA* and *angleB*\nfrom the vertical and axes text annotate the angle sizes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import FancyArrowPatch\n\n\ndef get_point_of_rotated_vertical(origin, line_length, degrees):\n    \"\"\"Return xy coordinates of the vertical line end rotated by degrees.\"\"\"\n    rad = np.deg2rad(-degrees)\n    return [origin[0] + line_length * np.sin(rad),\n            origin[1] + line_length * np.cos(rad)]\n\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 6), ylim=(-1, 5))\nax.set_title(\"Orientation of the bracket arrows relative to angleA and angleB\")\n\nstyle = ']-['\nfor i, angle in enumerate([-40, 0, 60]):\n    y = 2*i\n    arrow_centers = ((1, y), (5, y))\n    vlines = ((1, y + 0.5), (5, y + 0.5))\n    anglesAB = (angle, -angle)\n    bracketstyle = f\"{style}, angleA={anglesAB[0]}, angleB={anglesAB[1]}\"\n    bracket = FancyArrowPatch(*arrow_centers, arrowstyle=bracketstyle,\n                              mutation_scale=42)\n    ax.add_patch(bracket)\n    ax.text(3, y + 0.05, bracketstyle, ha=\"center\", va=\"bottom\", fontsize=14)\n    ax.vlines([line[0] for line in vlines], [y, y], [line[1] for line in vlines],\n              linestyles=\"--\", color=\"C0\")\n    # Get the top coordinates for the drawn patches at A and B\n    patch_tops = [get_point_of_rotated_vertical(center, 0.5, angle)\n                  for center, angle in zip(arrow_centers, anglesAB)]\n    # Define the connection directions for the annotation arrows\n    connection_dirs = (1, -1) if angle > 0 else (-1, 1)\n    # Add arrows and annotation text\n    arrowstyle = \"Simple, tail_width=0.5, head_width=4, head_length=8\"\n    for vline, dir, patch_top, angle in zip(vlines, connection_dirs,\n                                            patch_tops, anglesAB):\n        kw = dict(connectionstyle=f\"arc3,rad={dir * 0.5}\",\n                  arrowstyle=arrowstyle, color=\"C0\")\n        ax.add_patch(FancyArrowPatch(vline, patch_top, **kw))\n        ax.text(vline[0] - dir * 0.15, y + 0.7, f'{angle}\u00b0', ha=\"center\",\n                va=\"center\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches.ArrowStyle`\n"
    },
    {
      "filename": "annotate_transform.py",
      "title": "Annotate Transform",
      "code": "\"\"\"\n==================\nAnnotate transform\n==================\n\nThis example shows how to use different coordinate systems for annotations.\nFor a complete overview of the annotation capabilities, also see the\n:ref:`annotation tutorial<annotations>`.\n\n.. redirect-from:: /gallery/pyplots/annotate_transform\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nxdata, ydata = 5, 0\nxdisplay, ydisplay = ax.transData.transform((xdata, ydata))\n\nbbox = dict(boxstyle=\"round\", fc=\"0.8\")\narrowprops = dict(\n    arrowstyle=\"->\",\n    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\")\n\noffset = 72\nax.annotate(\n    f'data = ({xdata:.1f}, {ydata:.1f})',\n    (xdata, ydata),\n    xytext=(-2*offset, offset), textcoords='offset points',\n    bbox=bbox, arrowprops=arrowprops)\nax.annotate(\n    f'display = ({xdisplay:.1f}, {ydisplay:.1f})',\n    xy=(xdisplay, ydisplay), xycoords='figure pixels',\n    xytext=(0.5*offset, -offset), textcoords='offset points',\n    bbox=bbox, arrowprops=arrowprops)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.transforms.Transform.transform`\n#    - `matplotlib.axes.Axes.annotate` / `matplotlib.pyplot.annotate`\n"
    },
    {
      "filename": "annotation_basic.py",
      "title": "Annotation Basic",
      "code": "\"\"\"\n=================\nAnnotating a plot\n=================\n\nThis example shows how to annotate a plot with an arrow pointing to provided\ncoordinates. We modify the defaults of the arrow, to \"shrink\" it.\n\nFor a complete overview of the annotation capabilities, also see the\n:ref:`annotation tutorial<annotations>`.\n\n.. redirect-from:: /gallery/pyplots/annotation_basic\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            )\nax.set_ylim(-2, 2)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.annotate` / `matplotlib.pyplot.annotate`\n"
    },
    {
      "filename": "annotation_demo.py",
      "title": "Annotation Demo",
      "code": "\"\"\"\n==============\nAnnotate plots\n==============\n\nThe following examples show ways to annotate plots in Matplotlib.\nThis includes highlighting specific points of interest and using various\nvisual tools to call attention to this point. For a more complete and in-depth\ndescription of the annotation and text tools in Matplotlib, see the\n:ref:`tutorial on annotation <annotations>`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse\nfrom matplotlib.text import OffsetFrom\n\n# %%\n# Specifying text points and annotation points\n# --------------------------------------------\n#\n# You must specify an annotation point ``xy=(x, y)`` to annotate this point.\n# Additionally, you may specify a text point ``xytext=(x, y)`` for the location\n# of the text for this annotation.  Optionally, you can specify the coordinate\n# system of *xy* and *xytext* with one of the following strings for *xycoords*\n# and *textcoords* (default is 'data')::\n#\n#  'figure points'   : points from the lower left corner of the figure\n#  'figure pixels'   : pixels from the lower left corner of the figure\n#  'figure fraction' : (0, 0) is lower left of figure and (1, 1) is upper right\n#  'axes points'     : points from lower left corner of the Axes\n#  'axes pixels'     : pixels from lower left corner of the Axes\n#  'axes fraction'   : (0, 0) is lower left of Axes and (1, 1) is upper right\n#  'offset points'   : Specify an offset (in points) from the xy value\n#  'offset pixels'   : Specify an offset (in pixels) from the xy value\n#  'data'            : use the Axes data coordinate system\n#\n# Note: for physical coordinate systems (points or pixels) the origin is the\n# (bottom, left) of the figure or Axes.\n#\n# Optionally, you can specify arrow properties which draws and arrow\n# from the text to the annotated point by giving a dictionary of arrow\n# properties\n#\n# Valid keys are::\n#\n#   width : the width of the arrow in points\n#   frac  : the fraction of the arrow length occupied by the head\n#   headwidth : the width of the base of the arrow head in points\n#   shrink : move the tip and base some percent away from the\n#            annotated point and text\n#   any key for matplotlib.patches.polygon  (e.g., facecolor)\n\n# Create our figure and data we'll use for plotting\nfig, ax = plt.subplots(figsize=(4, 4))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\n\n# Plot a line and add some simple annotations\nline, = ax.plot(t, s)\nax.annotate('figure pixels',\n            xy=(10, 10), xycoords='figure pixels')\nax.annotate('figure points',\n            xy=(107, 110), xycoords='figure points',\n            fontsize=12)\nax.annotate('figure fraction',\n            xy=(.025, .975), xycoords='figure fraction',\n            horizontalalignment='left', verticalalignment='top',\n            fontsize=20)\n\n# The following examples show off how these arrows are drawn.\n\nax.annotate('point offset from data',\n            xy=(3, 1), xycoords='data',\n            xytext=(-10, 90), textcoords='offset points',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='center', verticalalignment='bottom')\n\nax.annotate('axes fraction',\n            xy=(2, 1), xycoords='data',\n            xytext=(0.36, 0.68), textcoords='axes fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='right', verticalalignment='top')\n\n# You may also use negative points or pixels to specify from (right, top).\n# E.g., (-10, 10) is 10 points to the left of the right side of the Axes and 10\n# points above the bottom\n\nax.annotate('pixel offset from axes fraction',\n            xy=(1, 0), xycoords='axes fraction',\n            xytext=(-20, 20), textcoords='offset pixels',\n            horizontalalignment='right',\n            verticalalignment='bottom')\n\nax.set(xlim=(-1, 5), ylim=(-3, 5))\n\n\n# %%\n# Using multiple coordinate systems and axis types\n# ------------------------------------------------\n#\n# You can specify the *xypoint* and the *xytext* in different positions and\n# coordinate systems, and optionally turn on a connecting line and mark the\n# point with a marker.  Annotations work on polar Axes too.\n#\n# In the example below, the *xy* point is in native coordinates (*xycoords*\n# defaults to 'data').  For a polar Axes, this is in (theta, radius) space.\n# The text in the example is placed in the fractional figure coordinate system.\n# Text keyword arguments like horizontal and vertical alignment are respected.\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='polar'), figsize=(3, 3))\nr = np.arange(0, 1, 0.001)\ntheta = 2*2*np.pi*r\nline, = ax.plot(theta, r)\n\nind = 800\nthisr, thistheta = r[ind], theta[ind]\nax.plot([thistheta], [thisr], 'o')\nax.annotate('a polar annotation',\n            xy=(thistheta, thisr),  # theta, radius\n            xytext=(0.05, 0.05),    # fraction, fraction\n            textcoords='figure fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='left',\n            verticalalignment='bottom')\n\n# %%\n# You can also use polar notation on a cartesian Axes.  Here the native\n# coordinate system ('data') is cartesian, so you need to specify the\n# xycoords and textcoords as 'polar' if you want to use (theta, radius).\n\nel = Ellipse((0, 0), 10, 20, facecolor='r', alpha=0.5)\n\nfig, ax = plt.subplots(subplot_kw=dict(aspect='equal'))\nax.add_artist(el)\nel.set_clip_box(ax.bbox)\nax.annotate('the top',\n            xy=(np.pi/2., 10.),      # theta, radius\n            xytext=(np.pi/3, 20.),   # theta, radius\n            xycoords='polar',\n            textcoords='polar',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='left',\n            verticalalignment='bottom',\n            clip_on=True)  # clip to the Axes bounding box\n\nax.set(xlim=[-20, 20], ylim=[-20, 20])\n\n\n# %%\n# Customizing arrow and bubble styles\n# -----------------------------------\n#\n# The arrow between *xytext* and the annotation point, as well as the bubble\n# that covers the annotation text, are highly customizable. Below are a few\n# parameter options as well as their resulting output.\n\nfig, ax = plt.subplots(figsize=(8, 5))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=3)\n\nax.annotate(\n    'straight',\n    xy=(0, 1), xycoords='data',\n    xytext=(-50, 30), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\"))\nax.annotate(\n    'arc3,\\nrad 0.2',\n    xy=(0.5, -1), xycoords='data',\n    xytext=(-80, -60), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"arc3,rad=.2\"))\nax.annotate(\n    'arc,\\nangle 50',\n    xy=(1., 1), xycoords='data',\n    xytext=(-90, 50), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"arc,angleA=0,armA=50,rad=10\"))\nax.annotate(\n    'arc,\\narms',\n    xy=(1.5, -1), xycoords='data',\n    xytext=(-80, -60), textcoords='offset points',\n    arrowprops=dict(\n        arrowstyle=\"->\",\n        connectionstyle=\"arc,angleA=0,armA=40,angleB=-90,armB=30,rad=7\"))\nax.annotate(\n    'angle,\\nangle 90',\n    xy=(2., 1), xycoords='data',\n    xytext=(-70, 30), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\"))\nax.annotate(\n    'angle3,\\nangle -90',\n    xy=(2.5, -1), xycoords='data',\n    xytext=(-80, -60), textcoords='offset points',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle3,angleA=0,angleB=-90\"))\nax.annotate(\n    'angle,\\nround',\n    xy=(3., 1), xycoords='data',\n    xytext=(-60, 30), textcoords='offset points',\n    bbox=dict(boxstyle=\"round\", fc=\"0.8\"),\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\"))\nax.annotate(\n    'angle,\\nround4',\n    xy=(3.5, -1), xycoords='data',\n    xytext=(-70, -80), textcoords='offset points',\n    size=20,\n    bbox=dict(boxstyle=\"round4,pad=.5\", fc=\"0.8\"),\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle,angleA=0,angleB=-90,rad=10\"))\nax.annotate(\n    'angle,\\nshrink',\n    xy=(4., 1), xycoords='data',\n    xytext=(-60, 30), textcoords='offset points',\n    bbox=dict(boxstyle=\"round\", fc=\"0.8\"),\n    arrowprops=dict(arrowstyle=\"->\",\n                    shrinkA=0, shrinkB=10,\n                    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\"))\n# You can pass an empty string to get only annotation arrows rendered\nax.annotate('', xy=(4., 1.), xycoords='data',\n            xytext=(4.5, -1), textcoords='data',\n            arrowprops=dict(arrowstyle=\"<->\",\n                            connectionstyle=\"bar\",\n                            ec=\"k\",\n                            shrinkA=5, shrinkB=5))\n\nax.set(xlim=(-1, 5), ylim=(-4, 3))\n\n# %%\n# We'll create another figure so that it doesn't get too cluttered\nfig, ax = plt.subplots()\n\nel = Ellipse((2, -1), 0.5, 0.5)\nax.add_patch(el)\n\nax.annotate('$->$',\n            xy=(2., -1), xycoords='data',\n            xytext=(-150, -140), textcoords='offset points',\n            bbox=dict(boxstyle=\"round\", fc=\"0.8\"),\n            arrowprops=dict(arrowstyle=\"->\",\n                            patchB=el,\n                            connectionstyle=\"angle,angleA=90,angleB=0,rad=10\"))\nax.annotate('arrow\\nfancy',\n            xy=(2., -1), xycoords='data',\n            xytext=(-100, 60), textcoords='offset points',\n            size=20,\n            arrowprops=dict(arrowstyle=\"fancy\",\n                            fc=\"0.6\", ec=\"none\",\n                            patchB=el,\n                            connectionstyle=\"angle3,angleA=0,angleB=-90\"))\nax.annotate('arrow\\nsimple',\n            xy=(2., -1), xycoords='data',\n            xytext=(100, 60), textcoords='offset points',\n            size=20,\n            arrowprops=dict(arrowstyle=\"simple\",\n                            fc=\"0.6\", ec=\"none\",\n                            patchB=el,\n                            connectionstyle=\"arc3,rad=0.3\"))\nax.annotate('wedge',\n            xy=(2., -1), xycoords='data',\n            xytext=(-100, -100), textcoords='offset points',\n            size=20,\n            arrowprops=dict(arrowstyle=\"wedge,tail_width=0.7\",\n                            fc=\"0.6\", ec=\"none\",\n                            patchB=el,\n                            connectionstyle=\"arc3,rad=-0.3\"))\nax.annotate('bubble,\\ncontours',\n            xy=(2., -1), xycoords='data',\n            xytext=(0, -70), textcoords='offset points',\n            size=20,\n            bbox=dict(boxstyle=\"round\",\n                      fc=(1.0, 0.7, 0.7),\n                      ec=(1., .5, .5)),\n            arrowprops=dict(arrowstyle=\"wedge,tail_width=1.\",\n                            fc=(1.0, 0.7, 0.7), ec=(1., .5, .5),\n                            patchA=None,\n                            patchB=el,\n                            relpos=(0.2, 0.8),\n                            connectionstyle=\"arc3,rad=-0.1\"))\nax.annotate('bubble',\n            xy=(2., -1), xycoords='data',\n            xytext=(55, 0), textcoords='offset points',\n            size=20, va=\"center\",\n            bbox=dict(boxstyle=\"round\", fc=(1.0, 0.7, 0.7), ec=\"none\"),\n            arrowprops=dict(arrowstyle=\"wedge,tail_width=1.\",\n                            fc=(1.0, 0.7, 0.7), ec=\"none\",\n                            patchA=None,\n                            patchB=el,\n                            relpos=(0.2, 0.5)))\n\nax.set(xlim=(-1, 5), ylim=(-5, 3))\n\n# %%\n# More examples of coordinate systems\n# -----------------------------------\n#\n# Below we'll show a few more examples of coordinate systems and how the\n# location of annotations may be specified.\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\n\nbbox_args = dict(boxstyle=\"round\", fc=\"0.8\")\narrow_args = dict(arrowstyle=\"->\")\n\n# Here we'll demonstrate the extents of the coordinate system and how\n# we place annotating text.\n\nax1.annotate('figure fraction : 0, 0', xy=(0, 0), xycoords='figure fraction',\n             xytext=(20, 20), textcoords='offset points',\n             ha=\"left\", va=\"bottom\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax1.annotate('figure fraction : 1, 1', xy=(1, 1), xycoords='figure fraction',\n             xytext=(-20, -20), textcoords='offset points',\n             ha=\"right\", va=\"top\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax1.annotate('axes fraction : 0, 0', xy=(0, 0), xycoords='axes fraction',\n             xytext=(20, 20), textcoords='offset points',\n             ha=\"left\", va=\"bottom\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax1.annotate('axes fraction : 1, 1', xy=(1, 1), xycoords='axes fraction',\n             xytext=(-20, -20), textcoords='offset points',\n             ha=\"right\", va=\"top\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\n# It is also possible to generate draggable annotations\n\nan1 = ax1.annotate('Drag me 1', xy=(.5, .7), xycoords='data',\n                   ha=\"center\", va=\"center\",\n                   bbox=bbox_args)\n\nan2 = ax1.annotate('Drag me 2', xy=(.5, .5), xycoords=an1,\n                   xytext=(.5, .3), textcoords='axes fraction',\n                   ha=\"center\", va=\"center\",\n                   bbox=bbox_args,\n                   arrowprops=dict(patchB=an1.get_bbox_patch(),\n                                   connectionstyle=\"arc3,rad=0.2\",\n                                   **arrow_args))\nan1.draggable()\nan2.draggable()\n\nan3 = ax1.annotate('', xy=(.5, .5), xycoords=an2,\n                   xytext=(.5, .5), textcoords=an1,\n                   ha=\"center\", va=\"center\",\n                   bbox=bbox_args,\n                   arrowprops=dict(patchA=an1.get_bbox_patch(),\n                                   patchB=an2.get_bbox_patch(),\n                                   connectionstyle=\"arc3,rad=0.2\",\n                                   **arrow_args))\n\n# Finally we'll show off some more complex annotation and placement\n\ntext = ax2.annotate('xy=(0, 1)\\nxycoords=(\"data\", \"axes fraction\")',\n                    xy=(0, 1), xycoords=(\"data\", 'axes fraction'),\n                    xytext=(0, -20), textcoords='offset points',\n                    ha=\"center\", va=\"top\",\n                    bbox=bbox_args,\n                    arrowprops=arrow_args)\n\nax2.annotate('xy=(0.5, 0)\\nxycoords=artist',\n             xy=(0.5, 0.), xycoords=text,\n             xytext=(0, -20), textcoords='offset points',\n             ha=\"center\", va=\"top\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax2.annotate('xy=(0.8, 0.5)\\nxycoords=ax1.transData',\n             xy=(0.8, 0.5), xycoords=ax1.transData,\n             xytext=(10, 10),\n             textcoords=OffsetFrom(ax2.bbox, (0, 0), \"points\"),\n             ha=\"left\", va=\"bottom\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax2.set(xlim=[-2, 2], ylim=[-2, 2])\nplt.show()\n"
    },
    {
      "filename": "annotation_polar.py",
      "title": "Annotation Polar",
      "code": "\"\"\"\n====================\nAnnotate polar plots\n====================\n\nThis example shows how to create an annotation on a polar graph.\n\nFor a complete overview of the annotation capabilities, also see the\n:ref:`annotations`.\n\n.. redirect-from:: /gallery/pyplots/annotation_polar\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nr = np.arange(0, 1, 0.001)\ntheta = 2 * 2*np.pi * r\nline, = ax.plot(theta, r, color='#ee8d18', lw=3)\n\nind = 800\nthisr, thistheta = r[ind], theta[ind]\nax.plot([thistheta], [thisr], 'o')\nax.annotate('a polar annotation',\n            xy=(thistheta, thisr),  # theta, radius\n            xytext=(0.05, 0.05),    # fraction, fraction\n            textcoords='figure fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='left',\n            verticalalignment='bottom',\n            )\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.projections.polar`\n#    - `matplotlib.axes.Axes.annotate` / `matplotlib.pyplot.annotate`\n"
    },
    {
      "filename": "arrow_demo.py",
      "title": "Arrow Demo",
      "code": "\"\"\"\n==========\nArrow Demo\n==========\n\nThree ways of drawing arrows to encode arrow \"strength\" (e.g., transition\nprobabilities in a Markov model) using arrow length, width, or alpha (opacity).\n\"\"\"\n\nimport itertools\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef make_arrow_graph(ax, data, size=4, display='length', shape='right',\n                     max_arrow_width=0.03, arrow_sep=0.02, alpha=0.5,\n                     normalize_data=False, ec=None, labelcolor=None,\n                     **kwargs):\n    \"\"\"\n    Makes an arrow plot.\n\n    Parameters\n    ----------\n    ax\n        The Axes where the graph is drawn.\n    data\n        Dict with probabilities for the bases and pair transitions.\n    size\n        Size of the plot, in inches.\n    display : {'length', 'width', 'alpha'}\n        The arrow property to change.\n    shape : {'full', 'left', 'right'}\n        For full or half arrows.\n    max_arrow_width : float\n        Maximum width of an arrow, in data coordinates.\n    arrow_sep : float\n        Separation between arrows in a pair, in data coordinates.\n    alpha : float\n        Maximum opacity of arrows.\n    **kwargs\n        `.FancyArrow` properties, e.g. *linewidth* or *edgecolor*.\n    \"\"\"\n\n    ax.set(xlim=(-0.25, 1.25), ylim=(-0.25, 1.25), xticks=[], yticks=[],\n           title=f'flux encoded as arrow {display}')\n    max_text_size = size * 12\n    min_text_size = size\n    label_text_size = size * 4\n\n    bases = 'ATGC'\n    coords = {\n        'A': np.array([0, 1]),\n        'T': np.array([1, 1]),\n        'G': np.array([0, 0]),\n        'C': np.array([1, 0]),\n    }\n    colors = {'A': 'r', 'T': 'k', 'G': 'g', 'C': 'b'}\n\n    for base in bases:\n        fontsize = np.clip(max_text_size * data[base]**(1/2),\n                           min_text_size, max_text_size)\n        ax.text(*coords[base], f'${base}_3$',\n                color=colors[base], size=fontsize,\n                horizontalalignment='center', verticalalignment='center',\n                weight='bold')\n\n    arrow_h_offset = 0.25  # data coordinates, empirically determined\n    max_arrow_length = 1 - 2 * arrow_h_offset\n    max_head_width = 2.5 * max_arrow_width\n    max_head_length = 2 * max_arrow_width\n    sf = 0.6  # max arrow size represents this in data coords\n\n    if normalize_data:\n        # find maximum value for rates, i.e. where keys are 2 chars long\n        max_val = max((v for k, v in data.items() if len(k) == 2), default=0)\n        # divide rates by max val, multiply by arrow scale factor\n        for k, v in data.items():\n            data[k] = v / max_val * sf\n\n    # iterate over strings 'AT', 'TA', 'AG', 'GA', etc.\n    for pair in map(''.join, itertools.permutations(bases, 2)):\n        # set the length of the arrow\n        if display == 'length':\n            length = (max_head_length\n                      + data[pair] / sf * (max_arrow_length - max_head_length))\n        else:\n            length = max_arrow_length\n        # set the transparency of the arrow\n        if display == 'alpha':\n            alpha = min(data[pair] / sf, alpha)\n        # set the width of the arrow\n        if display == 'width':\n            scale = data[pair] / sf\n            width = max_arrow_width * scale\n            head_width = max_head_width * scale\n            head_length = max_head_length * scale\n        else:\n            width = max_arrow_width\n            head_width = max_head_width\n            head_length = max_head_length\n\n        fc = colors[pair[0]]\n\n        cp0 = coords[pair[0]]\n        cp1 = coords[pair[1]]\n        # unit vector in arrow direction\n        delta = cos, sin = (cp1 - cp0) / np.hypot(*(cp1 - cp0))\n        x_pos, y_pos = (\n            (cp0 + cp1) / 2  # midpoint\n            - delta * length / 2  # half the arrow length\n            + np.array([-sin, cos]) * arrow_sep  # shift outwards by arrow_sep\n        )\n        ax.arrow(\n            x_pos, y_pos, cos * length, sin * length,\n            fc=fc, ec=ec or fc, alpha=alpha, width=width,\n            head_width=head_width, head_length=head_length, shape=shape,\n            length_includes_head=True,\n            **kwargs\n        )\n\n        # figure out coordinates for text:\n        # if drawing relative to base: x and y are same as for arrow\n        # dx and dy are one arrow width left and up\n        orig_positions = {\n            'base': [3 * max_arrow_width, 3 * max_arrow_width],\n            'center': [length / 2, 3 * max_arrow_width],\n            'tip': [length - 3 * max_arrow_width, 3 * max_arrow_width],\n        }\n        # for diagonal arrows, put the label at the arrow base\n        # for vertical or horizontal arrows, center the label\n        where = 'base' if (cp0 != cp1).all() else 'center'\n        # rotate based on direction of arrow (cos, sin)\n        M = [[cos, -sin], [sin, cos]]\n        x, y = np.dot(M, orig_positions[where]) + [x_pos, y_pos]\n        label = r'$r_{_{\\mathrm{%s}}}$' % (pair,)\n        ax.text(x, y, label, size=label_text_size, ha='center', va='center',\n                color=labelcolor or fc)\n\n\nif __name__ == '__main__':\n    data = {  # test data\n        'A': 0.4, 'T': 0.3, 'G': 0.6, 'C': 0.2,\n        'AT': 0.4, 'AC': 0.3, 'AG': 0.2,\n        'TA': 0.2, 'TC': 0.3, 'TG': 0.4,\n        'CT': 0.2, 'CG': 0.3, 'CA': 0.2,\n        'GA': 0.1, 'GT': 0.4, 'GC': 0.1,\n    }\n\n    size = 4\n    fig = plt.figure(figsize=(3 * size, size), layout=\"constrained\")\n    axs = fig.subplot_mosaic([[\"length\", \"width\", \"alpha\"]])\n\n    for display, ax in axs.items():\n        make_arrow_graph(\n            ax, data, display=display, linewidth=0.001, edgecolor=None,\n            normalize_data=True, size=size)\n\n    plt.show()\n"
    },
    {
      "filename": "autowrap.py",
      "title": "Autowrap",
      "code": "\"\"\"\n==============\nAuto-wrap text\n==============\n\nMatplotlib can wrap text automatically, but if it's too long, the text will\nstill be displayed slightly outside the boundaries of the axis.\n\nNote: Auto-wrapping does not work together with\n``savefig(..., bbox_inches='tight')``. The 'tight' setting rescales the canvas\nto accommodate all content and happens before wrapping. This affects\n``%matplotlib inline`` in IPython and Jupyter notebooks where the inline\nsetting uses ``bbox_inches='tight'`` by default when saving the image to\nembed.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig = plt.figure()\nplt.axis((0, 10, 0, 10))\nt = (\"This is a really long string that I'd rather have wrapped so that it \"\n     \"doesn't go outside of the figure, but if it's long enough it will go \"\n     \"off the top or bottom!\")\nplt.text(4, 1, t, ha='left', rotation=15, wrap=True)\nplt.text(6, 5, t, ha='left', rotation=15, wrap=True)\nplt.text(5, 5, t, ha='right', rotation=-15, wrap=True)\nplt.text(5, 10, t, fontsize=18, style='oblique', ha='center',\n         va='top', wrap=True)\nplt.text(3, 4, t, family='serif', style='italic', ha='right', wrap=True)\nplt.text(-1, 0, t, ha='left', rotation=-15, wrap=True)\n\nplt.show()\n"
    },
    {
      "filename": "custom_legends.py",
      "title": "Custom Legends",
      "code": "\"\"\"\n======================\nCompose custom legends\n======================\n\nComposing custom legends piece-by-piece.\n\n.. note::\n\n   For more information on creating and customizing legends, see the following\n   pages:\n\n   * :ref:`legend_guide`\n   * :doc:`/gallery/text_labels_and_annotations/legend_demo`\n\nSometimes you don't want a legend that is explicitly tied to data that\nyou have plotted. For example, say you have plotted 10 lines, but don't\nwant a legend item to show up for each one. If you simply plot the lines\nand call ``ax.legend()``, you will get the following:\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# sphinx_gallery_thumbnail_number = 2\nimport matplotlib as mpl\nfrom matplotlib import cycler\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# %%\nN = 10\ndata = (np.geomspace(1, 10, 100) + np.random.randn(N, 100)).T\ncmap = plt.cm.coolwarm\nmpl.rcParams['axes.prop_cycle'] = cycler(color=cmap(np.linspace(0, 1, N)))\n\nfig, ax = plt.subplots()\nlines = ax.plot(data)\n\n# %%\n# Since the data does not have any labels, creating a legend requires\n# us to define the icons and labels.\n# In this case, we can compose a legend using Matplotlib objects that aren't\n# explicitly tied to the data that was plotted. For example:\n\nfrom matplotlib.lines import Line2D\n\ncustom_lines = [Line2D([0], [0], color=cmap(0.), lw=4),\n                Line2D([0], [0], color=cmap(.5), lw=4),\n                Line2D([0], [0], color=cmap(1.), lw=4)]\n\nfig, ax = plt.subplots()\nlines = ax.plot(data)\nax.legend(custom_lines, ['Cold', 'Medium', 'Hot'])\n\n\n# %%\n# There are many other Matplotlib objects that can be used in this way. In the\n# code below we've listed a few common ones.\n\nfrom matplotlib.lines import Line2D\nfrom matplotlib.patches import Patch\n\nlegend_elements = [Line2D([0], [0], color='b', lw=4, label='Line'),\n                   Line2D([0], [0], marker='o', color='w', label='Scatter',\n                          markerfacecolor='g', markersize=15),\n                   Patch(facecolor='orange', edgecolor='r',\n                         label='Color Patch')]\n\n# Create the figure\nfig, ax = plt.subplots()\nax.legend(handles=legend_elements, loc='center')\n\nplt.show()\n"
    },
    {
      "filename": "date.py",
      "title": "Date",
      "code": "\"\"\"\n================\nDate tick labels\n================\n\nMatplotlib date plotting is done by converting date instances into\ndays since an epoch (by default 1970-01-01T00:00:00). The\n:mod:`matplotlib.dates` module provides the converter functions `.date2num`\nand `.num2date` that convert `datetime.datetime` and `numpy.datetime64`\nobjects to and from Matplotlib's internal representation.  These data\ntypes are registered with the unit conversion mechanism described in\n:mod:`matplotlib.units`, so the conversion happens automatically for the user.\nThe registration process also sets the default tick ``locator`` and\n``formatter`` for the axis to be `~.matplotlib.dates.AutoDateLocator` and\n`~.matplotlib.dates.AutoDateFormatter`.\n\nAn alternative formatter is the `~.dates.ConciseDateFormatter`,\nused in the second ``Axes`` below (see\n:doc:`/gallery/ticks/date_concise_formatter`), which often removes the need to\nrotate the tick labels. The last ``Axes`` formats the dates manually, using\n`~.dates.DateFormatter` to format the dates using the format strings documented\nat `datetime.date.strftime`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.dates as mdates\n\n# Load a numpy record array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit ('D') in\n# the date column.\ndata = cbook.get_sample_data('goog.npz')['price_data']\n\nfig, axs = plt.subplots(3, 1, figsize=(6.4, 7), layout='constrained')\n# common to all three:\nfor ax in axs:\n    ax.plot('date', 'adj_close', data=data)\n    # Major ticks every half year, minor ticks every month,\n    ax.xaxis.set_major_locator(mdates.MonthLocator(bymonth=(1, 7)))\n    ax.xaxis.set_minor_locator(mdates.MonthLocator())\n    ax.grid(True)\n    ax.set_ylabel(r'Price [\\$]')\n\n# different formats:\nax = axs[0]\nax.set_title('DefaultFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\n\nax = axs[1]\nax.set_title('ConciseFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\nax.xaxis.set_major_formatter(\n    mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\n\nax = axs[2]\nax.set_title('Manual DateFormatter', loc='left', y=0.85, x=0.02,\n             fontsize='medium')\n# Text in the x-axis will be displayed in 'YYYY-mm' format.\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%b'))\n# Rotates and right-aligns the x labels so they don't crowd each other.\nfor label in ax.get_xticklabels(which='major'):\n    label.set(rotation=30, horizontalalignment='right')\n\nplt.show()\n"
    },
    {
      "filename": "demo_annotation_box.py",
      "title": "Demo Annotation Box",
      "code": "\"\"\"\n===================\nAnnotationBbox demo\n===================\n\n`.AnnotationBbox` creates an annotation using an `.OffsetBox`, and\nprovides more fine-grained control than `.Axes.annotate`.  This example\ndemonstrates the use of AnnotationBbox together with three different\nOffsetBoxes: `.TextArea`, `.DrawingArea`, and `.OffsetImage`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nfrom matplotlib.offsetbox import (AnnotationBbox, DrawingArea, OffsetImage,\n                                  TextArea)\nfrom matplotlib.patches import Circle\n\nfig, ax = plt.subplots()\n\n# Define a 1st position to annotate (display it with a marker)\nxy = (0.5, 0.7)\nax.plot(xy[0], xy[1], \".r\")\n\n# Annotate the 1st position with a text box ('Test 1')\noffsetbox = TextArea(\"Test 1\")\n\nab = AnnotationBbox(offsetbox, xy,\n                    xybox=(-20, 40),\n                    xycoords='data',\n                    boxcoords=\"offset points\",\n                    arrowprops=dict(arrowstyle=\"->\"),\n                    bboxprops=dict(boxstyle=\"sawtooth\"))\nax.add_artist(ab)\n\n# Annotate the 1st position with another text box ('Test')\noffsetbox = TextArea(\"Test\")\n\nab = AnnotationBbox(offsetbox, xy,\n                    xybox=(1.02, xy[1]),\n                    xycoords='data',\n                    boxcoords=(\"axes fraction\", \"data\"),\n                    box_alignment=(0., 0.5),\n                    arrowprops=dict(arrowstyle=\"->\"))\nax.add_artist(ab)\n\n# Define a 2nd position to annotate (don't display with a marker this time)\nxy = [0.3, 0.55]\n\n# Annotate the 2nd position with a circle patch\nda = DrawingArea(20, 20, 0, 0)\np = Circle((10, 10), 10)\nda.add_artist(p)\n\nab = AnnotationBbox(da, xy,\n                    xybox=(1., xy[1]),\n                    xycoords='data',\n                    boxcoords=(\"axes fraction\", \"data\"),\n                    box_alignment=(0.2, 0.5),\n                    arrowprops=dict(arrowstyle=\"->\"),\n                    bboxprops=dict(alpha=0.5))\n\nax.add_artist(ab)\n\n# Annotate the 2nd position with an image (a generated array of pixels)\narr = np.arange(100).reshape((10, 10))\nim = OffsetImage(arr, zoom=2)\nim.image.axes = ax\n\nab = AnnotationBbox(im, xy,\n                    xybox=(-50., 50.),\n                    xycoords='data',\n                    boxcoords=\"offset points\",\n                    pad=0.3,\n                    arrowprops=dict(arrowstyle=\"->\"))\n\nax.add_artist(ab)\n\n# Annotate the 2nd position with another image (a Grace Hopper portrait)\nwith get_sample_data(\"grace_hopper.jpg\") as file:\n    arr_img = plt.imread(file)\n\nimagebox = OffsetImage(arr_img, zoom=0.2)\nimagebox.image.axes = ax\n\nab = AnnotationBbox(imagebox, xy,\n                    xybox=(120., -80.),\n                    xycoords='data',\n                    boxcoords=\"offset points\",\n                    pad=0.5,\n                    arrowprops=dict(\n                        arrowstyle=\"->\",\n                        connectionstyle=\"angle,angleA=0,angleB=90,rad=3\")\n                    )\n\nax.add_artist(ab)\n\n# Fix the display limits to see everything\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches.Circle`\n#    - `matplotlib.offsetbox.TextArea`\n#    - `matplotlib.offsetbox.DrawingArea`\n#    - `matplotlib.offsetbox.OffsetImage`\n#    - `matplotlib.offsetbox.AnnotationBbox`\n#    - `matplotlib.cbook.get_sample_data`\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.pyplot.imread`\n"
    },
    {
      "filename": "demo_text_path.py",
      "title": "Demo Text Path",
      "code": "\"\"\"\n======================\nUsing a text as a Path\n======================\n\n`~matplotlib.text.TextPath` creates a `.Path` that is the outline of the\ncharacters of a text. The resulting path can be employed e.g. as a clip path\nfor an image.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nfrom matplotlib.image import BboxImage\nfrom matplotlib.offsetbox import (AnchoredOffsetbox, AnnotationBbox,\n                                  AuxTransformBox)\nfrom matplotlib.patches import PathPatch, Shadow\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import IdentityTransform\n\n\nclass PathClippedImagePatch(PathPatch):\n    \"\"\"\n    The given image is used to draw the face of the patch. Internally,\n    it uses BboxImage whose clippath set to the path of the patch.\n\n    FIXME : The result is currently dpi dependent.\n    \"\"\"\n\n    def __init__(self, path, bbox_image, **kwargs):\n        super().__init__(path, **kwargs)\n        self.bbox_image = BboxImage(\n            self.get_window_extent, norm=None, origin=None)\n        self.bbox_image.set_data(bbox_image)\n\n    def set_facecolor(self, color):\n        \"\"\"Simply ignore facecolor.\"\"\"\n        super().set_facecolor(\"none\")\n\n    def draw(self, renderer=None):\n        # the clip path must be updated every draw. any solution? -JJ\n        self.bbox_image.set_clip_path(self._path, self.get_transform())\n        self.bbox_image.draw(renderer)\n        super().draw(renderer)\n\n\nif __name__ == \"__main__\":\n\n    fig, (ax1, ax2) = plt.subplots(2)\n\n    # EXAMPLE 1\n\n    arr = plt.imread(get_sample_data(\"grace_hopper.jpg\"))\n\n    text_path = TextPath((0, 0), \"!?\", size=150)\n    p = PathClippedImagePatch(text_path, arr, ec=\"k\")\n\n    # make offset box\n    offsetbox = AuxTransformBox(IdentityTransform())\n    offsetbox.add_artist(p)\n\n    # make anchored offset box\n    ao = AnchoredOffsetbox(loc='upper left', child=offsetbox, frameon=True,\n                           borderpad=0.2)\n    ax1.add_artist(ao)\n\n    # another text\n    for usetex, ypos, string in [\n            (False, 0.25, r\"textpath supports mathtext\"),\n            (True, 0.05, r\"textpath supports \\TeX\"),\n    ]:\n        text_path = TextPath((0, 0), string, size=20, usetex=usetex)\n\n        p1 = PathPatch(text_path, ec=\"w\", lw=3, fc=\"w\", alpha=0.9)\n        p2 = PathPatch(text_path, ec=\"none\", fc=\"k\")\n\n        offsetbox2 = AuxTransformBox(IdentityTransform())\n        offsetbox2.add_artist(p1)\n        offsetbox2.add_artist(p2)\n\n        ab = AnnotationBbox(offsetbox2, (0.95, ypos),\n                            xycoords='axes fraction',\n                            boxcoords=\"offset points\",\n                            box_alignment=(1., 0.),\n                            frameon=False,\n                            )\n        ax1.add_artist(ab)\n\n    ax1.imshow([[0, 1, 2], [1, 2, 3]], cmap=plt.cm.gist_gray_r,\n               interpolation=\"bilinear\", aspect=\"auto\")\n\n    # EXAMPLE 2\n\n    arr = np.arange(256).reshape(1, 256)\n\n    for usetex, xpos, string in [\n            (False, 0.25,\n             r\"$\\left[\\sum_{n=1}^\\infty\\frac{-e^{i\\pi}}{2^n}\\right]$!\"),\n            (True, 0.75,\n             r\"$\\displaystyle\\left[\\sum_{n=1}^\\infty\"\n             r\"\\frac{-e^{i\\pi}}{2^n}\\right]$!\"),\n    ]:\n        text_path = TextPath((0, 0), string, size=40, usetex=usetex)\n        text_patch = PathClippedImagePatch(text_path, arr, ec=\"none\")\n        shadow1 = Shadow(text_patch, 1, -1, fc=\"none\", ec=\"0.6\", lw=3)\n        shadow2 = Shadow(text_patch, 1, -1, fc=\"0.3\", ec=\"none\")\n\n        # make offset box\n        offsetbox = AuxTransformBox(IdentityTransform())\n        offsetbox.add_artist(shadow1)\n        offsetbox.add_artist(shadow2)\n        offsetbox.add_artist(text_patch)\n\n        # place the anchored offset box using AnnotationBbox\n        ab = AnnotationBbox(offsetbox, (xpos, 0.5), box_alignment=(0.5, 0.5))\n\n        ax2.add_artist(ab)\n\n    ax2.set_xlim(0, 1)\n    ax2.set_ylim(0, 1)\n\n    plt.show()\n"
    },
    {
      "filename": "demo_text_rotation_mode.py",
      "title": "Demo Text Rotation Mode",
      "code": "r\"\"\"\n==================\nText rotation mode\n==================\n\nThis example illustrates the effect of ``rotation_mode`` on the positioning\nof rotated text.\n\nRotated `.Text`\\s are created by passing the parameter ``rotation`` to\nthe constructor or the Axes' method `~.axes.Axes.text`.\n\nThe actual positioning depends on the additional parameters\n``horizontalalignment``, ``verticalalignment`` and ``rotation_mode``.\n``rotation_mode`` determines the order of rotation and alignment:\n\n- ``rotation_mode='default'`` (or None) first rotates the text and then aligns\n  the bounding box of the rotated text.\n- ``rotation_mode='anchor'`` aligns the unrotated text and then rotates the\n  text around the point of alignment.\n\n.. redirect-from:: /gallery/text_labels_and_annotations/text_rotation\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef test_rotation_mode(fig, mode):\n    ha_list = [\"left\", \"center\", \"right\"]\n    va_list = [\"top\", \"center\", \"baseline\", \"bottom\"]\n    axs = fig.subplots(len(va_list), len(ha_list), sharex=True, sharey=True,\n                       subplot_kw=dict(aspect=1),\n                       gridspec_kw=dict(hspace=0, wspace=0))\n\n    # labels and title\n    for ha, ax in zip(ha_list, axs[-1, :]):\n        ax.set_xlabel(ha)\n    for va, ax in zip(va_list, axs[:, 0]):\n        ax.set_ylabel(va)\n    axs[0, 1].set_title(f\"rotation_mode='{mode}'\", size=\"large\")\n\n    kw = (\n        {} if mode == \"default\" else\n        {\"bbox\": dict(boxstyle=\"square,pad=0.\", ec=\"none\", fc=\"C1\", alpha=0.3)}\n    )\n\n    texts = {}\n\n    # use a different text alignment in each Axes\n    for i, va in enumerate(va_list):\n        for j, ha in enumerate(ha_list):\n            ax = axs[i, j]\n            # prepare Axes layout\n            ax.set(xticks=[], yticks=[])\n            ax.axvline(0.5, color=\"skyblue\", zorder=0)\n            ax.axhline(0.5, color=\"skyblue\", zorder=0)\n            ax.plot(0.5, 0.5, color=\"C0\", marker=\"o\", zorder=1)\n            # add text with rotation and alignment settings\n            tx = ax.text(0.5, 0.5, \"Tpg\",\n                         size=\"x-large\", rotation=40,\n                         horizontalalignment=ha, verticalalignment=va,\n                         rotation_mode=mode, **kw)\n            texts[ax] = tx\n\n    if mode == \"default\":\n        # highlight bbox\n        fig.canvas.draw()\n        for ax, text in texts.items():\n            bb = text.get_window_extent().transformed(ax.transData.inverted())\n            rect = plt.Rectangle((bb.x0, bb.y0), bb.width, bb.height,\n                                 facecolor=\"C1\", alpha=0.3, zorder=2)\n            ax.add_patch(rect)\n\n\nfig = plt.figure(figsize=(8, 5))\nsubfigs = fig.subfigures(1, 2)\ntest_rotation_mode(subfigs[0], \"default\")\ntest_rotation_mode(subfigs[1], \"anchor\")\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.text` / `matplotlib.pyplot.text`\n"
    },
    {
      "filename": "dfrac_demo.py",
      "title": "Dfrac Demo",
      "code": "r\"\"\"\n=========================================\nThe difference between \\\\dfrac and \\\\frac\n=========================================\n\nIn this example, the differences between the \\\\dfrac and \\\\frac TeX macros are\nillustrated; in particular, the difference between display style and text style\nfractions when using Mathtex.\n\n.. versionadded:: 2.1\n\n.. note::\n    To use \\\\dfrac with the LaTeX engine (text.usetex : True), you need to\n    import the amsmath package with the text.latex.preamble rc, which is\n    an unsupported feature; therefore, it is probably a better idea to just\n    use the \\\\displaystyle option before the \\\\frac macro to get this behavior\n    with the LaTeX engine.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(5.25, 0.75))\nfig.text(0.5, 0.3, r'\\dfrac: $\\dfrac{a}{b}$',\n         horizontalalignment='center', verticalalignment='center')\nfig.text(0.5, 0.7, r'\\frac: $\\frac{a}{b}$',\n         horizontalalignment='center', verticalalignment='center')\nplt.show()\n"
    },
    {
      "filename": "engineering_formatter.py",
      "title": "Engineering Formatter",
      "code": "\"\"\"\n=======================================\nFormat ticks using engineering notation\n=======================================\n\nUse of the engineering Formatter.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import EngFormatter\n\n# Fixing random state for reproducibility\nprng = np.random.RandomState(19680801)\n\n# Create artificial data to plot.\n# The x data span over several decades to demonstrate several SI prefixes.\nxs = np.logspace(1, 9, 100)\nys = (0.8 + 0.4 * prng.uniform(size=100)) * np.log10(xs)**2\n\n# Figure width is doubled (2*6.4) to display nicely 2 subplots side by side.\nfig, (ax0, ax1) = plt.subplots(nrows=2, figsize=(7, 9.6))\nfor ax in (ax0, ax1):\n    ax.set_xscale('log')\n\n# Demo of the default settings, with a user-defined unit label.\nax0.set_title('Full unit ticklabels, w/ default precision & space separator')\nformatter0 = EngFormatter(unit='Hz')\nax0.xaxis.set_major_formatter(formatter0)\nax0.plot(xs, ys)\nax0.set_xlabel('Frequency')\n\n# Demo of the options `places` (number of digit after decimal point) and\n# `sep` (separator between the number and the prefix/unit).\nax1.set_title('SI-prefix only ticklabels, 1-digit precision & '\n              'thin space separator')\nformatter1 = EngFormatter(places=1, sep=\"\\N{THIN SPACE}\")  # U+2009\nax1.xaxis.set_major_formatter(formatter1)\nax1.plot(xs, ys)\nax1.set_xlabel('Frequency [Hz]')\n\nplt.tight_layout()\nplt.show()\n"
    },
    {
      "filename": "fancyarrow_demo.py",
      "title": "Fancyarrow Demo",
      "code": "\"\"\"\n================================\nAnnotation arrow style reference\n================================\n\nOverview of the available `.ArrowStyle` settings. These are used for the *arrowstyle*\nparameter of `~.Axes.annotate` and `.FancyArrowPatch`.\n\nEach style can be configured with a set of parameters, which are stated along with\ntheir default values.\n\"\"\"\n\nimport inspect\nimport itertools\nimport re\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.patches import ArrowStyle\n\nstyles = ArrowStyle.get_styles()\nncol = 2\nnrow = (len(styles) + 1) // ncol\ngridspec_kw = dict(wspace=0, hspace=0.05, left=0, right=1, bottom=0, top=1)\nfig, axs = plt.subplots(1 + nrow, ncol,\n                        figsize=(4 * ncol, 1 + nrow), gridspec_kw=gridspec_kw)\nfor ax in axs.flat:\n    ax.set_xlim(-0.1, 4)\n    ax.set_axis_off()\nfor ax in axs[0, :]:\n    ax.text(0, 0.5, \"arrowstyle\", size=\"large\", color=\"tab:blue\")\n    ax.text(1.4, .5, \"default parameters\", size=\"large\")\nfor ax, (stylename, stylecls) in zip(axs[1:, :].T.flat, styles.items()):\n    # draw dot and annotation with arrowstyle\n    l, = ax.plot(1.25, 0, \"o\", color=\"darkgrey\")\n    ax.annotate(stylename, (1.25, 0), (0, 0),\n                size=\"large\", color=\"tab:blue\", va=\"center\", family=\"monospace\",\n                arrowprops=dict(\n                    arrowstyle=stylename, connectionstyle=\"arc3,rad=0\",\n                    color=\"black\", shrinkA=5, shrinkB=5, patchB=l,\n                ),\n                bbox=dict(boxstyle=\"square\", fc=\"w\", ec=\"darkgrey\"))\n    # draw default parameters\n    # wrap at every nth comma (n = 1 or 2, depending on text length)\n    s = str(inspect.signature(stylecls))[1:-1]\n    n = 2 if s.count(',') > 3 else 1\n    ax.text(1.4, 0,\n            re.sub(', ', lambda m, c=itertools.count(1): m.group()\n                   if next(c) % n else '\\n', s),\n            verticalalignment=\"center\", color=\"0.3\")\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.patches`\n#    - `matplotlib.patches.ArrowStyle`\n#    - ``matplotlib.patches.ArrowStyle.get_styles``\n#    - `matplotlib.axes.Axes.annotate`\n"
    },
    {
      "filename": "fancytextbox_demo.py",
      "title": "Fancytextbox Demo",
      "code": "\"\"\"\n==================\nStyling text boxes\n==================\n\nThis example shows how to style text boxes using *bbox* parameters.\n\"\"\"\nimport matplotlib.pyplot as plt\n\nplt.text(0.6, 0.7, \"eggs\", size=50, rotation=30.,\n         ha=\"center\", va=\"center\",\n         bbox=dict(boxstyle=\"round\",\n                   ec=(1., 0.5, 0.5),\n                   fc=(1., 0.8, 0.8),\n                   )\n         )\n\nplt.text(0.55, 0.6, \"spam\", size=50, rotation=-25.,\n         ha=\"right\", va=\"top\",\n         bbox=dict(boxstyle=\"square\",\n                   ec=(1., 0.5, 0.5),\n                   fc=(1., 0.8, 0.8),\n                   )\n         )\n\nplt.show()\n"
    },
    {
      "filename": "figlegend_demo.py",
      "title": "Figlegend Demo",
      "code": "\"\"\"\n==================\nFigure legend demo\n==================\n\nRather than plotting a legend on each axis, a legend for all the artists\non all the sub-axes of a figure can be plotted instead.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axs = plt.subplots(1, 2, layout='constrained')\n\nx = np.arange(0.0, 4*np.pi, 0.2)\naxs[0].plot(x, np.sin(x), label='Line 1')\naxs[0].plot(x, np.exp(-x/2), marker='o', label='Line 2')\naxs[1].plot(x, np.sin(x), color='tab:green', label='Line 3')\naxs[1].plot(x, np.exp(-x/4), color='tab:red', marker='^', label='Line 4')\n\nfig.legend(loc='outside right upper')\n\nplt.show()\n\n# %%\n# The outside positioning is discussed in detail here:\n# https://matplotlib.org/stable/users/explain/axes/legend_guide.html#figure-legends\n"
    },
    {
      "filename": "font_family_rc.py",
      "title": "Font Family Rc",
      "code": "\"\"\"\n=========================\nConfigure the font family\n=========================\n\nYou can explicitly set which font family is picked up, either by specifying\nfamily names of fonts installed on user's system, or generic-families\n(e.g., 'serif', 'sans-serif', 'monospace', 'fantasy' or 'cursive'),\nor a combination of both.\n(see :ref:`text_props`)\n\nIn the example below, we are overriding the default sans-serif generic family\nto include a specific (Tahoma) font. (Note that the best way to achieve this\nwould simply be to prepend 'Tahoma' in 'font.family')\n\nThe default family is set with the font.family rcparam,\ne.g. ::\n\n  rcParams['font.family'] = 'sans-serif'\n\nand for the font.family you set a list of font styles to try to find\nin order::\n\n  rcParams['font.sans-serif'] = ['Tahoma', 'DejaVu Sans',\n                                 'Lucida Grande', 'Verdana']\n\n.. redirect-from:: /gallery/font_family_rc_sgskip\n\nThe ``font.family`` defaults are OS dependent and can be viewed with:\n\"\"\"\nimport matplotlib.pyplot as plt\n\nprint(plt.rcParams[\"font.sans-serif\"][0])\nprint(plt.rcParams[\"font.monospace\"][0])\n\n\n# %%\n# Choose default sans-serif font\n\ndef print_text(text):\n    fig, ax = plt.subplots(figsize=(6, 1), facecolor=\"#eefade\")\n    ax.text(0.5, 0.5, text, ha='center', va='center', size=40)\n    ax.axis(\"off\")\n    plt.show()\n\n\nplt.rcParams[\"font.family\"] = \"sans-serif\"\nprint_text(\"Hello World! 01\")\n\n\n# %%\n# Choose sans-serif font and specify to it to \"Nimbus Sans\"\n\nplt.rcParams[\"font.family\"] = \"sans-serif\"\nplt.rcParams[\"font.sans-serif\"] = [\"Nimbus Sans\"]\nprint_text(\"Hello World! 02\")\n\n\n# %%\n# Choose default monospace font\n\nplt.rcParams[\"font.family\"] = \"monospace\"\nprint_text(\"Hello World! 03\")\n\n\n# %%\n# Choose monospace font and specify to it to \"FreeMono\"\n\nplt.rcParams[\"font.family\"] = \"monospace\"\nplt.rcParams[\"font.monospace\"] = [\"FreeMono\"]\nprint_text(\"Hello World! 04\")\n"
    },
    {
      "filename": "font_file.py",
      "title": "Font File",
      "code": "r\"\"\"\n====================\nUsing ttf font files\n====================\n\nAlthough it is usually not a good idea to explicitly point to a single ttf file\nfor a font instance, you can do so by passing a `pathlib.Path` instance as the\n*font* parameter.  Note that passing paths as `str`\\s is intentionally not\nsupported, but you can simply wrap `str`\\s in `pathlib.Path`\\s as needed.\n\nHere, we use the Computer Modern roman font (``cmr10``) shipped with\nMatplotlib.\n\nFor a more flexible solution, see\n:doc:`/gallery/text_labels_and_annotations/font_family_rc` and\n:doc:`/gallery/text_labels_and_annotations/fonts_demo`.\n\"\"\"\n\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib as mpl\n\nfig, ax = plt.subplots()\n\nfpath = Path(mpl.get_data_path(), \"fonts/ttf/cmr10.ttf\")\nax.set_title(f'This is a special font: {fpath.name}', font=fpath)\nax.set_xlabel('This is the default font')\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.set_title`\n"
    },
    {
      "filename": "font_table.py",
      "title": "Font Table",
      "code": "\"\"\"\n==========\nFont table\n==========\n\nMatplotlib's font support is provided by the FreeType library.\n\nHere, we use `~.Axes.table` to draw a table that shows the glyphs by Unicode\ncodepoint. For brevity, the table only contains the first 256 glyphs.\n\nThe example is a full working script. You can download it and use it to\ninvestigate a font by running ::\n\n    python font_table.py /path/to/font/file\n\"\"\"\n\nimport os\nfrom pathlib import Path\nimport unicodedata\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.font_manager as fm\nfrom matplotlib.ft2font import FT2Font\n\n\ndef print_glyphs(path):\n    \"\"\"\n    Print the all glyphs in the given font file to stdout.\n\n    Parameters\n    ----------\n    path : str or None\n        The path to the font file.  If None, use Matplotlib's default font.\n    \"\"\"\n    if path is None:\n        path = fm.findfont(fm.FontProperties())  # The default font.\n\n    font = FT2Font(path)\n\n    charmap = font.get_charmap()\n    max_indices_len = len(str(max(charmap.values())))\n\n    print(\"The font face contains the following glyphs:\")\n    for char_code, glyph_index in charmap.items():\n        char = chr(char_code)\n        name = unicodedata.name(\n                char,\n                f\"{char_code:#x} ({font.get_glyph_name(glyph_index)})\")\n        print(f\"{glyph_index:>{max_indices_len}} {char} {name}\")\n\n\ndef draw_font_table(path):\n    \"\"\"\n    Draw a font table of the first 255 chars of the given font.\n\n    Parameters\n    ----------\n    path : str or None\n        The path to the font file.  If None, use Matplotlib's default font.\n    \"\"\"\n    if path is None:\n        path = fm.findfont(fm.FontProperties())  # The default font.\n\n    font = FT2Font(path)\n    # A charmap is a mapping of \"character codes\" (in the sense of a character\n    # encoding, e.g. latin-1) to glyph indices (i.e. the internal storage table\n    # of the font face).\n    # In FreeType>=2.1, a Unicode charmap (i.e. mapping Unicode codepoints)\n    # is selected by default.  Moreover, recent versions of FreeType will\n    # automatically synthesize such a charmap if the font does not include one\n    # (this behavior depends on the font format; for example it is present\n    # since FreeType 2.0 for Type 1 fonts but only since FreeType 2.8 for\n    # TrueType (actually, SFNT) fonts).\n    # The code below (specifically, the ``chr(char_code)`` call) assumes that\n    # we have indeed selected a Unicode charmap.\n    codes = font.get_charmap().items()\n\n    labelc = [f\"{i:X}\" for i in range(16)]\n    labelr = [f\"{i:02X}\" for i in range(0, 16*16, 16)]\n    chars = [[\"\" for c in range(16)] for r in range(16)]\n\n    for char_code, glyph_index in codes:\n        if char_code >= 256:\n            continue\n        row, col = divmod(char_code, 16)\n        chars[row][col] = chr(char_code)\n\n    fig, ax = plt.subplots(figsize=(8, 4))\n    ax.set_title(os.path.basename(path))\n    ax.set_axis_off()\n\n    table = ax.table(\n        cellText=chars,\n        rowLabels=labelr,\n        colLabels=labelc,\n        rowColours=[\"palegreen\"] * 16,\n        colColours=[\"palegreen\"] * 16,\n        cellColours=[[\".95\" for c in range(16)] for r in range(16)],\n        cellLoc='center',\n        loc='upper left',\n    )\n    for key, cell in table.get_celld().items():\n        row, col = key\n        if row > 0 and col > -1:  # Beware of table's idiosyncratic indexing...\n            cell.set_text_props(font=Path(path))\n\n    fig.tight_layout()\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    from argparse import ArgumentParser\n\n    parser = ArgumentParser(description=\"Display a font table.\")\n    parser.add_argument(\"path\", nargs=\"?\", help=\"Path to the font file.\")\n    parser.add_argument(\"--print-all\", action=\"store_true\",\n                        help=\"Additionally, print all chars to stdout.\")\n    args = parser.parse_args()\n\n    if args.print_all:\n        print_glyphs(args.path)\n    draw_font_table(args.path)\n"
    },
    {
      "filename": "fonts_demo.py",
      "title": "Fonts Demo",
      "code": "\"\"\"\n==================================\nFonts demo (object-oriented style)\n==================================\n\nSet font properties using setters.\n\nSee :doc:`fonts_demo_kw` to achieve the same effect using keyword arguments.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.font_manager import FontProperties\n\nfig = plt.figure()\nalignment = {'horizontalalignment': 'center', 'verticalalignment': 'baseline'}\nyp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]\nheading_font = FontProperties(size='large')\n\n# Show family options\nfig.text(0.1, 0.9, 'family', fontproperties=heading_font, **alignment)\nfamilies = ['serif', 'sans-serif', 'cursive', 'fantasy', 'monospace']\nfor k, family in enumerate(families):\n    font = FontProperties(family=[family])\n    fig.text(0.1, yp[k], family, fontproperties=font, **alignment)\n\n# Show style options\nstyles = ['normal', 'italic', 'oblique']\nfig.text(0.3, 0.9, 'style', fontproperties=heading_font, **alignment)\nfor k, style in enumerate(styles):\n    font = FontProperties(family='sans-serif', style=style)\n    fig.text(0.3, yp[k], style, fontproperties=font, **alignment)\n\n# Show variant options\nvariants = ['normal', 'small-caps']\nfig.text(0.5, 0.9, 'variant', fontproperties=heading_font, **alignment)\nfor k, variant in enumerate(variants):\n    font = FontProperties(family='serif', variant=variant)\n    fig.text(0.5, yp[k], variant, fontproperties=font, **alignment)\n\n# Show weight options\nweights = ['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']\nfig.text(0.7, 0.9, 'weight', fontproperties=heading_font, **alignment)\nfor k, weight in enumerate(weights):\n    font = FontProperties(weight=weight)\n    fig.text(0.7, yp[k], weight, fontproperties=font, **alignment)\n\n# Show size options\nsizes = [\n    'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large']\nfig.text(0.9, 0.9, 'size', fontproperties=heading_font, **alignment)\nfor k, size in enumerate(sizes):\n    font = FontProperties(size=size)\n    fig.text(0.9, yp[k], size, fontproperties=font, **alignment)\n\n# Show bold italic\nfont = FontProperties(style='italic', weight='bold', size='x-small')\nfig.text(0.3, 0.1, 'bold italic', fontproperties=font, **alignment)\nfont = FontProperties(style='italic', weight='bold', size='medium')\nfig.text(0.3, 0.2, 'bold italic', fontproperties=font, **alignment)\nfont = FontProperties(style='italic', weight='bold', size='x-large')\nfig.text(0.3, 0.3, 'bold italic', fontproperties=font, **alignment)\n\nplt.show()\n"
    },
    {
      "filename": "fonts_demo_kw.py",
      "title": "Fonts Demo Kw",
      "code": "\"\"\"\n==============================\nFonts demo (keyword arguments)\n==============================\n\nSet font properties using keyword arguments.\n\nSee :doc:`fonts_demo` to achieve the same effect using setters.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig = plt.figure()\nalignment = {'horizontalalignment': 'center', 'verticalalignment': 'baseline'}\nyp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]\n\n# Show family options\nfig.text(0.1, 0.9, 'family', size='large', **alignment)\nfamilies = ['serif', 'sans-serif', 'cursive', 'fantasy', 'monospace']\nfor k, family in enumerate(families):\n    fig.text(0.1, yp[k], family, family=family, **alignment)\n\n# Show style options\nfig.text(0.3, 0.9, 'style', **alignment)\nstyles = ['normal', 'italic', 'oblique']\nfor k, style in enumerate(styles):\n    fig.text(0.3, yp[k], style, family='sans-serif', style=style, **alignment)\n\n# Show variant options\nfig.text(0.5, 0.9, 'variant', **alignment)\nvariants = ['normal', 'small-caps']\nfor k, variant in enumerate(variants):\n    fig.text(0.5, yp[k], variant, family='serif', variant=variant, **alignment)\n\n# Show weight options\nfig.text(0.7, 0.9, 'weight', **alignment)\nweights = ['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']\nfor k, weight in enumerate(weights):\n    fig.text(0.7, yp[k], weight, weight=weight, **alignment)\n\n# Show size options\nfig.text(0.9, 0.9, 'size', **alignment)\nsizes = [\n    'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large']\nfor k, size in enumerate(sizes):\n    fig.text(0.9, yp[k], size, size=size, **alignment)\n\n# Show bold italic\nfig.text(0.3, 0.1, 'bold italic',\n         style='italic', weight='bold', size='x-small', **alignment)\nfig.text(0.3, 0.2, 'bold italic',\n         style='italic', weight='bold', size='medium', **alignment)\nfig.text(0.3, 0.3, 'bold italic',\n         style='italic', weight='bold', size='x-large', **alignment)\n\nplt.show()\n"
    },
    {
      "filename": "label_subplots.py",
      "title": "Label Subplots",
      "code": "\"\"\"\n==================\nLabelling subplots\n==================\n\nLabelling subplots is relatively straightforward, and varies, so Matplotlib\ndoes not have a general method for doing this.\n\nWe showcase two methods to position text at a given physical offset (in\nfontsize units or in points) away from a corner of the Axes: one using\n`~.Axes.annotate`, and one using `.ScaledTranslation`.\n\nFor convenience, this example uses `.pyplot.subplot_mosaic` and subplot\nlabels as keys for the subplots.  However, the approach also works with\n`.pyplot.subplots` or keys that are different from what you want to label the\nsubplot with.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.transforms import ScaledTranslation\n\n# %%\nfig, axs = plt.subplot_mosaic([['a)', 'c)'], ['b)', 'c)'], ['d)', 'd)']],\n                              layout='constrained')\nfor label, ax in axs.items():\n    # Use Axes.annotate to put the label\n    # - at the top left corner (axes fraction (0, 1)),\n    # - offset half-a-fontsize right and half-a-fontsize down\n    #   (offset fontsize (+0.5, -0.5)),\n    # i.e. just inside the axes.\n    ax.annotate(\n        label,\n        xy=(0, 1), xycoords='axes fraction',\n        xytext=(+0.5, -0.5), textcoords='offset fontsize',\n        fontsize='medium', verticalalignment='top', fontfamily='serif',\n        bbox=dict(facecolor='0.7', edgecolor='none', pad=3.0))\n\n# %%\nfig, axs = plt.subplot_mosaic([['a)', 'c)'], ['b)', 'c)'], ['d)', 'd)']],\n                              layout='constrained')\nfor label, ax in axs.items():\n    # Use ScaledTranslation to put the label\n    # - at the top left corner (axes fraction (0, 1)),\n    # - offset 20 pixels left and 7 pixels up (offset points (-20, +7)),\n    # i.e. just outside the axes.\n    ax.text(\n        0.0, 1.0, label, transform=(\n            ax.transAxes + ScaledTranslation(-20/72, +7/72, fig.dpi_scale_trans)),\n        fontsize='medium', va='bottom', fontfamily='serif')\n\n# %%\n# If we want it aligned with the title, either incorporate in the title or\n# use the *loc* keyword argument:\n\nfig, axs = plt.subplot_mosaic([['a)', 'c)'], ['b)', 'c)'], ['d)', 'd)']],\n                              layout='constrained')\nfor label, ax in axs.items():\n    ax.set_title('Normal Title', fontstyle='italic')\n    ax.set_title(label, fontfamily='serif', loc='left', fontsize='medium')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure.subplot_mosaic` /\n#      `matplotlib.pyplot.subplot_mosaic`\n#    - `matplotlib.axes.Axes.set_title`\n#    - `matplotlib.axes.Axes.annotate`\n"
    },
    {
      "filename": "legend.py",
      "title": "Legend",
      "code": "\"\"\"\n===============================\nLegend using pre-defined labels\n===============================\n\nDefining legend labels with plots.\n\"\"\"\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Make some fake data.\na = b = np.arange(0, 3, .02)\nc = np.exp(a)\nd = c[::-1]\n\n# Create plots with pre-defined labels.\nfig, ax = plt.subplots()\nax.plot(a, c, 'k--', label='Model length')\nax.plot(a, d, 'k:', label='Data length')\nax.plot(a, c + d, 'k', label='Total message length')\n\nlegend = ax.legend(loc='upper center', shadow=True, fontsize='x-large')\n\n# Put a nicer background color on the legend.\nlegend.get_frame().set_facecolor('C0')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n#    - `matplotlib.axes.Axes.legend` / `matplotlib.pyplot.legend`\n"
    },
    {
      "filename": "legend_demo.py",
      "title": "Legend Demo",
      "code": "\"\"\"\n===========\nLegend Demo\n===========\n\nThere are many ways to create and customize legends in Matplotlib. Below\nwe'll show a few examples for how to do so.\n\nFirst we'll show off how to make a legend for specific lines.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.collections as mcol\nfrom matplotlib.legend_handler import HandlerLineCollection, HandlerTuple\nfrom matplotlib.lines import Line2D\n\nt1 = np.arange(0.0, 2.0, 0.1)\nt2 = np.arange(0.0, 2.0, 0.01)\n\nfig, ax = plt.subplots()\n\n# note that plot returns a list of lines.  The \"l1, = plot\" usage\n# extracts the first element of the list into l1 using tuple\n# unpacking.  So l1 is a Line2D instance, not a sequence of lines\nl1, = ax.plot(t2, np.exp(-t2))\nl2, l3 = ax.plot(t2, np.sin(2 * np.pi * t2), '--o', t1, np.log(1 + t1), '.')\nl4, = ax.plot(t2, np.exp(-t2) * np.sin(2 * np.pi * t2), 's-.')\n\nax.legend((l2, l4), ('oscillatory', 'damped'), loc='upper right', shadow=True)\nax.set_xlabel('time')\nax.set_ylabel('volts')\nax.set_title('Damped oscillation')\nplt.show()\n\n\n# %%\n# Next we'll demonstrate plotting more complex labels.\n\nx = np.linspace(0, 1)\n\nfig, (ax0, ax1) = plt.subplots(2, 1)\n\n# Plot the lines y=x**n for n=1..4.\nfor n in range(1, 5):\n    ax0.plot(x, x**n, label=f\"{n=}\")\nleg = ax0.legend(loc=\"upper left\", bbox_to_anchor=[0, 1],\n                 ncols=2, shadow=True, title=\"Legend\", fancybox=True)\nleg.get_title().set_color(\"red\")\n\n# Demonstrate some more complex labels.\nax1.plot(x, x**2, label=\"multi\\nline\")\nhalf_pi = np.linspace(0, np.pi / 2)\nax1.plot(np.sin(half_pi), np.cos(half_pi), label=r\"$\\frac{1}{2}\\pi$\")\nax1.plot(x, 2**(x**2), label=\"$2^{x^2}$\")\nax1.legend(shadow=True, fancybox=True)\n\nplt.show()\n\n\n# %%\n# Here we attach legends to more complex plots.\n\nfig, axs = plt.subplots(3, 1, layout=\"constrained\")\ntop_ax, middle_ax, bottom_ax = axs\n\ntop_ax.bar([0, 1, 2], [0.2, 0.3, 0.1], width=0.4, label=\"Bar 1\",\n           align=\"center\")\ntop_ax.bar([0.5, 1.5, 2.5], [0.3, 0.2, 0.2], color=\"red\", width=0.4,\n           label=\"Bar 2\", align=\"center\")\ntop_ax.legend()\n\nmiddle_ax.errorbar([0, 1, 2], [2, 3, 1], xerr=0.4, fmt=\"s\", label=\"test 1\")\nmiddle_ax.errorbar([0, 1, 2], [3, 2, 4], yerr=0.3, fmt=\"o\", label=\"test 2\")\nmiddle_ax.errorbar([0, 1, 2], [1, 1, 3], xerr=0.4, yerr=0.3, fmt=\"^\",\n                   label=\"test 3\")\nmiddle_ax.legend()\n\nbottom_ax.stem([0.3, 1.5, 2.7], [1, 3.6, 2.7], label=\"stem test\")\nbottom_ax.legend()\n\nplt.show()\n\n# %%\n# Now we'll showcase legend entries with more than one legend key.\n\nfig, (ax1, ax2) = plt.subplots(2, 1, layout='constrained')\n\n# First plot: two legend keys for a single entry\np1 = ax1.scatter([1], [5], c='r', marker='s', s=100)\np2 = ax1.scatter([3], [2], c='b', marker='o', s=100)\n# `plot` returns a list, but we want the handle - thus the comma on the left\np3, = ax1.plot([1, 5], [4, 4], 'm-d')\n\n# Assign two of the handles to the same legend entry by putting them in a tuple\n# and using a generic handler map (which would be used for any additional\n# tuples of handles like (p1, p3)).\nl = ax1.legend([(p1, p3), p2], ['two keys', 'one key'], scatterpoints=1,\n               numpoints=1, handler_map={tuple: HandlerTuple(ndivide=None)})\n\n# Second plot: plot two bar charts on top of each other and change the padding\n# between the legend keys\nx_left = [1, 2, 3]\ny_pos = [1, 3, 2]\ny_neg = [2, 1, 4]\n\nrneg = ax2.bar(x_left, y_neg, width=0.5, color='w', hatch='///', label='-1')\nrpos = ax2.bar(x_left, y_pos, width=0.5, color='k', label='+1')\n\n# Treat each legend entry differently by using specific `HandlerTuple`s\nl = ax2.legend([(rpos, rneg), (rneg, rpos)], ['pad!=0', 'pad=0'],\n               handler_map={(rpos, rneg): HandlerTuple(ndivide=None),\n                            (rneg, rpos): HandlerTuple(ndivide=None, pad=0.)})\nplt.show()\n\n# %%\n# Finally, it is also possible to write custom classes that define\n# how to stylize legends.\n\n\nclass HandlerDashedLines(HandlerLineCollection):\n    \"\"\"\n    Custom Handler for LineCollection instances.\n    \"\"\"\n    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize, trans):\n        # figure out how many lines there are\n        numlines = len(orig_handle.get_segments())\n        xdata, xdata_marker = self.get_xdata(legend, xdescent, ydescent,\n                                             width, height, fontsize)\n        leglines = []\n        # divide the vertical space where the lines will go\n        # into equal parts based on the number of lines\n        ydata = np.full_like(xdata, height / (numlines + 1))\n        # for each line, create the line at the proper location\n        # and set the dash pattern\n        for i in range(numlines):\n            legline = Line2D(xdata, ydata * (numlines - i) - ydescent)\n            self.update_prop(legline, orig_handle, legend)\n            # set color, dash pattern, and linewidth to that\n            # of the lines in linecollection\n            try:\n                color = orig_handle.get_colors()[i]\n            except IndexError:\n                color = orig_handle.get_colors()[0]\n            try:\n                dashes = orig_handle.get_dashes()[i]\n            except IndexError:\n                dashes = orig_handle.get_dashes()[0]\n            try:\n                lw = orig_handle.get_linewidths()[i]\n            except IndexError:\n                lw = orig_handle.get_linewidths()[0]\n            if dashes[1] is not None:\n                legline.set_dashes(dashes[1])\n            legline.set_color(color)\n            legline.set_transform(trans)\n            legline.set_linewidth(lw)\n            leglines.append(legline)\n        return leglines\n\nx = np.linspace(0, 5, 100)\n\nfig, ax = plt.subplots()\ncolors = plt.rcParams['axes.prop_cycle'].by_key()['color'][:5]\nstyles = ['solid', 'dashed', 'dashed', 'dashed', 'solid']\nfor i, color, style in zip(range(5), colors, styles):\n    ax.plot(x, np.sin(x) - .1 * i, c=color, ls=style)\n\n# make proxy artists\n# make list of one line -- doesn't matter what the coordinates are\nline = [[(0, 0)]]\n# set up the proxy artist\nlc = mcol.LineCollection(5 * line, linestyles=styles, colors=colors)\n# create the legend\nax.legend([lc], ['multi-line'], handler_map={type(lc): HandlerDashedLines()},\n          handlelength=2.5, handleheight=3)\n\nplt.show()\n"
    },
    {
      "filename": "line_with_text.py",
      "title": "Line With Text",
      "code": "\"\"\"\n=======================\nArtist within an artist\n=======================\n\nOverride basic methods so an artist can contain another\nartist.  In this case, the line contains a Text instance to label it.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.lines as lines\nimport matplotlib.text as mtext\nimport matplotlib.transforms as mtransforms\n\n\nclass MyLine(lines.Line2D):\n    def __init__(self, *args, **kwargs):\n        # we'll update the position when the line data is set\n        self.text = mtext.Text(0, 0, '')\n        super().__init__(*args, **kwargs)\n\n        # we can't access the label attr until *after* the line is\n        # initiated\n        self.text.set_text(self.get_label())\n\n    def set_figure(self, figure):\n        self.text.set_figure(figure)\n        super().set_figure(figure)\n\n    # Override the Axes property setter to set Axes on our children as well.\n    @lines.Line2D.axes.setter\n    def axes(self, new_axes):\n        self.text.axes = new_axes\n        lines.Line2D.axes.fset(self, new_axes)  # Call the superclass property setter.\n\n    def set_transform(self, transform):\n        # 2 pixel offset\n        texttrans = transform + mtransforms.Affine2D().translate(2, 2)\n        self.text.set_transform(texttrans)\n        super().set_transform(transform)\n\n    def set_data(self, x, y):\n        if len(x):\n            self.text.set_position((x[-1], y[-1]))\n\n        super().set_data(x, y)\n\n    def draw(self, renderer):\n        # draw my label at the end of the line with 2 pixel offset\n        super().draw(renderer)\n        self.text.draw(renderer)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nx, y = np.random.rand(2, 20)\nline = MyLine(x, y, mfc='red', ms=12, label='line label')\nline.text.set_color('red')\nline.text.set_fontsize(16)\n\nax.add_line(line)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.lines`\n#    - `matplotlib.lines.Line2D`\n#    - `matplotlib.lines.Line2D.set_data`\n#    - `matplotlib.artist`\n#    - `matplotlib.artist.Artist`\n#    - `matplotlib.artist.Artist.draw`\n#    - `matplotlib.artist.Artist.set_transform`\n#    - `matplotlib.text`\n#    - `matplotlib.text.Text`\n#    - `matplotlib.text.Text.set_color`\n#    - `matplotlib.text.Text.set_fontsize`\n#    - `matplotlib.text.Text.set_position`\n#    - `matplotlib.axes.Axes.add_line`\n#    - `matplotlib.transforms`\n#    - `matplotlib.transforms.Affine2D`\n"
    },
    {
      "filename": "mathtext_asarray.py",
      "title": "Mathtext Asarray",
      "code": "\"\"\"\n=======================\nConvert texts to images\n=======================\n\"\"\"\n\nfrom io import BytesIO\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.figure import Figure\nfrom matplotlib.transforms import IdentityTransform\n\n\ndef text_to_rgba(s, *, dpi, **kwargs):\n    # To convert a text string to an image, we can:\n    # - draw it on an empty and transparent figure;\n    # - save the figure to a temporary buffer using ``bbox_inches=\"tight\",\n    #   pad_inches=0`` which will pick the correct area to save;\n    # - load the buffer using ``plt.imread``.\n    #\n    # (If desired, one can also directly save the image to the filesystem.)\n    fig = Figure(facecolor=\"none\")\n    fig.text(0, 0, s, **kwargs)\n    with BytesIO() as buf:\n        fig.savefig(buf, dpi=dpi, format=\"png\", bbox_inches=\"tight\",\n                    pad_inches=0)\n        buf.seek(0)\n        rgba = plt.imread(buf)\n    return rgba\n\n\nfig = plt.figure()\nrgba1 = text_to_rgba(r\"IQ: $\\sigma_i=15$\", color=\"blue\", fontsize=20, dpi=200)\nrgba2 = text_to_rgba(r\"some other string\", color=\"red\", fontsize=20, dpi=200)\n# One can then draw such text images to a Figure using `.Figure.figimage`.\nfig.figimage(rgba1, 100, 50)\nfig.figimage(rgba2, 100, 150)\n\n# One can also directly draw texts to a figure with positioning\n# in pixel coordinates by using `.Figure.text` together with\n# `.transforms.IdentityTransform`.\nfig.text(100, 250, r\"IQ: $\\sigma_i=15$\", color=\"blue\", fontsize=20,\n         transform=IdentityTransform())\nfig.text(100, 350, r\"some other string\", color=\"red\", fontsize=20,\n         transform=IdentityTransform())\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure.figimage`\n#    - `matplotlib.figure.Figure.text`\n#    - `matplotlib.transforms.IdentityTransform`\n#    - `matplotlib.image.imread`\n"
    },
    {
      "filename": "mathtext_demo.py",
      "title": "Mathtext Demo",
      "code": "\"\"\"\n========\nMathtext\n========\n\nUse Matplotlib's internal LaTeX parser and layout engine.  For true LaTeX\nrendering, see the text.usetex option.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nax.plot([1, 2, 3], label=r'$\\sqrt{x^2}$')\nax.legend()\n\nax.set_xlabel(r'$\\Delta_i^j$', fontsize=20)\nax.set_ylabel(r'$\\Delta_{i+1}^j$', fontsize=20)\nax.set_title(r'$\\Delta_i^j \\hspace{0.4} \\mathrm{versus} \\hspace{0.4} '\n             r'\\Delta_{i+1}^j$', fontsize=20)\n\ntex = r'$\\mathcal{R}\\prod_{i=\\alpha_{i+1}}^\\infty a_i\\sin(2 \\pi f x_i)$'\nax.text(1, 1.6, tex, fontsize=20, va='bottom')\n\nfig.tight_layout()\nplt.show()\n"
    },
    {
      "filename": "mathtext_examples.py",
      "title": "Mathtext Examples",
      "code": "\"\"\"\n========================\nMathematical expressions\n========================\n\nSelected features of Matplotlib's math rendering engine.\n\"\"\"\nimport re\nimport subprocess\nimport sys\n\nimport matplotlib.pyplot as plt\n\n# Selection of features following \"Writing mathematical expressions\" tutorial,\n# with randomly picked examples.\nmathtext_demos = {\n    \"Header demo\":\n        r\"$W^{3\\beta}_{\\delta_1 \\rho_1 \\sigma_2} = \"\n        r\"U^{3\\beta}_{\\delta_1 \\rho_1} + \\frac{1}{8 \\pi 2} \"\n        r\"\\int^{\\alpha_2}_{\\alpha_2} d \\alpha^\\prime_2 \\left[\\frac{ \"\n        r\"U^{2\\beta}_{\\delta_1 \\rho_1} - \\alpha^\\prime_2U^{1\\beta}_\"\n        r\"{\\rho_1 \\sigma_2} }{U^{0\\beta}_{\\rho_1 \\sigma_2}}\\right]$\",\n\n    \"Subscripts and superscripts\":\n        r\"$\\alpha_i > \\beta_i,\\ \"\n        r\"\\alpha_{i+1}^j = {\\rm sin}(2\\pi f_j t_i) e^{-5 t_i/\\tau},\\ \"\n        r\"\\ldots$\",\n\n    \"Fractions, binomials and stacked numbers\":\n        r\"$\\frac{3}{4},\\ \\binom{3}{4},\\ \\genfrac{}{}{0}{}{3}{4},\\ \"\n        r\"\\left(\\frac{5 - \\frac{1}{x}}{4}\\right),\\ \\ldots$\",\n\n    \"Radicals\":\n        r\"$\\sqrt{2},\\ \\sqrt[3]{x},\\ \\ldots$\",\n\n    \"Fonts\":\n        r\"$\\mathrm{Roman}\\ , \\ \\mathit{Italic}\\ , \\ \\mathtt{Typewriter} \\ \"\n        r\"\\mathrm{or}\\ \\mathcal{CALLIGRAPHY}$\",\n\n    \"Accents\":\n        r\"$\\acute a,\\ \\bar a,\\ \\breve a,\\ \\dot a,\\ \\ddot a, \\ \\grave a, \\ \"\n        r\"\\hat a,\\ \\tilde a,\\ \\vec a,\\ \\widehat{xyz},\\ \\widetilde{xyz},\\ \"\n        r\"\\ldots$\",\n\n    \"Greek, Hebrew\":\n        r\"$\\alpha,\\ \\beta,\\ \\chi,\\ \\delta,\\ \\lambda,\\ \\mu,\\ \"\n        r\"\\Delta,\\ \\Gamma,\\ \\Omega,\\ \\Phi,\\ \\Pi,\\ \\Upsilon,\\ \\nabla,\\ \"\n        r\"\\aleph,\\ \\beth,\\ \\daleth,\\ \\gimel,\\ \\ldots$\",\n\n    \"Delimiters, functions and Symbols\":\n        r\"$\\coprod,\\ \\int,\\ \\oint,\\ \\prod,\\ \\sum,\\ \"\n        r\"\\log,\\ \\sin,\\ \\approx,\\ \\oplus,\\ \\star,\\ \\varpropto,\\ \"\n        r\"\\infty,\\ \\partial,\\ \\Re,\\ \\leftrightsquigarrow, \\ \\ldots$\",\n}\nn_lines = len(mathtext_demos)\n\n\ndef doall():\n    # Colors used in Matplotlib online documentation.\n    mpl_grey_rgb = (51 / 255, 51 / 255, 51 / 255)\n\n    # Creating figure and axis.\n    fig = plt.figure(figsize=(7, 7))\n    ax = fig.add_axes([0.01, 0.01, 0.98, 0.90],\n                      facecolor=\"white\", frameon=True)\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_title(\"Matplotlib's math rendering engine\",\n                 color=mpl_grey_rgb, fontsize=14, weight='bold')\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    # Gap between lines in axes coords\n    line_axesfrac = 1 / n_lines\n\n    # Plot header demonstration formula.\n    full_demo = mathtext_demos['Header demo']\n    ax.annotate(full_demo,\n                xy=(0.5, 1. - 0.59 * line_axesfrac),\n                color='tab:orange', ha='center', fontsize=20)\n\n    # Plot feature demonstration formulae.\n    for i_line, (title, demo) in enumerate(mathtext_demos.items()):\n        print(i_line, demo)\n        if i_line == 0:\n            continue\n\n        baseline = 1 - i_line * line_axesfrac\n        baseline_next = baseline - line_axesfrac\n        fill_color = ['white', 'tab:blue'][i_line % 2]\n        ax.axhspan(baseline, baseline_next, color=fill_color, alpha=0.2)\n        ax.annotate(f'{title}:',\n                    xy=(0.06, baseline - 0.3 * line_axesfrac),\n                    color=mpl_grey_rgb, weight='bold')\n        ax.annotate(demo,\n                    xy=(0.04, baseline - 0.75 * line_axesfrac),\n                    color=mpl_grey_rgb, fontsize=16)\n\n    plt.show()\n\n\nif '--latex' in sys.argv:\n    # Run: python mathtext_examples.py --latex\n    # Need amsmath and amssymb packages.\n    with open(\"mathtext_examples.ltx\", \"w\") as fd:\n        fd.write(\"\\\\documentclass{article}\\n\")\n        fd.write(\"\\\\usepackage{amsmath, amssymb}\\n\")\n        fd.write(\"\\\\begin{document}\\n\")\n        fd.write(\"\\\\begin{enumerate}\\n\")\n\n        for s in mathtext_demos.values():\n            s = re.sub(r\"(?<!\\\\)\\$\", \"$$\", s)\n            fd.write(\"\\\\item %s\\n\" % s)\n\n        fd.write(\"\\\\end{enumerate}\\n\")\n        fd.write(\"\\\\end{document}\\n\")\n\n    subprocess.call([\"pdflatex\", \"mathtext_examples.ltx\"])\nelse:\n    doall()\n"
    },
    {
      "filename": "mathtext_fontfamily_example.py",
      "title": "Mathtext Fontfamily Example",
      "code": "\"\"\"\n===============\nMath fontfamily\n===============\n\nA simple example showcasing the new *math_fontfamily* parameter that can\nbe used to change the family of fonts for each individual text\nelement in a plot.\n\nIf no parameter is set, the global value\n:rc:`mathtext.fontset` will be used.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 5))\n\n# A simple plot for the background.\nax.plot(range(11), color=\"0.9\")\n\n# A text mixing normal text and math text.\nmsg = (r\"Normal Text. $Text\\ in\\ math\\ mode:\\ \"\n       r\"\\int_{0}^{\\infty } x^2 dx$\")\n\n# Set the text in the plot.\nax.text(1, 7, msg, size=12, math_fontfamily='cm')\n\n# Set another font for the next text.\nax.text(1, 3, msg, size=12, math_fontfamily='dejavuserif')\n\n# *math_fontfamily* can be used in most places where there is text,\n# like in the title:\nax.set_title(r\"$Title\\ in\\ math\\ mode:\\ \\int_{0}^{\\infty } x^2 dx$\",\n             math_fontfamily='stixsans', size=14)\n\n# Note that the normal text is not changed by *math_fontfamily*.\nplt.show()\n"
    },
    {
      "filename": "multiline.py",
      "title": "Multiline",
      "code": "\"\"\"\n=========\nMultiline\n=========\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(7, 4))\n\nax0.set_aspect(1)\nax0.plot(np.arange(10))\nax0.set_xlabel('this is a xlabel\\n(with newlines!)')\nax0.set_ylabel('this is vertical\\ntest', multialignment='center')\nax0.text(2, 7, 'this is\\nyet another test',\n         rotation=45,\n         horizontalalignment='center',\n         verticalalignment='top',\n         multialignment='center')\n\nax0.grid()\n\n\nax1.text(0.29, 0.4, \"Mat\\nTTp\\n123\", size=18,\n         va=\"baseline\", ha=\"right\", multialignment=\"left\",\n         bbox=dict(fc=\"none\"))\n\nax1.text(0.34, 0.4, \"Mag\\nTTT\\n123\", size=18,\n         va=\"baseline\", ha=\"left\", multialignment=\"left\",\n         bbox=dict(fc=\"none\"))\n\nax1.text(0.95, 0.4, \"Mag\\nTTT$^{A^A}$\\n123\", size=18,\n         va=\"baseline\", ha=\"right\", multialignment=\"left\",\n         bbox=dict(fc=\"none\"))\n\nax1.set_xticks([0.2, 0.4, 0.6, 0.8, 1.],\n               labels=[\"Jan\\n2009\", \"Feb\\n2009\", \"Mar\\n2009\", \"Apr\\n2009\",\n                       \"May\\n2009\"])\n\nax1.axhline(0.4)\nax1.set_title(\"test line spacing for multiline text\")\n\nfig.subplots_adjust(bottom=0.25, top=0.75)\nplt.show()\n"
    },
    {
      "filename": "placing_text_boxes.py",
      "title": "Placing Text Boxes",
      "code": "\"\"\"\nPlacing text boxes\n==================\n\nWhen decorating Axes with text boxes, two useful tricks are to place the text\nin axes coordinates (see :ref:`transforms_tutorial`),\nso the text doesn't move around with changes in x or y limits.  You\ncan also use the ``bbox`` property of text to surround the text with a\n`~matplotlib.patches.Patch` instance -- the ``bbox`` keyword argument takes a\ndictionary with keys that are Patch properties.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nx = 30*np.random.randn(10000)\nmu = x.mean()\nmedian = np.median(x)\nsigma = x.std()\ntextstr = '\\n'.join((\n    r'$\\mu=%.2f$' % (mu, ),\n    r'$\\mathrm{median}=%.2f$' % (median, ),\n    r'$\\sigma=%.2f$' % (sigma, )))\n\nax.hist(x, 50)\n# these are matplotlib.patch.Patch properties\nprops = dict(boxstyle='round', facecolor='wheat', alpha=0.5)\n\n# place a text box in upper left in axes coords\nax.text(0.05, 0.95, textstr, transform=ax.transAxes, fontsize=14,\n        verticalalignment='top', bbox=props)\n\nplt.show()\n"
    },
    {
      "filename": "rainbow_text.py",
      "title": "Rainbow Text",
      "code": "\"\"\"\n==================================================\nConcatenate text objects with different properties\n==================================================\n\nThe example strings together several Text objects with different properties\n(e.g., color or font), positioning each one after the other.  The first Text\nis created directly using `~.Axes.text`; all subsequent ones are created with\n`~.Axes.annotate`, which allows positioning the Text's lower left corner at the\nlower right corner (``xy=(1, 0)``) of the previous one (``xycoords=text``).\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nplt.rcParams[\"font.size\"] = 20\nax = plt.figure().add_subplot(xticks=[], yticks=[])\n\n# The first word, created with text().\ntext = ax.text(.1, .5, \"Matplotlib\", color=\"red\")\n# Subsequent words, positioned with annotate(), relative to the preceding one.\ntext = ax.annotate(\n    \" says,\", xycoords=text, xy=(1, 0), verticalalignment=\"bottom\",\n    color=\"gold\", weight=\"bold\")  # custom properties\ntext = ax.annotate(\n    \" hello\", xycoords=text, xy=(1, 0), verticalalignment=\"bottom\",\n    color=\"green\", style=\"italic\")  # custom properties\ntext = ax.annotate(\n    \" world!\", xycoords=text, xy=(1, 0), verticalalignment=\"bottom\",\n    color=\"blue\", family=\"serif\")  # custom properties\n\nplt.show()\n"
    },
    {
      "filename": "stix_fonts_demo.py",
      "title": "Stix Fonts Demo",
      "code": "\"\"\"\n==========\nSTIX Fonts\n==========\n\nDemonstration of `STIX Fonts <https://www.stixfonts.org/>`_ used in LaTeX\nrendering.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\ncircle123 = \"\\N{CIRCLED DIGIT ONE}\\N{CIRCLED DIGIT TWO}\\N{CIRCLED DIGIT THREE}\"\n\ntests = [\n    r'$%s\\;\\mathrm{%s}\\;\\mathbf{%s}$' % ((circle123,) * 3),\n    r'$\\mathsf{Sans \\Omega}\\;\\mathrm{\\mathsf{Sans \\Omega}}\\;'\n    r'\\mathbf{\\mathsf{Sans \\Omega}}$',\n    r'$\\mathtt{Monospace}$',\n    r'$\\mathcal{CALLIGRAPHIC}$',\n    r'$\\mathbb{Blackboard\\;\\pi}$',\n    r'$\\mathrm{\\mathbb{Blackboard\\;\\pi}}$',\n    r'$\\mathbf{\\mathbb{Blackboard\\;\\pi}}$',\n    r'$\\mathfrak{Fraktur}\\;\\mathbf{\\mathfrak{Fraktur}}$',\n    r'$\\mathscr{Script}$',\n]\n\nfig = plt.figure(figsize=(8, len(tests) + 2))\nfor i, s in enumerate(tests[::-1]):\n    fig.text(0, (i + .5) / len(tests), s, fontsize=32)\n\nplt.show()\n"
    },
    {
      "filename": "tex_demo.py",
      "title": "Tex Demo",
      "code": "\"\"\"\n===============================\nRender math equations using TeX\n===============================\n\nYou can use TeX to render all of your Matplotlib text by setting\n:rc:`text.usetex` to True.  This requires that you have TeX and the other\ndependencies described in the :ref:`usetex` tutorial properly\ninstalled on your system.  Matplotlib caches processed TeX expressions, so that\nonly the first occurrence of an expression triggers a TeX compilation. Later\noccurrences reuse the rendered image from the cache and are thus faster.\n\nUnicode input is supported, e.g. for the y-axis label in this example.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParams['text.usetex'] = True\n\n\nt = np.linspace(0.0, 1.0, 100)\ns = np.cos(4 * np.pi * t) + 2\n\nfig, ax = plt.subplots(figsize=(6, 4), tight_layout=True)\nax.plot(t, s)\n\nax.set_xlabel(r'\\textbf{time (s)}')\nax.set_ylabel('\\\\textit{Velocity (\\N{DEGREE SIGN}/sec)}', fontsize=16)\nax.set_title(r'\\TeX\\ is Number $\\displaystyle\\sum_{n=1}^\\infty'\n             r'\\frac{-e^{i\\pi}}{2^n}$!', fontsize=16, color='r')\n\n# %%\n# A more complex example.\n\nfig, ax = plt.subplots()\n# interface tracking profiles\nN = 500\ndelta = 0.6\nX = np.linspace(-1, 1, N)\nax.plot(X, (1 - np.tanh(4 * X / delta)) / 2,    # phase field tanh profiles\n        X, (1.4 + np.tanh(4 * X / delta)) / 4, \"C2\",  # composition profile\n        X, X < 0, \"k--\")                        # sharp interface\n\n# legend\nax.legend((\"phase field\", \"level set\", \"sharp interface\"),\n          shadow=True, loc=(0.01, 0.48), handlelength=1.5, fontsize=16)\n\n# the arrow\nax.annotate(\"\", xy=(-delta / 2., 0.1), xytext=(delta / 2., 0.1),\n            arrowprops=dict(arrowstyle=\"<->\", connectionstyle=\"arc3\"))\nax.text(0, 0.1, r\"$\\delta$\",\n        color=\"black\", fontsize=24,\n        horizontalalignment=\"center\", verticalalignment=\"center\",\n        bbox=dict(boxstyle=\"round\", fc=\"white\", ec=\"black\", pad=0.2))\n\n# Use tex in labels\nax.set_xticks([-1, 0, 1])\nax.set_xticklabels([\"$-1$\", r\"$\\pm 0$\", \"$+1$\"], color=\"k\", size=20)\n\n# Left Y-axis labels, combine math mode and text mode\nax.set_ylabel(r\"\\bf{phase field} $\\phi$\", color=\"C0\", fontsize=20)\nax.set_yticks([0, 0.5, 1])\nax.set_yticklabels([r\"\\bf{0}\", r\"\\bf{.5}\", r\"\\bf{1}\"], color=\"k\", size=20)\n\n# Right Y-axis labels\nax.text(1.02, 0.5, r\"\\bf{level set} $\\phi$\",\n        color=\"C2\", fontsize=20, rotation=90,\n        horizontalalignment=\"left\", verticalalignment=\"center\",\n        clip_on=False, transform=ax.transAxes)\n\n# Use multiline environment inside a `text`.\n# level set equations\neq1 = (r\"\\begin{eqnarray*}\"\n       r\"|\\nabla\\phi| &=& 1,\\\\\"\n       r\"\\frac{\\partial \\phi}{\\partial t} + U|\\nabla \\phi| &=& 0 \"\n       r\"\\end{eqnarray*}\")\nax.text(1, 0.9, eq1, color=\"C2\", fontsize=18,\n        horizontalalignment=\"right\", verticalalignment=\"top\")\n\n# phase field equations\neq2 = (r\"\\begin{eqnarray*}\"\n       r\"\\mathcal{F} &=& \\int f\\left( \\phi, c \\right) dV, \\\\ \"\n       r\"\\frac{ \\partial \\phi } { \\partial t } &=& -M_{ \\phi } \"\n       r\"\\frac{ \\delta \\mathcal{F} } { \\delta \\phi }\"\n       r\"\\end{eqnarray*}\")\nax.text(0.18, 0.18, eq2, color=\"C0\", fontsize=16)\n\nax.text(-1, .30, r\"gamma: $\\gamma$\", color=\"r\", fontsize=20)\nax.text(-1, .18, r\"Omega: $\\Omega$\", color=\"b\", fontsize=20)\n\nplt.show()\n"
    },
    {
      "filename": "text_alignment.py",
      "title": "Text Alignment",
      "code": "\"\"\"\n==============\nText alignment\n==============\n\nTexts are aligned relative to their anchor point depending on the properties\n``horizontalalignment`` (default: ``left``) and ``verticalalignment``\n(default: ``baseline``.)\n\n.. redirect-from:: /gallery/pyplots/text_layout\n\n.. plot::\n\n    import matplotlib.pyplot as plt\n    import numpy as np\n\n    y = [0.22, 0.34, 0.5, 0.56, 0.78]\n    x = [0.17, 0.5, 0.855]\n    X, Y = np.meshgrid(x, y)\n\n    fig, ax = plt.subplots(figsize=(6, 4), dpi=100)\n    ax.set(xlim=(0, 1), ylim=(0, 1), xticks=[], yticks=[])\n    ax.spines[:].set_visible(False)\n    ax.text(0.5, 0.5, 'plot', fontsize=128, ha='center', va='center', zorder=1)\n    ax.hlines(y, x[0], x[-1], color='grey')\n    ax.vlines(x, y[0], y[-1], color='grey')\n    ax.plot(X.ravel(), Y.ravel(), 'o')\n    pad_x = 0.02\n    pad_y = 0.04\n    ax.text(x[0] - pad_x, y[0], 'bottom', ha='right', va='center')\n    ax.text(x[0] - pad_x, y[1], 'baseline', ha='right', va='center')\n    ax.text(x[0] - pad_x, y[2], 'center', ha='right', va='center')\n    ax.text(x[0] - pad_x, y[3], 'center_baseline', ha='right', va='center')\n    ax.text(x[0] - pad_x, y[4], 'top', ha='right', va='center')\n    ax.text(x[0], y[0] - pad_y, 'left', ha='center', va='top')\n    ax.text(x[1], y[0] - pad_y, 'center', ha='center', va='top')\n    ax.text(x[2], y[0] - pad_y, 'right', ha='center', va='top')\n    ax.set_xlabel('horizontalalignment', fontsize=14)\n    ax.set_ylabel('verticalalignment', fontsize=14, labelpad=35)\n    ax.set_title(\n        'Relative position of text anchor point depending on alignment')\n    plt.show()\n\n\"\"\"\n\n# %%\n# The following plot uses this to align text relative to a plotted rectangle.\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\n# Build a rectangle in axes coords\nleft, width = .25, .5\nbottom, height = .25, .5\nright = left + width\ntop = bottom + height\np = plt.Rectangle((left, bottom), width, height, fill=False)\np.set_transform(ax.transAxes)\np.set_clip_on(False)\nax.add_patch(p)\n\nax.text(left, bottom, 'left top',\n        horizontalalignment='left',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, bottom, 'left bottom',\n        horizontalalignment='left',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right bottom',\n        horizontalalignment='right',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right top',\n        horizontalalignment='right',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(right, bottom, 'center top',\n        horizontalalignment='center',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, 0.5 * (bottom + top), 'right center',\n        horizontalalignment='right',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, 0.5 * (bottom + top), 'left center',\n        horizontalalignment='left',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(0.5 * (left + right), 0.5 * (bottom + top), 'middle',\n        horizontalalignment='center',\n        verticalalignment='center',\n        transform=ax.transAxes)\n\nax.text(right, 0.5 * (bottom + top), 'centered',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, top, 'rotated\\nwith newlines',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation=45,\n        transform=ax.transAxes)\n\nax.set_axis_off()\n\nplt.show()\n"
    },
    {
      "filename": "text_commands.py",
      "title": "Text Commands",
      "code": "\"\"\"\n===============\nText properties\n===============\n\nPlotting text of many different kinds.\n\n.. redirect-from:: /gallery/pyplots/text_commands\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig = plt.figure()\nfig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')\n\nax = fig.add_subplot()\nfig.subplots_adjust(top=0.85)\nax.set_title('axes title')\n\nax.set_xlabel('xlabel')\nax.set_ylabel('ylabel')\n\nax.text(3, 8, 'boxed italics text in data coords', style='italic',\n        bbox={'facecolor': 'red', 'alpha': 0.5, 'pad': 10})\n\nax.text(2, 6, r'an equation: $E=mc^2$', fontsize=15)\n\nax.text(3, 2, 'Unicode: Institut f\\374r Festk\\366rperphysik')\n\nax.text(0.95, 0.01, 'colored text in axes coords',\n        verticalalignment='bottom', horizontalalignment='right',\n        transform=ax.transAxes,\n        color='green', fontsize=15)\n\n\nax.plot([2], [1], 'o')\nax.annotate('annotate', xy=(2, 1), xytext=(3, 4),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\nax.set(xlim=(0, 10), ylim=(0, 10))\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure.suptitle`\n#    - `matplotlib.figure.Figure.add_subplot`\n#    - `matplotlib.figure.Figure.subplots_adjust`\n#    - `matplotlib.axes.Axes.set_title`\n#    - `matplotlib.axes.Axes.set_xlabel`\n#    - `matplotlib.axes.Axes.set_ylabel`\n#    - `matplotlib.axes.Axes.text`\n#    - `matplotlib.axes.Axes.annotate`\n"
    },
    {
      "filename": "text_fontdict.py",
      "title": "Text Fontdict",
      "code": "\"\"\"\n=======================================================\nControlling style of text and labels using a dictionary\n=======================================================\n\nThis example shows how to share parameters across many text objects and labels\nby creating a dictionary of options passed across several functions.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfont = {'family': 'serif',\n        'color':  'darkred',\n        'weight': 'normal',\n        'size': 16,\n        }\n\nx = np.linspace(0.0, 5.0, 100)\ny = np.cos(2*np.pi*x) * np.exp(-x)\n\nplt.plot(x, y, 'k')\nplt.title('Damped exponential decay', fontdict=font)\nplt.text(2, 0.65, r'$\\cos(2 \\pi t) \\exp(-t)$', fontdict=font)\nplt.xlabel('time (s)', fontdict=font)\nplt.ylabel('voltage (mV)', fontdict=font)\n\n# Tweak spacing to prevent clipping of ylabel\nplt.subplots_adjust(left=0.15)\nplt.show()\n"
    },
    {
      "filename": "text_rotation_relative_to_line.py",
      "title": "Text Rotation Relative To Line",
      "code": "\"\"\"\n=======================================\nText rotation angle in data coordinates\n=======================================\n\nText objects in matplotlib are normally rotated with respect to the\nscreen coordinate system (i.e., 45 degrees rotation plots text along a\nline that is in between horizontal and vertical no matter how the axes\nare changed).  However, at times one wants to rotate text with respect\nto something on the plot.  In this case, the correct angle won't be\nthe angle of that object in the plot coordinate system, but the angle\nthat that object APPEARS in the screen coordinate system.  This angle\ncan be determined automatically by setting the parameter\n*transform_rotates_text*, as shown in the example below.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\n# Plot diagonal line (45 degrees in data coordinates)\nax.plot(range(0, 8), range(0, 8))\nax.set_xlim([-10, 10])\n\n# Plot text\nax.text(-8, 0, 'text 45\u00b0 in screen coordinates', fontsize=18,\n        rotation=45, rotation_mode='anchor')\nax.text(0, 0, 'text 45\u00b0 in data coordinates', fontsize=18,\n        rotation=45, rotation_mode='anchor',\n        transform_rotates_text=True)\n\nplt.show()\n"
    },
    {
      "filename": "titles_demo.py",
      "title": "Titles Demo",
      "code": "\"\"\"\n=================\nTitle positioning\n=================\n\nMatplotlib can display plot titles centered, flush with the left side of\na set of Axes, and flush with the right side of a set of Axes.\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nplt.plot(range(10))\n\nplt.title('Center Title')\nplt.title('Left Title', loc='left')\nplt.title('Right Title', loc='right')\n\nplt.show()\n\n# %%\n# The vertical position is automatically chosen to avoid decorations\n# (i.e. labels and ticks) on the topmost x-axis:\n\nfig, axs = plt.subplots(1, 2, layout='constrained')\n\nax = axs[0]\nax.plot(range(10))\nax.xaxis.set_label_position('top')\nax.set_xlabel('X-label')\nax.set_title('Center Title')\n\nax = axs[1]\nax.plot(range(10))\nax.xaxis.set_label_position('top')\nax.xaxis.tick_top()\nax.set_xlabel('X-label')\nax.set_title('Center Title')\nplt.show()\n\n# %%\n# Automatic positioning can be turned off by manually specifying the *y*\n# keyword argument for the title or setting :rc:`axes.titley` in the rcParams.\n\nfig, axs = plt.subplots(1, 2, layout='constrained')\n\nax = axs[0]\nax.plot(range(10))\nax.xaxis.set_label_position('top')\nax.set_xlabel('X-label')\nax.set_title('Manual y', y=1.0, pad=-14)\n\nplt.rcParams['axes.titley'] = 1.0    # y is in axes-relative coordinates.\nplt.rcParams['axes.titlepad'] = -14  # pad is in points...\nax = axs[1]\nax.plot(range(10))\nax.set_xlabel('X-label')\nax.set_title('rcParam y')\n\nplt.show()\n"
    },
    {
      "filename": "unicode_minus.py",
      "title": "Unicode Minus",
      "code": "\"\"\"\n=============\nUnicode minus\n=============\n\nBy default, tick labels at negative values are rendered using a `Unicode\nminus`__ (U+2212) rather than an ASCII hyphen (U+002D).  This can be controlled\nby setting :rc:`axes.unicode_minus`.\n\n__ https://en.wikipedia.org/wiki/Plus_and_minus_signs#Character_codes\n\nThe replacement is performed at draw time of the tick labels (usually during a\n`.pyplot.show()` or `.pyplot.savefig()` call). Therefore, all tick labels of\nthe figure follow the same setting and we cannot demonstrate both glyphs on\nreal tick labels of the same figure simultaneously.\n\nInstead, this example simply showcases the difference between the two glyphs\nin a magnified font.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(4, 2))\nfig.text(.15, .6, \"Unicode minus:\", fontsize=20)\nfig.text(.85, .6, \"\\N{MINUS SIGN}1\", ha='right', fontsize=20)\nfig.text(.15, .3, \"ASCII hyphen:\", fontsize=20)\nfig.text(.85, .3, \"-1\", ha='right', fontsize=20)\nplt.show()\n"
    },
    {
      "filename": "usetex_baseline_test.py",
      "title": "Usetex Baseline Test",
      "code": "\"\"\"\n====================\nUsetex text baseline\n====================\n\nComparison of text baselines computed for mathtext and usetex.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nplt.rcParams.update({\"mathtext.fontset\": \"cm\", \"mathtext.rm\": \"serif\"})\naxs = plt.figure(figsize=(2 * 3, 6.5)).subplots(1, 2)\nfor ax, usetex in zip(axs, [False, True]):\n    ax.axvline(0, color=\"r\")\n    test_strings = [\"lg\", r\"$\\frac{1}{2}\\pi$\", r\"$p^{3^A}$\", r\"$p_{3_2}$\"]\n    for i, s in enumerate(test_strings):\n        ax.axhline(i, color=\"r\")\n        ax.text(0., 3 - i, s,\n                usetex=usetex,\n                verticalalignment=\"baseline\",\n                size=50,\n                bbox=dict(pad=0, ec=\"k\", fc=\"none\"))\n    ax.set(xlim=(-0.1, 1.1), ylim=(-.8, 3.9), xticks=[], yticks=[],\n           title=f\"usetex={usetex}\\n\")\nplt.show()\n"
    },
    {
      "filename": "usetex_fonteffects.py",
      "title": "Usetex Fonteffects",
      "code": "\"\"\"\n===================\nUsetex font effects\n===================\n\nThis script demonstrates that font effects specified in your pdftex.map\nare now supported in usetex mode.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef setfont(font):\n    return rf'\\font\\a {font} at 14pt\\a '\n\n\nfig = plt.figure()\nfor y, font, text in zip(\n    range(5),\n    ['ptmr8r', 'ptmri8r', 'ptmro8r', 'ptmr8rn', 'ptmrr8re'],\n    [f'Nimbus Roman No9 L {x}'\n     for x in ['', 'Italics (real italics for comparison)',\n               '(slanted)', '(condensed)', '(extended)']],\n):\n    fig.text(.1, 1 - (y + 1) / 6, setfont(font) + text, usetex=True)\n\nfig.suptitle('Usetex font effects')\n# Would also work if saving to pdf.\nplt.show()\n"
    },
    {
      "filename": "watermark_text.py",
      "title": "Watermark Text",
      "code": "\"\"\"\n==============\nText watermark\n==============\n\nA watermark effect can be achieved by drawing a semi-transparent text.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nax.plot(np.random.rand(20), '-o', ms=20, lw=2, alpha=0.7, mfc='orange')\nax.grid()\n\nax.text(0.5, 0.5, 'created with matplotlib', transform=ax.transAxes,\n        fontsize=40, color='gray', alpha=0.5,\n        ha='center', va='center', rotation=30)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.figure.Figure.text`\n"
    }
  ],
  "ticks": [
    {
      "filename": "auto_ticks.py",
      "title": "Auto Ticks",
      "code": "\"\"\"\n====================================\nAutomatically setting tick positions\n====================================\n\nSetting the behavior of tick auto-placement.\n\nBy default, Matplotlib will choose the number of ticks and tick positions so\nthat there is a reasonable number of ticks on the axis and they are located\nat \"round\" numbers.\n\nAs a result, there may be no ticks on the edges of the plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\ndots = np.linspace(0.3, 1.2, 10)\nX, Y = np.meshgrid(dots, dots)\nx, y = X.ravel(), Y.ravel()\nax.scatter(x, y, c=x+y)\nplt.show()\n\n# %%\n# If you want to keep ticks at round numbers, and also have ticks at the edges\n# you can switch :rc:`axes.autolimit_mode` to 'round_numbers'. This expands the\n# axis limits to the next round number.\n\nplt.rcParams['axes.autolimit_mode'] = 'round_numbers'\n\n# Note: The limits are calculated at draw-time. Therefore, when using\n# :rc:`axes.autolimit_mode` in a context manager, it is important that\n# the ``show()`` command is within the context.\n\nfig, ax = plt.subplots()\nax.scatter(x, y, c=x+y)\nplt.show()\n\n# %%\n# The round numbers autolimit_mode is still respected if you set an additional\n# margin around the data using `.Axes.set_xmargin` / `.Axes.set_ymargin`:\n\nfig, ax = plt.subplots()\nax.scatter(x, y, c=x+y)\nax.set_xmargin(0.8)\nplt.show()\n"
    },
    {
      "filename": "centered_ticklabels.py",
      "title": "Centered Ticklabels",
      "code": "\"\"\"\n===========================\nCenter labels between ticks\n===========================\n\nTicklabels are aligned relative to their associated tick. The alignment\n'center', 'left', or 'right' can be controlled using the horizontal alignment\nproperty::\n\n    for label in ax.get_xticklabels():\n        label.set_horizontalalignment('right')\n\nHowever, there is no direct way to center the labels between ticks. To fake\nthis behavior, one can place a label on the minor ticks in between the major\nticks, and hide the major tick labels and minor ticks.\n\nHere is an example that labels the months, centered between the ticks.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.dates as dates\nimport matplotlib.ticker as ticker\n\n# Load some financial data; Google's stock price\nr = cbook.get_sample_data('goog.npz')['price_data']\nr = r[-250:]  # get the last 250 days\n\nfig, ax = plt.subplots()\nax.plot(r[\"date\"], r[\"adj_close\"])\n\nax.xaxis.set_major_locator(dates.MonthLocator())\n# 16 is a slight approximation since months differ in number of days.\nax.xaxis.set_minor_locator(dates.MonthLocator(bymonthday=16))\n\nax.xaxis.set_major_formatter(ticker.NullFormatter())\nax.xaxis.set_minor_formatter(dates.DateFormatter('%b'))\n\n# Remove the tick lines\nax.tick_params(axis='x', which='minor', tick1On=False, tick2On=False)\n\n# Align the minor tick label\nfor label in ax.get_xticklabels(minor=True):\n    label.set_horizontalalignment('center')\nimid = len(r) // 2\nax.set_xlabel(str(r[\"date\"][imid].item().year))\nplt.show()\n"
    },
    {
      "filename": "colorbar_tick_labelling_demo.py",
      "title": "Colorbar Tick Labelling Demo",
      "code": "\"\"\"\n=======================\nColorbar Tick Labelling\n=======================\n\nVertical colorbars have ticks, tick labels, and labels visible on the *y* axis,\nhorizontal colorbars on the *x* axis. The ``ticks`` parameter can be used to\nset the ticks and the ``format`` parameter can be used to format the tick labels\nof the visible colorbar Axes. For further adjustments, the ``yaxis`` or\n``xaxis`` Axes of the colorbar can be retrieved using its ``ax`` property.\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as mticker\n\n# Fixing random state for reproducibility\nrng = np.random.default_rng(seed=19680801)\n\n# %%\n# Make plot with vertical (default) colorbar\n\nfig, ax = plt.subplots()\n\ndata = rng.standard_normal((250, 250))\n\ncax = ax.imshow(data, vmin=-1, vmax=1, cmap='coolwarm')\nax.set_title('Gaussian noise with vertical colorbar')\n\n# Add colorbar, make sure to specify tick locations to match desired ticklabels\ncbar = fig.colorbar(cax,\n                    ticks=[-1, 0, 1],\n                    format=mticker.FixedFormatter(['< -1', '0', '> 1']),\n                    extend='both'\n                    )\nlabels = cbar.ax.get_yticklabels()\nlabels[0].set_verticalalignment('top')\nlabels[-1].set_verticalalignment('bottom')\n\n# %%\n# Make plot with horizontal colorbar\n\nfig, ax = plt.subplots()\n\ndata = np.clip(data, -1, 1)\n\ncax = ax.imshow(data, cmap='afmhot')\nax.set_title('Gaussian noise with horizontal colorbar')\n\n# Add colorbar and adjust ticks afterwards\ncbar = fig.colorbar(cax, orientation='horizontal')\ncbar.set_ticks(ticks=[-1, 0, 1], labels=['Low', 'Medium', 'High'])\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.colorbar.Colorbar.set_ticks`\n#    - `matplotlib.figure.Figure.colorbar` / `matplotlib.pyplot.colorbar`\n"
    },
    {
      "filename": "custom_ticker1.py",
      "title": "Custom Ticker1",
      "code": "\"\"\"\n=============\nCustom Ticker\n=============\n\nThe :mod:`matplotlib.ticker` module defines many preset tickers, but was\nprimarily designed for extensibility, i.e., to support user customized ticking.\n\nIn this example, a user defined function is used to format the ticks in\nmillions of dollars on the y-axis.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n\ndef millions(x, pos):\n    \"\"\"The two arguments are the value and tick position.\"\"\"\n    return f'${x*1e-6:1.1f}M'\n\n\nfig, ax = plt.subplots()\n# set_major_formatter internally creates a FuncFormatter from the callable.\nax.yaxis.set_major_formatter(millions)\nmoney = [1.5e5, 2.5e6, 5.5e6, 2.0e7]\nax.bar(['Bill', 'Fred', 'Mary', 'Sue'], money)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axis.Axis.set_major_formatter`\n"
    },
    {
      "filename": "date_concise_formatter.py",
      "title": "Date Concise Formatter",
      "code": "\"\"\"\n.. _date_concise_formatter:\n\n============================================\nFormat date ticks using ConciseDateFormatter\n============================================\n\nFinding good tick values and formatting the ticks for an axis that\nhas date data is often a challenge.  `~.dates.ConciseDateFormatter` is\nmeant to improve the strings chosen for the ticklabels, and to minimize\nthe strings used in those tick labels as much as possible.\n\n.. note::\n\n    This formatter is a candidate to become the default date tick formatter\n    in future versions of Matplotlib.  Please report any issues or\n    suggestions for improvement to the GitHub repository or mailing list.\n\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\n# %%\n# First, the default formatter.\n\nbase = datetime.datetime(2005, 2, 1)\ndates = [base + datetime.timedelta(hours=(2 * i)) for i in range(732)]\nN = len(dates)\nnp.random.seed(19680801)\ny = np.cumsum(np.random.randn(N))\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\nlims = [(np.datetime64('2005-02'), np.datetime64('2005-04')),\n        (np.datetime64('2005-02-03'), np.datetime64('2005-02-15')),\n        (np.datetime64('2005-02-03 11:00'), np.datetime64('2005-02-04 13:20'))]\nfor nn, ax in enumerate(axs):\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\n    # rotate_labels...\n    for label in ax.get_xticklabels():\n        label.set_rotation(40)\n        label.set_horizontalalignment('right')\naxs[0].set_title('Default Date Formatter')\nplt.show()\n\n# %%\n# The default date formatter is quite verbose, so we have the option of\n# using `~.dates.ConciseDateFormatter`, as shown below.  Note that\n# for this example the labels do not need to be rotated as they do for the\n# default formatter because the labels are as small as possible.\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\nfor nn, ax in enumerate(axs):\n    locator = mdates.AutoDateLocator(minticks=3, maxticks=7)\n    formatter = mdates.ConciseDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter')\n\nplt.show()\n\n# %%\n# If all calls to axes that have dates are to be made using this converter,\n# it is probably most convenient to use the units registry where you do\n# imports:\n\nimport matplotlib.units as munits\n\nconverter = mdates.ConciseDateConverter()\nmunits.registry[np.datetime64] = converter\nmunits.registry[datetime.date] = converter\nmunits.registry[datetime.datetime] = converter\n\nfig, axs = plt.subplots(3, 1, figsize=(6, 6), layout='constrained')\nfor nn, ax in enumerate(axs):\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter')\n\nplt.show()\n\n# %%\n# Localization of date formats\n# ============================\n#\n# Dates formats can be localized if the default formats are not desirable by\n# manipulating one of three lists of strings.\n#\n# The ``formatter.formats`` list of formats is for the normal tick labels,\n# There are six levels: years, months, days, hours, minutes, seconds.\n# The ``formatter.offset_formats`` is how the \"offset\" string on the right\n# of the axis is formatted.  This is usually much more verbose than the tick\n# labels. Finally, the ``formatter.zero_formats`` are the formats of the\n# ticks that are \"zeros\".  These are tick values that are either the first of\n# the year, month, or day of month, or the zeroth hour, minute, or second.\n# These are usually the same as the format of\n# the ticks a level above.  For example if the axis limits mean the ticks are\n# mostly days, then we label 1 Mar 2005 simply with a \"Mar\".  If the axis\n# limits are mostly hours, we label Feb 4 00:00 as simply \"Feb-4\".\n#\n# Note that these format lists can also be passed to `.ConciseDateFormatter`\n# as optional keyword arguments.\n#\n# Here we modify the labels to be \"day month year\", instead of the ISO\n# \"year month day\":\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\n\nfor nn, ax in enumerate(axs):\n    locator = mdates.AutoDateLocator()\n    formatter = mdates.ConciseDateFormatter(locator)\n    formatter.formats = ['%y',  # ticks are mostly years\n                         '%b',       # ticks are mostly months\n                         '%d',       # ticks are mostly days\n                         '%H:%M',    # hrs\n                         '%H:%M',    # min\n                         '%S.%f', ]  # secs\n    # these are mostly just the level above...\n    formatter.zero_formats = [''] + formatter.formats[:-1]\n    # ...except for ticks that are mostly hours, then it is nice to have\n    # month-day:\n    formatter.zero_formats[3] = '%d-%b'\n\n    formatter.offset_formats = ['',\n                                '%Y',\n                                '%b %Y',\n                                '%d %b %Y',\n                                '%d %b %Y',\n                                '%d %b %Y %H:%M', ]\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter')\n\nplt.show()\n\n# %%\n# Registering a converter with localization\n# =========================================\n#\n# `.ConciseDateFormatter` doesn't have rcParams entries, but localization can\n# be accomplished by passing keyword arguments to `.ConciseDateConverter` and\n# registering the datatypes you will use with the units registry:\n\nimport datetime\n\nformats = ['%y',          # ticks are mostly years\n           '%b',     # ticks are mostly months\n           '%d',     # ticks are mostly days\n           '%H:%M',  # hrs\n           '%H:%M',  # min\n           '%S.%f', ]  # secs\n# these can be the same, except offset by one level....\nzero_formats = [''] + formats[:-1]\n# ...except for ticks that are mostly hours, then it's nice to have month-day\nzero_formats[3] = '%d-%b'\noffset_formats = ['',\n                  '%Y',\n                  '%b %Y',\n                  '%d %b %Y',\n                  '%d %b %Y',\n                  '%d %b %Y %H:%M', ]\n\nconverter = mdates.ConciseDateConverter(\n    formats=formats, zero_formats=zero_formats, offset_formats=offset_formats)\n\nmunits.registry[np.datetime64] = converter\nmunits.registry[datetime.date] = converter\nmunits.registry[datetime.datetime] = converter\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\nfor nn, ax in enumerate(axs):\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter registered non-default')\n\nplt.show()\n"
    },
    {
      "filename": "date_demo_convert.py",
      "title": "Date Demo Convert",
      "code": "\"\"\"\n=================\nDate Demo Convert\n=================\n\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import DateFormatter, DayLocator, HourLocator, drange\n\ndate1 = datetime.datetime(2000, 3, 2)\ndate2 = datetime.datetime(2000, 3, 6)\ndelta = datetime.timedelta(hours=6)\ndates = drange(date1, date2, delta)\n\ny = np.arange(len(dates))\n\nfig, ax = plt.subplots()\nax.plot(dates, y**2, 'o')\n\n# this is superfluous, since the autoscaler should get it right, but\n# use date2num and num2date to convert between dates and floats if\n# you want; both date2num and num2date convert an instance or sequence\nax.set_xlim(dates[0], dates[-1])\n\n# The hour locator takes the hour or sequence of hours you want to\n# tick, not the base multiple\n\nax.xaxis.set_major_locator(DayLocator())\nax.xaxis.set_minor_locator(HourLocator(range(0, 25, 6)))\nax.xaxis.set_major_formatter(DateFormatter('%Y-%m-%d'))\n\nax.fmt_xdata = DateFormatter('%Y-%m-%d %H:%M:%S')\nfig.autofmt_xdate()\n\nplt.show()\n"
    },
    {
      "filename": "date_demo_rrule.py",
      "title": "Date Demo Rrule",
      "code": "\"\"\"\n=========================================\nPlacing date ticks using recurrence rules\n=========================================\n\nThe `iCalender RFC`_ specifies *recurrence rules* (rrules), that define\ndate sequences. You can use rrules in Matplotlib to place date ticks.\n\nThis example sets custom date ticks on every 5th easter.\n\nSee https://dateutil.readthedocs.io/en/stable/rrule.html for help with rrules.\n\n.. _iCalender RFC: https://tools.ietf.org/html/rfc5545\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import (YEARLY, DateFormatter, RRuleLocator, drange,\n                              rrulewrapper)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# tick every 5th easter\nrule = rrulewrapper(YEARLY, byeaster=1, interval=5)\nloc = RRuleLocator(rule)\nformatter = DateFormatter('%m/%d/%y')\ndate1 = datetime.date(1952, 1, 1)\ndate2 = datetime.date(2004, 4, 12)\ndelta = datetime.timedelta(days=100)\n\ndates = drange(date1, date2, delta)\ns = np.random.rand(len(dates))  # make up some random y values\n\n\nfig, ax = plt.subplots()\nplt.plot(dates, s, 'o')\nax.xaxis.set_major_locator(loc)\nax.xaxis.set_major_formatter(formatter)\nax.xaxis.set_tick_params(rotation=30, labelsize=10)\n\nplt.show()\n"
    },
    {
      "filename": "date_formatters_locators.py",
      "title": "Date Formatters Locators",
      "code": "\"\"\"\n.. _date_formatters_locators:\n\n=================================\nDate tick locators and formatters\n=================================\n\nThis example illustrates the usage and effect of the various date locators and\nformatters.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import (FR, MO, MONTHLY, SA, SU, TH, TU, WE,\n                              AutoDateFormatter, AutoDateLocator,\n                              ConciseDateFormatter, DateFormatter, DayLocator,\n                              HourLocator, MicrosecondLocator, MinuteLocator,\n                              MonthLocator, RRuleLocator, SecondLocator,\n                              WeekdayLocator, YearLocator, rrulewrapper)\nimport matplotlib.ticker as ticker\n\n\ndef plot_axis(ax, locator=None, xmax='2002-02-01', fmt=None, formatter=None):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5)\n    ax.set_xlim(np.datetime64('2000-02-01'), np.datetime64(xmax))\n    if locator:\n        ax.xaxis.set_major_locator(eval(locator))\n        ax.xaxis.set_major_formatter(DateFormatter(fmt))\n    else:\n        ax.xaxis.set_major_formatter(eval(formatter))\n    ax.text(0.0, 0.2, locator or formatter, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n# %%\n# :ref:`date-locators`\n# --------------------\n\n\nlocators = [\n    # locator as str, xmax, fmt\n    ('AutoDateLocator(maxticks=8)', '2003-02-01', '%Y-%m'),\n    ('YearLocator(month=4)', '2003-02-01', '%Y-%m'),\n    ('MonthLocator(bymonth=[4, 8, 12])', '2003-02-01', '%Y-%m'),\n    ('DayLocator(interval=180)', '2003-02-01', '%Y-%m-%d'),\n    ('WeekdayLocator(byweekday=SU, interval=4)', '2000-07-01', '%a %Y-%m-%d'),\n    ('HourLocator(byhour=range(0, 24, 6))', '2000-02-04', '%H h'),\n    ('MinuteLocator(interval=15)', '2000-02-01 02:00', '%H:%M'),\n    ('SecondLocator(bysecond=(0, 30))', '2000-02-01 00:02', '%H:%M:%S'),\n    ('MicrosecondLocator(interval=1000)', '2000-02-01 00:00:00.005', '%S.%f'),\n    ('RRuleLocator(rrulewrapper(freq=MONTHLY, \\nbyweekday=(MO, TU, WE, TH, FR), '\n     'bysetpos=-1))', '2000-07-01', '%Y-%m-%d'),\n]\n\nfig, axs = plt.subplots(len(locators), 1, figsize=(8, len(locators) * .8),\n                        layout='constrained')\nfig.suptitle('Date Locators')\nfor ax, (locator, xmax, fmt) in zip(axs, locators):\n    plot_axis(ax, locator, xmax, fmt)\n\n# %%\n# :ref:`date-formatters`\n# ----------------------\n\nformatters = [\n    'AutoDateFormatter(ax.xaxis.get_major_locator())',\n    'ConciseDateFormatter(ax.xaxis.get_major_locator())',\n    'DateFormatter(\"%b %Y\")',\n]\n\nfig, axs = plt.subplots(len(formatters), 1, figsize=(8, len(formatters) * .8),\n                        layout='constrained')\nfig.suptitle('Date Formatters')\nfor ax, fmt in zip(axs, formatters):\n    plot_axis(ax, formatter=fmt)\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.dates.AutoDateLocator`\n#    - `matplotlib.dates.YearLocator`\n#    - `matplotlib.dates.MonthLocator`\n#    - `matplotlib.dates.DayLocator`\n#    - `matplotlib.dates.WeekdayLocator`\n#    - `matplotlib.dates.HourLocator`\n#    - `matplotlib.dates.MinuteLocator`\n#    - `matplotlib.dates.SecondLocator`\n#    - `matplotlib.dates.MicrosecondLocator`\n#    - `matplotlib.dates.RRuleLocator`\n#    - `matplotlib.dates.rrulewrapper`\n#    - `matplotlib.dates.DateFormatter`\n#    - `matplotlib.dates.AutoDateFormatter`\n#    - `matplotlib.dates.ConciseDateFormatter`\n"
    },
    {
      "filename": "date_index_formatter.py",
      "title": "Date Index Formatter",
      "code": "\"\"\"\n=====================================\nCustom tick formatter for time series\n=====================================\n\n.. redirect-from:: /gallery/text_labels_and_annotations/date_index_formatter\n.. redirect-from:: /gallery/ticks/date_index_formatter2\n\nWhen plotting daily data, e.g., financial time series, one often wants\nto leave out days on which there is no data, for instance weekends, so that\nthe data are plotted at regular intervals without extra spaces for the days\nwith no data.\nThe example shows how to use an 'index formatter' to achieve the desired plot.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\nfrom matplotlib.dates import DateFormatter, DayLocator\nimport matplotlib.lines as ml\nfrom matplotlib.ticker import Formatter\n\n# Load a structured numpy array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit ('D') in\n# the date column (``r['date']``).\nr = cbook.get_sample_data('goog.npz')['price_data']\nr = r[:9]  # get the first 9 days\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(6, 6), layout='constrained')\nfig.get_layout_engine().set(hspace=0.15)\n\n# First we'll do it the default way, with gaps on weekends\nax1.plot(r[\"date\"], r[\"adj_close\"], 'o-')\n\n# Highlight gaps in daily data\ngaps = np.flatnonzero(np.diff(r[\"date\"]) > np.timedelta64(1, 'D'))\nfor gap in r[['date', 'adj_close']][np.stack((gaps, gaps + 1)).T]:\n    ax1.plot(gap['date'], gap['adj_close'], 'w--', lw=2)\nax1.legend(handles=[ml.Line2D([], [], ls='--', label='Gaps in daily data')])\n\nax1.set_title(\"Plot y at x Coordinates\")\nax1.xaxis.set_major_locator(DayLocator())\nax1.xaxis.set_major_formatter(DateFormatter('%a'))\n\n\n# Next we'll write a custom index formatter. Below we will plot\n# the data against an index that goes from 0, 1,  ... len(data).  Instead of\n# formatting the tick marks as integers, we format as times.\ndef format_date(x, _):\n    try:\n        # convert datetime64 to datetime, and use datetime's strftime:\n        return r[\"date\"][round(x)].item().strftime('%a')\n    except IndexError:\n        pass\n\n# Create an index plot (x defaults to range(len(y)) if omitted)\nax2.plot(r[\"adj_close\"], 'o-')\n\nax2.set_title(\"Plot y at Index Coordinates Using Custom Formatter\")\nax2.xaxis.set_major_formatter(format_date)  # internally creates FuncFormatter\n\n# %%\n# Instead of passing a function into `.Axis.set_major_formatter` you can use\n# any other callable, e.g. an instance of a class that implements __call__:\n\n\nclass MyFormatter(Formatter):\n    def __init__(self, dates, fmt='%a'):\n        self.dates = dates\n        self.fmt = fmt\n\n    def __call__(self, x, pos=0):\n        \"\"\"Return the label for time x at position pos.\"\"\"\n        try:\n            return self.dates[round(x)].item().strftime(self.fmt)\n        except IndexError:\n            pass\n\n\nax2.xaxis.set_major_formatter(MyFormatter(r[\"date\"], '%a'))\n\nplt.show()\n"
    },
    {
      "filename": "date_precision_and_epochs.py",
      "title": "Date Precision And Epochs",
      "code": "\"\"\"\n=========================\nDate precision and epochs\n=========================\n\nMatplotlib can handle `.datetime` objects and `numpy.datetime64` objects using\na unit converter that recognizes these dates and converts them to floating\npoint numbers.\n\nBefore Matplotlib 3.3, the default for this conversion returns a float that was\ndays since \"0000-12-31T00:00:00\".  As of Matplotlib 3.3, the default is\ndays from \"1970-01-01T00:00:00\".  This allows more resolution for modern\ndates.  \"2020-01-01\" with the old epoch converted to 730120, and a 64-bit\nfloating point number has a resolution of 2^{-52}, or approximately\n14 microseconds, so microsecond precision was lost.  With the new default\nepoch \"2020-01-01\" is 10957.0, so the achievable resolution is 0.21\nmicroseconds.\n\n\"\"\"\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\n\ndef _reset_epoch_for_tutorial():\n    \"\"\"\n    Users (and downstream libraries) should not use the private method of\n    resetting the epoch.\n    \"\"\"\n    mdates._reset_epoch_test_example()\n\n\n# %%\n# Datetime\n# --------\n#\n# Python `.datetime` objects have microsecond resolution, so with the\n# old default matplotlib dates could not round-trip full-resolution datetime\n# objects.\n\nold_epoch = '0000-12-31T00:00:00'\nnew_epoch = '1970-01-01T00:00:00'\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(old_epoch)  # old epoch (pre MPL 3.3)\n\ndate1 = datetime.datetime(2000, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# Note this is only a round-off error, and there is no problem for\n# dates closer to the old epoch:\n\ndate1 = datetime.datetime(10, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# If a user wants to use modern dates at microsecond precision, they\n# can change the epoch using `.set_epoch`.  However, the epoch has to be\n# set before any date operations to prevent confusion between different\n# epochs. Trying to change the epoch later will raise a `RuntimeError`.\n\ntry:\n    mdates.set_epoch(new_epoch)  # this is the new MPL 3.3 default.\nexcept RuntimeError as e:\n    print('RuntimeError:', str(e))\n\n# %%\n# For this tutorial, we reset the sentinel using a private method, but users\n# should just set the epoch once, if at all.\n\n_reset_epoch_for_tutorial()  # Just being done for this tutorial.\nmdates.set_epoch(new_epoch)\n\ndate1 = datetime.datetime(2020, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# datetime64\n# ----------\n#\n# `numpy.datetime64` objects have microsecond precision for a much larger\n# timespace than `.datetime` objects.  However, currently Matplotlib time is\n# only converted back to datetime objects, which have microsecond resolution,\n# and years that only span 0000 to 9999.\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(new_epoch)\n\ndate1 = np.datetime64('2000-01-01T00:10:00.000012')\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\n# %%\n# Plotting\n# --------\n#\n# This all of course has an effect on plotting.  With the old default epoch\n# the times were rounded during the internal ``date2num`` conversion, leading\n# to jumps in the data:\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(old_epoch)\n\nx = np.arange('2000-01-01T00:00:00.0', '2000-01-01T00:00:00.000100',\n              dtype='datetime64[us]')\n# simulate the plot being made using the old epoch\nxold = np.array([mdates.num2date(mdates.date2num(d)) for d in x])\ny = np.arange(0, len(x))\n\n# resetting the Epoch so plots are comparable\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(new_epoch)\n\nfig, ax = plt.subplots(layout='constrained')\nax.plot(xold, y)\nax.set_title('Epoch: ' + mdates.get_epoch())\nax.xaxis.set_tick_params(rotation=40)\nplt.show()\n\n# %%\n# For dates plotted using the more recent epoch, the plot is smooth:\n\nfig, ax = plt.subplots(layout='constrained')\nax.plot(x, y)\nax.set_title('Epoch: ' + mdates.get_epoch())\nax.xaxis.set_tick_params(rotation=40)\nplt.show()\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.dates.num2date`\n#    - `matplotlib.dates.date2num`\n#    - `matplotlib.dates.set_epoch`\n"
    },
    {
      "filename": "dollar_ticks.py",
      "title": "Dollar Ticks",
      "code": "\"\"\"\n============\nDollar ticks\n============\n\nUse a format string to prepend dollar signs on y-axis labels.\n\n.. redirect-from:: /gallery/pyplots/dollar_ticks\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nax.plot(100*np.random.rand(20))\n\n# Use automatic StrMethodFormatter\nax.yaxis.set_major_formatter('${x:1.2f}')\n\nax.yaxis.set_tick_params(which='major', labelcolor='green',\n                         labelleft=False, labelright=True)\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.axis.Axis.set_tick_params`\n#    - `matplotlib.axis.Tick`\n#    - `matplotlib.ticker.StrMethodFormatter`\n"
    },
    {
      "filename": "engformatter_offset.py",
      "title": "Engformatter Offset",
      "code": "\"\"\"\n===================================================\nSI prefixed offsets and natural order of magnitudes\n===================================================\n\n`matplotlib.ticker.EngFormatter` is capable of computing a natural\noffset for your axis data, and presenting it with a standard SI prefix\nautomatically calculated.\n\nBelow is an examples of such a plot:\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as mticker\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nUNIT = \"Hz\"\n\nfig, ax = plt.subplots()\nax.yaxis.set_major_formatter(mticker.EngFormatter(\n    useOffset=True,\n    unit=UNIT\n))\nsize = 100\nmeasurement = np.full(size, 1e9)\nnoise = np.random.uniform(low=-2e3, high=2e3, size=size)\nax.plot(measurement + noise)\nplt.show()\n"
    },
    {
      "filename": "fig_axes_customize_simple.py",
      "title": "Fig Axes Customize Simple",
      "code": "\"\"\"\n=========================\nFig Axes Customize Simple\n=========================\n\nCustomize the background, labels and ticks of a simple plot.\n\n.. redirect-from:: /gallery/pyplots/fig_axes_customize_simple\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\n# %%\n# `.pyplot.figure` creates a `matplotlib.figure.Figure` instance.\n\nfig = plt.figure()\nrect = fig.patch  # a rectangle instance\nrect.set_facecolor('lightgoldenrodyellow')\n\nax1 = fig.add_axes([0.1, 0.3, 0.4, 0.4])\nrect = ax1.patch\nrect.set_facecolor('lightslategray')\n\nax1.tick_params(axis='x', labelcolor='tab:red', labelrotation=45, labelsize=16)\nax1.tick_params(axis='y', color='tab:green', size=25, width=3)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axis.Axis.get_ticklabels`\n#    - `matplotlib.axis.Axis.get_ticklines`\n#    - `matplotlib.text.Text.set_rotation`\n#    - `matplotlib.text.Text.set_fontsize`\n#    - `matplotlib.text.Text.set_color`\n#    - `matplotlib.lines.Line2D`\n#    - `matplotlib.lines.Line2D.set_markeredgecolor`\n#    - `matplotlib.lines.Line2D.set_markersize`\n#    - `matplotlib.lines.Line2D.set_markeredgewidth`\n#    - `matplotlib.patches.Patch.set_facecolor`\n"
    },
    {
      "filename": "major_minor_demo.py",
      "title": "Major Minor Demo",
      "code": "r\"\"\"\n=====================\nMajor and minor ticks\n=====================\n\nDemonstrate how to use major and minor tickers.\n\nThe two relevant classes are `.Locator`\\s and `.Formatter`\\s.  Locators\ndetermine where the ticks are, and formatters control the formatting of tick\nlabels.\n\nMinor ticks are off by default (using `.NullLocator` and `.NullFormatter`).\nMinor ticks can be turned on without labels by setting the minor locator.\nMinor tick labels can be turned on by setting the minor formatter.\n\n`.MultipleLocator` places ticks on multiples of some base.\n`.StrMethodFormatter` uses a format string (e.g., ``'{x:d}'`` or ``'{x:1.2f}'``\nor ``'{x:1.1f} cm'``) to format the tick labels (the variable in the format\nstring must be ``'x'``).  For a `.StrMethodFormatter`, the string can be passed\ndirectly to `.Axis.set_major_formatter` or\n`.Axis.set_minor_formatter`.  An appropriate `.StrMethodFormatter` will\nbe created and used automatically.\n\n`.pyplot.grid` changes the grid settings of the major ticks of the x- and\ny-axis together.  If you want to control the grid of the minor ticks for a\ngiven axis, use for example ::\n\n  ax.xaxis.grid(True, which='minor')\n\nNote that a given locator or formatter instance can only be used on a single\naxis (because the locator stores references to the axis data and view limits).\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import AutoMinorLocator, MultipleLocator\n\nt = np.arange(0.0, 100.0, 0.1)\ns = np.sin(0.1 * np.pi * t) * np.exp(-t * 0.01)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\n# Make a plot with major ticks that are multiples of 20 and minor ticks that\n# are multiples of 5.  Label major ticks with '.0f' formatting but don't label\n# minor ticks.  The string is used directly, the `StrMethodFormatter` is\n# created automatically.\nax.xaxis.set_major_locator(MultipleLocator(20))\nax.xaxis.set_major_formatter('{x:.0f}')\n\n# For the minor ticks, use no labels; default NullFormatter.\nax.xaxis.set_minor_locator(MultipleLocator(5))\n\nplt.show()\n\n# %%\n# Automatic tick selection for major and minor ticks.\n#\n# Use interactive pan and zoom to see how the tick intervals change. There will\n# be either 4 or 5 minor tick intervals per major interval, depending on the\n# major interval.\n#\n# One can supply an argument to `.AutoMinorLocator` to specify a fixed number\n# of minor intervals per major interval, e.g. ``AutoMinorLocator(2)`` would\n# lead to a single minor tick between major ticks.\n\nt = np.arange(0.0, 100.0, 0.01)\ns = np.sin(2 * np.pi * t) * np.exp(-t * 0.01)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.xaxis.set_minor_locator(AutoMinorLocator())\n\nax.tick_params(which='both', width=2)\nax.tick_params(which='major', length=7)\nax.tick_params(which='minor', length=4, color='r')\n\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.axis.Axis.set_minor_locator`\n#    - `matplotlib.ticker.AutoMinorLocator`\n#    - `matplotlib.ticker.MultipleLocator`\n#    - `matplotlib.ticker.StrMethodFormatter`\n"
    },
    {
      "filename": "multilevel_ticks.py",
      "title": "Multilevel Ticks",
      "code": "\"\"\"\n=========================\nMultilevel (nested) ticks\n=========================\n\nSometimes we want another level of tick labels on an axis, perhaps to indicate\na grouping of the ticks.\n\nMatplotlib does not provide an automated way to do this, but it is relatively\nstraightforward to annotate below the main axis.\n\nThese examples use `.Axes.secondary_xaxis`, which is one approach. It has the\nadvantage that we can use Matplotlib Locators and Formatters on the axis that\ndoes the grouping if we want.\n\nThis first example creates a secondary xaxis and manually adds the ticks and\nlabels using `.Axes.set_xticks`.  Note that the tick labels have a newline\n(e.g. ``\"\\nOughts\"``) at the beginning of them to put the second-level tick\nlabels below the main tick labels.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\nrng = np.random.default_rng(19680801)\n\nfig, ax = plt.subplots(layout='constrained', figsize=(4, 4))\n\nax.plot(np.arange(30))\n\nsec = ax.secondary_xaxis(location=0)\nsec.set_xticks([5, 15, 25], labels=['\\nOughts', '\\nTeens', '\\nTwenties'])\n\n# %%\n# This second example adds a second level of annotation to a categorical axis.\n# Here we need to note that each animal (category) is assigned an integer, so\n# ``cats`` is at x=0, ``dogs`` at x=1 etc.  Then we place the ticks on the\n# second level on an x that is at the middle of the animal class we are trying\n# to delineate.\n#\n# This example also adds tick marks between the classes by adding a second\n# secondary xaxis, and placing long, wide ticks at the boundaries between the\n# animal classes.\n\nfig, ax = plt.subplots(layout='constrained', figsize=(7, 4))\n\nax.plot(['cats', 'dogs', 'pigs', 'snakes', 'lizards', 'chickens',\n         'eagles', 'herons', 'buzzards'],\n        rng.normal(size=9), 'o')\n\n# label the classes:\nsec = ax.secondary_xaxis(location=0)\nsec.set_xticks([1, 3.5, 6.5], labels=['\\n\\nMammals', '\\n\\nReptiles', '\\n\\nBirds'])\nsec.tick_params('x', length=0)\n\n# lines between the classes:\nsec2 = ax.secondary_xaxis(location=0)\nsec2.set_xticks([-0.5, 2.5, 4.5, 8.5], labels=[])\nsec2.tick_params('x', length=40, width=1.5)\nax.set_xlim(-0.6, 8.6)\n\n# %%\n# Dates are another common place where we may want to have a second level of\n# tick labels.  In this last example, we take advantage of the ability to add\n# an automatic locator and formatter to the secondary xaxis, which means we do\n# not need to set the ticks manually.\n#\n# This example also differs from the above, in that we placed it at a location\n# below the main axes ``location=-0.075`` and then we hide the spine by setting\n# the line width to zero.  That means that our formatter no longer needs the\n# carriage returns of the previous two examples.\n\nfig, ax = plt.subplots(layout='constrained', figsize=(7, 4))\n\ntime = np.arange(np.datetime64('2020-01-01'), np.datetime64('2020-03-31'),\n                 np.timedelta64(1, 'D'))\n\nax.plot(time, rng.random(size=len(time)))\n\n# just format the days:\nax.xaxis.set_major_formatter(mdates.DateFormatter('%d'))\n\n# label the months:\nsec = ax.secondary_xaxis(location=-0.075)\nsec.xaxis.set_major_locator(mdates.MonthLocator(bymonthday=1))\n\n# note the extra spaces in the label to align the month label inside the month.\n# Note that this could have been done by changing ``bymonthday`` above as well:\nsec.xaxis.set_major_formatter(mdates.DateFormatter('  %b'))\nsec.tick_params('x', length=0)\nsec.spines['bottom'].set_linewidth(0)\n\n# label the xaxis, but note for this to look good, it needs to be on the\n# secondary xaxis.\nsec.set_xlabel('Dates (2020)')\n\nplt.show()\n"
    },
    {
      "filename": "scalarformatter.py",
      "title": "Scalarformatter",
      "code": "\"\"\"\n==========================\nThe default tick formatter\n==========================\n\nBy default, tick labels are formatted using a `.ScalarFormatter`, which can be\nconfigured via `~.axes.Axes.ticklabel_format`.  This example illustrates some\npossible configurations:\n\n- Default.\n- ``useMathText=True``: Fancy formatting of mathematical expressions.\n- ``useOffset=False``: Do not use offset notation; see\n  `.ScalarFormatter.set_useOffset`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0, 1, .01)\nfig, axs = plt.subplots(\n    3, 3, figsize=(9, 9), layout=\"constrained\", gridspec_kw={\"hspace\": 0.1})\n\nfor col in axs.T:\n    col[0].plot(x * 1e5 + 1e10, x * 1e-10 + 1e-5)\n    col[1].plot(x * 1e5, x * 1e-4)\n    col[2].plot(-x * 1e5 - 1e10, -x * 1e-5 - 1e-10)\n\nfor ax in axs[:, 1]:\n    ax.ticklabel_format(useMathText=True)\nfor ax in axs[:, 2]:\n    ax.ticklabel_format(useOffset=False)\n\nplt.rcParams.update({\"axes.titleweight\": \"bold\", \"axes.titley\": 1.1})\naxs[0, 0].set_title(\"default settings\")\naxs[0, 1].set_title(\"useMathText=True\")\naxs[0, 2].set_title(\"useOffset=False\")\n\nplt.show()\n"
    },
    {
      "filename": "tick-formatters.py",
      "title": "Tick-Formatters",
      "code": "\"\"\"\n===============\nTick formatters\n===============\n\nTick formatters define how the numeric value associated with a tick on an axis\nis formatted as a string.\n\nThis example illustrates the usage and effect of the most common formatters.\n\nThe tick format is configured via the function `~.Axis.set_major_formatter`\nor `~.Axis.set_minor_formatter`. It accepts:\n\n- a format string, which implicitly creates a `.StrMethodFormatter`.\n- a function,  implicitly creates a `.FuncFormatter`.\n- an instance of a `.Formatter` subclass. The most common are\n\n  - `.NullFormatter`: No labels on the ticks.\n  - `.StrMethodFormatter`: Use string `str.format` method.\n  - `.FormatStrFormatter`: Use %-style formatting.\n  - `.FuncFormatter`: Define labels through a function.\n  - `.FixedFormatter`: Set the label strings explicitly.\n  - `.ScalarFormatter`: Default formatter for scalars: auto-pick the format string.\n  - `.PercentFormatter`: Format labels as a percentage.\n\n  See :ref:`formatters` for a complete list.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib import ticker\n\n\ndef setup(ax, title):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n\n    # define tick positions\n    ax.xaxis.set_major_locator(ticker.MultipleLocator(1.00))\n    ax.xaxis.set_minor_locator(ticker.MultipleLocator(0.25))\n\n    ax.xaxis.set_ticks_position('bottom')\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5, labelsize=10)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\nfig = plt.figure(figsize=(8, 8), layout='constrained')\nfig0, fig1, fig2 = fig.subfigures(3, height_ratios=[1.5, 1.5, 7.5])\n\nfig0.suptitle('String Formatting', fontsize=16, x=0, ha='left')\nax0 = fig0.subplots()\n\nsetup(ax0, title=\"'{x} km'\")\nax0.xaxis.set_major_formatter('{x} km')\n\n\nfig1.suptitle('Function Formatting', fontsize=16, x=0, ha='left')\nax1 = fig1.subplots()\n\nsetup(ax1, title=\"def(x, pos): return str(x-5)\")\nax1.xaxis.set_major_formatter(lambda x, pos: str(x-5))\n\n\nfig2.suptitle('Formatter Object Formatting', fontsize=16, x=0, ha='left')\naxs2 = fig2.subplots(7, 1)\n\nsetup(axs2[0], title=\"NullFormatter()\")\naxs2[0].xaxis.set_major_formatter(ticker.NullFormatter())\n\nsetup(axs2[1], title=\"StrMethodFormatter('{x:.3f}')\")\naxs2[1].xaxis.set_major_formatter(ticker.StrMethodFormatter(\"{x:.3f}\"))\n\nsetup(axs2[2], title=\"FormatStrFormatter('#%d')\")\naxs2[2].xaxis.set_major_formatter(ticker.FormatStrFormatter(\"#%d\"))\n\n\ndef fmt_two_digits(x, pos):\n    return f'[{x:.2f}]'\n\n\nsetup(axs2[3], title='FuncFormatter(\"[{:.2f}]\".format)')\naxs2[3].xaxis.set_major_formatter(ticker.FuncFormatter(fmt_two_digits))\n\nsetup(axs2[4], title=\"FixedFormatter(['A', 'B', 'C', 'D', 'E', 'F'])\")\n# FixedFormatter should only be used together with FixedLocator.\n# Otherwise, one cannot be sure where the labels will end up.\npositions = [0, 1, 2, 3, 4, 5]\nlabels = ['A', 'B', 'C', 'D', 'E', 'F']\naxs2[4].xaxis.set_major_locator(ticker.FixedLocator(positions))\naxs2[4].xaxis.set_major_formatter(ticker.FixedFormatter(labels))\n\nsetup(axs2[5], title=\"ScalarFormatter()\")\naxs2[5].xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))\n\nsetup(axs2[6], title=\"PercentFormatter(xmax=5)\")\naxs2[6].xaxis.set_major_formatter(ticker.PercentFormatter(xmax=5))\n\nplt.show()\n"
    },
    {
      "filename": "tick-locators.py",
      "title": "Tick-Locators",
      "code": "\"\"\"\n=============\nTick locators\n=============\n\nTick locators define the position of the ticks.\n\nThis example illustrates the usage and effect of the most common locators.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\n\n\ndef setup(ax, title):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n\n    ax.xaxis.set_ticks_position('bottom')\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\nfig, axs = plt.subplots(8, 1, figsize=(8, 6))\n\n# Null Locator\nsetup(axs[0], title=\"NullLocator()\")\naxs[0].xaxis.set_major_locator(ticker.NullLocator())\naxs[0].xaxis.set_minor_locator(ticker.NullLocator())\n\n# Multiple Locator\nsetup(axs[1], title=\"MultipleLocator(0.5, offset=0.2)\")\naxs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5, offset=0.2))\naxs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1))\n\n# Fixed Locator\nsetup(axs[2], title=\"FixedLocator([0, 1, 5])\")\naxs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5]))\naxs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4)))\n\n# Linear Locator\nsetup(axs[3], title=\"LinearLocator(numticks=3)\")\naxs[3].xaxis.set_major_locator(ticker.LinearLocator(3))\naxs[3].xaxis.set_minor_locator(ticker.LinearLocator(31))\n\n# Index Locator\nsetup(axs[4], title=\"IndexLocator(base=0.5, offset=0.25)\")\naxs[4].plot([0]*5, color='white')\naxs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25))\n\n# Auto Locator\nsetup(axs[5], title=\"AutoLocator()\")\naxs[5].xaxis.set_major_locator(ticker.AutoLocator())\naxs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator())\n\n# MaxN Locator\nsetup(axs[6], title=\"MaxNLocator(n=4)\")\naxs[6].xaxis.set_major_locator(ticker.MaxNLocator(4))\naxs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40))\n\n# Log Locator\nsetup(axs[7], title=\"LogLocator(base=10, numticks=15)\")\naxs[7].set_xlim(10**3, 10**10)\naxs[7].set_xscale('log')\naxs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15))\n\nplt.tight_layout()\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The following functions, methods, classes and modules are used in this example:\n#\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.axis.Axis.set_minor_locator`\n#    - `matplotlib.ticker.NullLocator`\n#    - `matplotlib.ticker.MultipleLocator`\n#    - `matplotlib.ticker.FixedLocator`\n#    - `matplotlib.ticker.LinearLocator`\n#    - `matplotlib.ticker.IndexLocator`\n#    - `matplotlib.ticker.AutoLocator`\n#    - `matplotlib.ticker.MaxNLocator`\n#    - `matplotlib.ticker.LogLocator`\n"
    },
    {
      "filename": "tick_label_right.py",
      "title": "Tick Label Right",
      "code": "\"\"\"\n============================================\nSet default y-axis tick labels on the right\n============================================\n\nWe can use :rc:`ytick.labelright`, :rc:`ytick.right`, :rc:`ytick.labelleft`,\nand :rc:`ytick.left` to control where on the axes ticks and their labels\nappear. These properties can also be set in ``.matplotlib/matplotlibrc``.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParams['ytick.right'] = plt.rcParams['ytick.labelright'] = True\nplt.rcParams['ytick.left'] = plt.rcParams['ytick.labelleft'] = False\n\nx = np.arange(10)\n\nfig, (ax0, ax1) = plt.subplots(2, 1, sharex=True, figsize=(6, 6))\n\nax0.plot(x)\nax0.yaxis.tick_left()\n\n# use default parameter in rcParams, not calling tick_right()\nax1.plot(x)\n\nplt.show()\n"
    },
    {
      "filename": "tick_labels_from_values.py",
      "title": "Tick Labels From Values",
      "code": "\"\"\"\n=========================================\nSetting tick labels from a list of values\n=========================================\n\nUsing `.Axes.set_xticks` causes the tick labels to be set on the currently\nchosen ticks. However, you may want to allow matplotlib to dynamically\nchoose the number of ticks and their spacing.\n\nIn this case it may be better to determine the tick label from the\nvalue at the tick. The following example shows how to do this.\n\nNB: The `.ticker.MaxNLocator` is used here to ensure that the tick values\ntake integer values.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.ticker import MaxNLocator\n\nfig, ax = plt.subplots()\nxs = range(26)\nys = range(26)\nlabels = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef format_fn(tick_val, tick_pos):\n    if int(tick_val) in xs:\n        return labels[int(tick_val)]\n    else:\n        return ''\n\n\n# A FuncFormatter is created automatically.\nax.xaxis.set_major_formatter(format_fn)\nax.xaxis.set_major_locator(MaxNLocator(integer=True))\nax.plot(xs, ys)\nplt.show()\n\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.pyplot.subplots`\n#    - `matplotlib.axis.Axis.set_major_formatter`\n#    - `matplotlib.axis.Axis.set_major_locator`\n#    - `matplotlib.ticker.FuncFormatter`\n#    - `matplotlib.ticker.MaxNLocator`\n"
    },
    {
      "filename": "tick_xlabel_top.py",
      "title": "Tick Xlabel Top",
      "code": "\"\"\"\n==================================\nMove x-axis tick labels to the top\n==================================\n\n`~.axes.Axes.tick_params` can be used to configure the ticks. *top* and\n*labeltop* control the visibility tick lines and labels at the top x-axis.\nTo move x-axis ticks from bottom to top, we have to activate the top ticks\nand deactivate the bottom ticks::\n\n    ax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)\n\n.. note::\n\n    If the change should be made for all future plots and not only the current\n    Axes, you can adapt the respective config parameters\n\n    - :rc:`xtick.top`\n    - :rc:`xtick.labeltop`\n    - :rc:`xtick.bottom`\n    - :rc:`xtick.labelbottom`\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)\nax.set_title('x-ticks moved to the top')\n\nplt.show()\n"
    },
    {
      "filename": "ticklabels_rotation.py",
      "title": "Ticklabels Rotation",
      "code": "\"\"\"\n===================\nRotated tick labels\n===================\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4]\ny = [1, 4, 9, 6]\nlabels = ['Frogs', 'Hogs', 'Bogs', 'Slogs']\n\nfig, ax = plt.subplots()\nax.plot(x, y)\n# A tick label rotation can be set using Axes.tick_params.\nax.tick_params(\"y\", rotation=45)\n# Alternatively, if setting custom labels with set_xticks/set_yticks, it can\n# be set at the same time as the labels.\n# For both APIs, the rotation can be an angle in degrees, or one of the strings\n# \"horizontal\" or \"vertical\".\nax.set_xticks(x, labels, rotation='vertical')\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.axes.Axes.tick_params` / `matplotlib.pyplot.tick_params`\n#    - `matplotlib.axes.Axes.set_xticks` / `matplotlib.pyplot.xticks`\n"
    },
    {
      "filename": "ticks_too_many.py",
      "title": "Ticks Too Many",
      "code": "\"\"\"\n=====================\nFixing too many ticks\n=====================\n\nOne common cause for unexpected tick behavior is passing a list of strings\ninstead of numbers or datetime objects. This can easily happen without notice\nwhen reading in a comma-delimited text file. Matplotlib treats lists of strings\nas *categorical* variables\n(:doc:`/gallery/lines_bars_and_markers/categorical_variables`), and by default\nputs one tick per category, and plots them in the order in which they are\nsupplied.  If this is not desired, the solution is to convert the strings to\na numeric type as in the following examples.\n\n\"\"\"\n\n# %%\n# Example 1: Strings can lead to an unexpected order of number ticks\n# ------------------------------------------------------------------\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(1, 2, layout='constrained', figsize=(6, 2.5))\nx = ['1', '5', '2', '3']\ny = [1, 4, 2, 3]\nax[0].plot(x, y, 'd')\nax[0].tick_params(axis='x', color='r', labelcolor='r')\nax[0].set_xlabel('Categories')\nax[0].set_title('Ticks seem out of order / misplaced')\n\n# convert to numbers:\nx = np.asarray(x, dtype='float')\nax[1].plot(x, y, 'd')\nax[1].set_xlabel('Floats')\nax[1].set_title('Ticks as expected')\n\n# %%\n# Example 2: Strings can lead to very many ticks\n# ----------------------------------------------\n# If *x* has 100 elements, all strings, then we would have 100 (unreadable)\n# ticks, and again the solution is to convert the strings to floats:\n\nfig, ax = plt.subplots(1, 2, figsize=(6, 2.5))\nx = [f'{xx}' for xx in np.arange(100)]\ny = np.arange(100)\nax[0].plot(x, y)\nax[0].tick_params(axis='x', color='r', labelcolor='r')\nax[0].set_title('Too many ticks')\nax[0].set_xlabel('Categories')\n\nax[1].plot(np.asarray(x, float), y)\nax[1].set_title('x converted to numbers')\nax[1].set_xlabel('Floats')\n\n# %%\n# Example 3: Strings can lead to an unexpected order of datetime ticks\n# --------------------------------------------------------------------\n# A common case is when dates are read from a CSV file, they need to be\n# converted from strings to datetime objects to get the proper date locators\n# and formatters.\n\nfig, ax = plt.subplots(1, 2, layout='constrained', figsize=(6, 2.75))\nx = ['2021-10-01', '2021-11-02', '2021-12-03', '2021-09-01']\ny = [0, 2, 3, 1]\nax[0].plot(x, y, 'd')\nax[0].tick_params(axis='x', labelrotation=90, color='r', labelcolor='r')\nax[0].set_title('Dates out of order')\n\n# convert to datetime64\nx = np.asarray(x, dtype='datetime64[s]')\nax[1].plot(x, y, 'd')\nax[1].tick_params(axis='x', labelrotation=90)\nax[1].set_title('x converted to datetimes')\n\nplt.show()\n"
    }
  ],
  "units": [
    {
      "filename": "annotate_with_units.py",
      "title": "Annotate With Units",
      "code": "\"\"\"\n=====================\nAnnotation with units\n=====================\n\nThe example illustrates how to create text and arrow\nannotations using a centimeter-scale plot.\n\n.. only:: builder_html\n\n   This example requires :download:`basic_units.py <basic_units.py>`\n\"\"\"\n\nfrom basic_units import cm\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nax.annotate(\"Note 01\", [0.5*cm, 0.5*cm])\n\n# xy and text both unitized\nax.annotate('local max', xy=(3*cm, 1*cm), xycoords='data',\n            xytext=(0.8*cm, 0.95*cm), textcoords='data',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='right', verticalalignment='top')\n\n# mixing units w/ nonunits\nax.annotate('local max', xy=(3*cm, 1*cm), xycoords='data',\n            xytext=(0.8, 0.95), textcoords='axes fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='right', verticalalignment='top')\n\n\nax.set_xlim(0*cm, 4*cm)\nax.set_ylim(0*cm, 4*cm)\nplt.show()\n"
    },
    {
      "filename": "artist_tests.py",
      "title": "Artist Tests",
      "code": "\"\"\"\n============\nArtist tests\n============\n\nTest unit support with each of the Matplotlib primitive artist types.\n\nThe axis handles unit conversions and the artists keep a pointer to their axis\nparent. You must initialize the artists with the axis instance if you want to\nuse them with unit data, or else they will not know how to convert the units\nto scalars.\n\n.. only:: builder_html\n\n   This example requires :download:`basic_units.py <basic_units.py>`\n\"\"\"\nimport random\n\nfrom basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.collections as collections\nimport matplotlib.lines as lines\nimport matplotlib.patches as patches\nimport matplotlib.text as text\n\nfig, ax = plt.subplots()\nax.xaxis.set_units(cm)\nax.yaxis.set_units(cm)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nif 0:\n    # test a line collection\n    # Not supported at present.\n    verts = []\n    for i in range(10):\n        # a random line segment in inches\n        verts.append(zip(*inch*10*np.random.rand(2, random.randint(2, 15))))\n    lc = collections.LineCollection(verts, axes=ax)\n    ax.add_collection(lc)\n\n# test a plain-ol-line\nline = lines.Line2D([0*cm, 1.5*cm], [0*cm, 2.5*cm],\n                    lw=2, color='black', axes=ax)\nax.add_line(line)\n\nif 0:\n    # test a patch\n    # Not supported at present.\n    rect = patches.Rectangle((1*cm, 1*cm), width=5*cm, height=2*cm,\n                             alpha=0.2, axes=ax)\n    ax.add_patch(rect)\n\n\nt = text.Text(3*cm, 2.5*cm, 'text label', ha='left', va='bottom', axes=ax)\nax.add_artist(t)\n\nax.set_xlim(-1*cm, 10*cm)\nax.set_ylim(-1*cm, 10*cm)\n# ax.xaxis.set_units(inch)\nax.grid(True)\nax.set_title(\"Artists with units\")\nplt.show()\n"
    },
    {
      "filename": "bar_demo2.py",
      "title": "Bar Demo2",
      "code": "\"\"\"\n===================\nBar demo with units\n===================\n\nA plot using a variety of centimetre and inch conversions. This example shows\nhow default unit introspection works (ax1), how various keywords can be used to\nset the x and y units to override the defaults (ax2, ax3, ax4) and how one can\nset the xlimits using scalars (ax3, current units assumed) or units\n(conversions applied to get the numbers to current units).\n\n.. only:: builder_html\n\n   This example requires :download:`basic_units.py <basic_units.py>`\n\"\"\"\nfrom basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncms = cm * np.arange(0, 10, 2)\nbottom = 0 * cm\nwidth = 0.8 * cm\n\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].bar(cms, cms, bottom=bottom)\n\naxs[0, 1].bar(cms, cms, bottom=bottom, width=width, xunits=cm, yunits=inch)\n\naxs[1, 0].bar(cms, cms, bottom=bottom, width=width, xunits=inch, yunits=cm)\naxs[1, 0].set_xlim(2, 6)  # scalars are interpreted in current units\n\naxs[1, 1].bar(cms, cms, bottom=bottom, width=width, xunits=inch, yunits=inch)\naxs[1, 1].set_xlim(2 * cm, 6 * cm)  # cm are converted to inches\n\nfig.tight_layout()\nplt.show()\n"
    },
    {
      "filename": "bar_unit_demo.py",
      "title": "Bar Unit Demo",
      "code": "\"\"\"\n=========================\nGroup barchart with units\n=========================\n\nThis is the same example as\n:doc:`the barchart</gallery/lines_bars_and_markers/barchart>` in\ncentimeters.\n\n.. only:: builder_html\n\n   This example requires :download:`basic_units.py <basic_units.py>`\n\"\"\"\n\nfrom basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nN = 5\ntea_means = [15*cm, 10*cm, 8*cm, 12*cm, 5*cm]\ntea_std = [2*cm, 1*cm, 1*cm, 4*cm, 2*cm]\n\nfig, ax = plt.subplots()\nax.yaxis.set_units(inch)\n\nind = np.arange(N)    # the x locations for the groups\nwidth = 0.35         # the width of the bars\nax.bar(ind, tea_means, width, bottom=0*cm, yerr=tea_std, label='Tea')\n\ncoffee_means = (14*cm, 19*cm, 7*cm, 5*cm, 10*cm)\ncoffee_std = (3*cm, 5*cm, 2*cm, 1*cm, 2*cm)\nax.bar(ind + width, coffee_means, width, bottom=0*cm, yerr=coffee_std,\n       label='Coffee')\n\nax.set_title('Cup height by group and beverage choice')\nax.set_xticks(ind + width / 2, labels=['G1', 'G2', 'G3', 'G4', 'G5'])\n\nax.legend()\nax.autoscale_view()\n\nplt.show()\n"
    },
    {
      "filename": "basic_units.py",
      "title": "Basic Units",
      "code": "\"\"\"\n.. _basic_units:\n\n===========\nBasic units\n===========\n\n\nThis file implements a units library that supports registering arbitrary units,\nconversions between units, and math with unitized data. This library also implements a\nMatplotlib unit converter and registers its units with Matplotlib. This library is used\nin the examples to demonstrate Matplotlib's unit support. It is only maintained for the\npurposes of building documentation and should never be used outside of the Matplotlib\ndocumentation.\n\n\"\"\"\n\nimport itertools\nimport math\n\nfrom packaging.version import parse as parse_version\n\nimport numpy as np\n\nimport matplotlib.ticker as ticker\nimport matplotlib.units as units\n\n\nclass ProxyDelegate:\n    def __init__(self, fn_name, proxy_type):\n        self.proxy_type = proxy_type\n        self.fn_name = fn_name\n\n    def __get__(self, obj, objtype=None):\n        return self.proxy_type(self.fn_name, obj)\n\n\nclass TaggedValueMeta(type):\n    def __init__(self, name, bases, dict):\n        for fn_name in self._proxies:\n            if not hasattr(self, fn_name):\n                setattr(self, fn_name,\n                        ProxyDelegate(fn_name, self._proxies[fn_name]))\n\n\nclass PassThroughProxy:\n    def __init__(self, fn_name, obj):\n        self.fn_name = fn_name\n        self.target = obj.proxy_target\n\n    def __call__(self, *args):\n        fn = getattr(self.target, self.fn_name)\n        ret = fn(*args)\n        return ret\n\n\nclass ConvertArgsProxy(PassThroughProxy):\n    def __init__(self, fn_name, obj):\n        super().__init__(fn_name, obj)\n        self.unit = obj.unit\n\n    def __call__(self, *args):\n        converted_args = []\n        for a in args:\n            try:\n                converted_args.append(a.convert_to(self.unit))\n            except AttributeError:\n                converted_args.append(TaggedValue(a, self.unit))\n        converted_args = tuple([c.get_value() for c in converted_args])\n        return super().__call__(*converted_args)\n\n\nclass ConvertReturnProxy(PassThroughProxy):\n    def __init__(self, fn_name, obj):\n        super().__init__(fn_name, obj)\n        self.unit = obj.unit\n\n    def __call__(self, *args):\n        ret = super().__call__(*args)\n        return (NotImplemented if ret is NotImplemented\n                else TaggedValue(ret, self.unit))\n\n\nclass ConvertAllProxy(PassThroughProxy):\n    def __init__(self, fn_name, obj):\n        super().__init__(fn_name, obj)\n        self.unit = obj.unit\n\n    def __call__(self, *args):\n        converted_args = []\n        arg_units = [self.unit]\n        for a in args:\n            if hasattr(a, 'get_unit') and not hasattr(a, 'convert_to'):\n                # If this argument has a unit type but no conversion ability,\n                # this operation is prohibited.\n                return NotImplemented\n\n            if hasattr(a, 'convert_to'):\n                try:\n                    a = a.convert_to(self.unit)\n                except Exception:\n                    pass\n                arg_units.append(a.get_unit())\n                converted_args.append(a.get_value())\n            else:\n                converted_args.append(a)\n                if hasattr(a, 'get_unit'):\n                    arg_units.append(a.get_unit())\n                else:\n                    arg_units.append(None)\n        converted_args = tuple(converted_args)\n        ret = super().__call__(*converted_args)\n        if ret is NotImplemented:\n            return NotImplemented\n        ret_unit = unit_resolver(self.fn_name, arg_units)\n        if ret_unit is NotImplemented:\n            return NotImplemented\n        return TaggedValue(ret, ret_unit)\n\n\nclass TaggedValue(metaclass=TaggedValueMeta):\n\n    _proxies = {'__add__': ConvertAllProxy,\n                '__sub__': ConvertAllProxy,\n                '__mul__': ConvertAllProxy,\n                '__rmul__': ConvertAllProxy,\n                '__cmp__': ConvertAllProxy,\n                '__lt__': ConvertAllProxy,\n                '__gt__': ConvertAllProxy,\n                '__len__': PassThroughProxy}\n\n    def __new__(cls, value, unit):\n        # generate a new subclass for value\n        value_class = type(value)\n        try:\n            subcls = type(f'TaggedValue_of_{value_class.__name__}',\n                          (cls, value_class), {})\n            return object.__new__(subcls)\n        except TypeError:\n            return object.__new__(cls)\n\n    def __init__(self, value, unit):\n        self.value = value\n        self.unit = unit\n        self.proxy_target = self.value\n\n    def __copy__(self):\n        return TaggedValue(self.value, self.unit)\n\n    def __getattribute__(self, name):\n        if name.startswith('__'):\n            return object.__getattribute__(self, name)\n        variable = object.__getattribute__(self, 'value')\n        if hasattr(variable, name) and name not in self.__class__.__dict__:\n            return getattr(variable, name)\n        return object.__getattribute__(self, name)\n\n    def __array__(self, dtype=object, copy=False):\n        return np.asarray(self.value, dtype)\n\n    def __array_wrap__(self, array, context=None, return_scalar=False):\n        return TaggedValue(array, self.unit)\n\n    def __repr__(self):\n        return f'TaggedValue({self.value!r}, {self.unit!r})'\n\n    def __str__(self):\n        return f\"{self.value} in {self.unit}\"\n\n    def __len__(self):\n        return len(self.value)\n\n    if parse_version(np.__version__) >= parse_version('1.20'):\n        def __getitem__(self, key):\n            return TaggedValue(self.value[key], self.unit)\n\n    def __iter__(self):\n        # Return a generator expression rather than use `yield`, so that\n        # TypeError is raised by iter(self) if appropriate when checking for\n        # iterability.\n        return (TaggedValue(inner, self.unit) for inner in self.value)\n\n    def get_compressed_copy(self, mask):\n        new_value = np.ma.masked_array(self.value, mask=mask).compressed()\n        return TaggedValue(new_value, self.unit)\n\n    def convert_to(self, unit):\n        if unit == self.unit or not unit:\n            return self\n        try:\n            new_value = self.unit.convert_value_to(self.value, unit)\n        except AttributeError:\n            new_value = self\n        return TaggedValue(new_value, unit)\n\n    def get_value(self):\n        return self.value\n\n    def get_unit(self):\n        return self.unit\n\n\nclass BasicUnit:\n    # numpy scalars convert eager and np.float64(2) * BasicUnit('cm')\n    # would thus return a numpy scalar. To avoid this, we increase the\n    # priority of the BasicUnit.\n    __array_priority__ = np.float64(0).__array_priority__ + 1\n\n    def __init__(self, name, fullname=None):\n        self.name = name\n        if fullname is None:\n            fullname = name\n        self.fullname = fullname\n        self.conversions = dict()\n\n    def __repr__(self):\n        return f'BasicUnit({self.name})'\n\n    def __str__(self):\n        return self.fullname\n\n    def __call__(self, value):\n        return TaggedValue(value, self)\n\n    def __mul__(self, rhs):\n        value = rhs\n        unit = self\n        if hasattr(rhs, 'get_unit'):\n            value = rhs.get_value()\n            unit = rhs.get_unit()\n            unit = unit_resolver('__mul__', (self, unit))\n        if unit is NotImplemented:\n            return NotImplemented\n        return TaggedValue(value, unit)\n\n    def __rmul__(self, lhs):\n        return self*lhs\n\n    def __array_wrap__(self, array, context=None, return_scalar=False):\n        return TaggedValue(array, self)\n\n    def __array__(self, t=None, context=None, copy=False):\n        ret = np.array(1)\n        if t is not None:\n            return ret.astype(t)\n        else:\n            return ret\n\n    def add_conversion_factor(self, unit, factor):\n        def convert(x):\n            return x*factor\n        self.conversions[unit] = convert\n\n    def add_conversion_fn(self, unit, fn):\n        self.conversions[unit] = fn\n\n    def get_conversion_fn(self, unit):\n        return self.conversions[unit]\n\n    def convert_value_to(self, value, unit):\n        conversion_fn = self.conversions[unit]\n        ret = conversion_fn(value)\n        return ret\n\n    def get_unit(self):\n        return self\n\n\nclass UnitResolver:\n    def addition_rule(self, units):\n        for unit_1, unit_2 in itertools.pairwise(units):\n            if unit_1 != unit_2:\n                return NotImplemented\n        return units[0]\n\n    def multiplication_rule(self, units):\n        non_null = [u for u in units if u]\n        if len(non_null) > 1:\n            return NotImplemented\n        return non_null[0]\n\n    op_dict = {\n        '__mul__': multiplication_rule,\n        '__rmul__': multiplication_rule,\n        '__add__': addition_rule,\n        '__radd__': addition_rule,\n        '__sub__': addition_rule,\n        '__rsub__': addition_rule}\n\n    def __call__(self, operation, units):\n        if operation not in self.op_dict:\n            return NotImplemented\n\n        return self.op_dict[operation](self, units)\n\n\nunit_resolver = UnitResolver()\n\ncm = BasicUnit('cm', 'centimeters')\ninch = BasicUnit('inch', 'inches')\ninch.add_conversion_factor(cm, 2.54)\ncm.add_conversion_factor(inch, 1/2.54)\n\nradians = BasicUnit('rad', 'radians')\ndegrees = BasicUnit('deg', 'degrees')\nradians.add_conversion_factor(degrees, 180.0/np.pi)\ndegrees.add_conversion_factor(radians, np.pi/180.0)\n\nsecs = BasicUnit('s', 'seconds')\nhertz = BasicUnit('Hz', 'Hertz')\nminutes = BasicUnit('min', 'minutes')\n\nsecs.add_conversion_fn(hertz, lambda x: 1./x)\nsecs.add_conversion_factor(minutes, 1/60.0)\n\n\n# radians formatting\ndef rad_fn(x, pos=None):\n    if x >= 0:\n        n = int((x / np.pi) * 2.0 + 0.25)\n    else:\n        n = int((x / np.pi) * 2.0 - 0.25)\n\n    if n == 0:\n        return '0'\n    elif n == 1:\n        return r'$\\pi/2$'\n    elif n == 2:\n        return r'$\\pi$'\n    elif n == -1:\n        return r'$-\\pi/2$'\n    elif n == -2:\n        return r'$-\\pi$'\n    elif n % 2 == 0:\n        return fr'${n//2}\\pi$'\n    else:\n        return fr'${n}\\pi/2$'\n\n\nclass BasicUnitConverter(units.ConversionInterface):\n    @staticmethod\n    def axisinfo(unit, axis):\n        \"\"\"Return AxisInfo instance for x and unit.\"\"\"\n\n        if unit == radians:\n            return units.AxisInfo(\n                majloc=ticker.MultipleLocator(base=np.pi/2),\n                majfmt=ticker.FuncFormatter(rad_fn),\n                label=unit.fullname,\n            )\n        elif unit == degrees:\n            return units.AxisInfo(\n                majloc=ticker.AutoLocator(),\n                majfmt=ticker.FormatStrFormatter(r'$%i^\\circ$'),\n                label=unit.fullname,\n            )\n        elif unit is not None:\n            if hasattr(unit, 'fullname'):\n                return units.AxisInfo(label=unit.fullname)\n            elif hasattr(unit, 'unit'):\n                return units.AxisInfo(label=unit.unit.fullname)\n        return None\n\n    @staticmethod\n    def convert(val, unit, axis):\n        if np.iterable(val):\n            if isinstance(val, np.ma.MaskedArray):\n                val = val.astype(float).filled(np.nan)\n            out = np.empty(len(val))\n            for i, thisval in enumerate(val):\n                if np.ma.is_masked(thisval):\n                    out[i] = np.nan\n                else:\n                    try:\n                        out[i] = thisval.convert_to(unit).get_value()\n                    except AttributeError:\n                        out[i] = thisval\n            return out\n        if np.ma.is_masked(val):\n            return np.nan\n        else:\n            return val.convert_to(unit).get_value()\n\n    @staticmethod\n    def default_units(x, axis):\n        \"\"\"Return the default unit for x or None.\"\"\"\n        if np.iterable(x):\n            for thisx in x:\n                return thisx.unit\n        return x.unit\n\n\ndef cos(x):\n    if np.iterable(x):\n        return [math.cos(val.convert_to(radians).get_value()) for val in x]\n    else:\n        return math.cos(x.convert_to(radians).get_value())\n\n\nunits.registry[BasicUnit] = units.registry[TaggedValue] = BasicUnitConverter()\n"
    },
    {
      "filename": "ellipse_with_units.py",
      "title": "Ellipse With Units",
      "code": "\"\"\"\n==================\nEllipse with units\n==================\n\nCompare the ellipse generated with arcs versus a polygonal approximation.\n\n.. only:: builder_html\n\n   This example requires :download:`basic_units.py <basic_units.py>`\n\"\"\"\n\nfrom basic_units import cm\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patches\n\nxcenter, ycenter = 0.38*cm, 0.52*cm\nwidth, height = 1e-1*cm, 3e-1*cm\nangle = -30\n\ntheta = np.deg2rad(np.arange(0.0, 360.0, 1.0))\nx = 0.5 * width * np.cos(theta)\ny = 0.5 * height * np.sin(theta)\n\nrtheta = np.radians(angle)\nR = np.array([\n    [np.cos(rtheta), -np.sin(rtheta)],\n    [np.sin(rtheta),  np.cos(rtheta)],\n    ])\n\n\nx, y = np.dot(R, [x, y])\nx += xcenter\ny += ycenter\n\n# %%\n\nfig = plt.figure()\nax = fig.add_subplot(211, aspect='auto')\nax.fill(x, y, alpha=0.2, facecolor='yellow',\n        edgecolor='yellow', linewidth=1, zorder=1)\n\ne1 = patches.Ellipse((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\nax.add_patch(e1)\n\nax = fig.add_subplot(212, aspect='equal')\nax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)\ne2 = patches.Ellipse((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\n\nax.add_patch(e2)\nfig.savefig('ellipse_compare')\n\n# %%\n\nfig = plt.figure()\nax = fig.add_subplot(211, aspect='auto')\nax.fill(x, y, alpha=0.2, facecolor='yellow',\n        edgecolor='yellow', linewidth=1, zorder=1)\n\ne1 = patches.Arc((xcenter, ycenter), width, height,\n                 angle=angle, linewidth=2, fill=False, zorder=2)\n\nax.add_patch(e1)\n\nax = fig.add_subplot(212, aspect='equal')\nax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)\ne2 = patches.Arc((xcenter, ycenter), width, height,\n                 angle=angle, linewidth=2, fill=False, zorder=2)\n\n\nax.add_patch(e2)\nfig.savefig('arc_compare')\n\nplt.show()\n"
    },
    {
      "filename": "evans_test.py",
      "title": "Evans Test",
      "code": "\"\"\"\n==========\nEvans test\n==========\n\nA mockup \"Foo\" units class which supports conversion and different tick\nformatting depending on the \"unit\".  Here the \"unit\" is just a scalar\nconversion factor, but this example shows that Matplotlib is entirely agnostic\nto what kind of units client packages use.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\nimport matplotlib.units as units\n\n\nclass Foo:\n    def __init__(self, val, unit=1.0):\n        self.unit = unit\n        self._val = val * unit\n\n    def value(self, unit):\n        if unit is None:\n            unit = self.unit\n        return self._val / unit\n\n\nclass FooConverter(units.ConversionInterface):\n    @staticmethod\n    def axisinfo(unit, axis):\n        \"\"\"Return the Foo AxisInfo.\"\"\"\n        if unit == 1.0 or unit == 2.0:\n            return units.AxisInfo(\n                majloc=ticker.IndexLocator(8, 0),\n                majfmt=ticker.FormatStrFormatter(\"VAL: %s\"),\n                label='foo',\n                )\n\n        else:\n            return None\n\n    @staticmethod\n    def convert(obj, unit, axis):\n        \"\"\"\n        Convert *obj* using *unit*.\n\n        If *obj* is a sequence, return the converted sequence.\n        \"\"\"\n        if np.iterable(obj):\n            return [o.value(unit) for o in obj]\n        else:\n            return obj.value(unit)\n\n    @staticmethod\n    def default_units(x, axis):\n        \"\"\"Return the default unit for *x* or None.\"\"\"\n        if np.iterable(x):\n            for thisx in x:\n                return thisx.unit\n        else:\n            return x.unit\n\n\nunits.registry[Foo] = FooConverter()\n\n# create some Foos\nx = [Foo(val, 1.0) for val in range(0, 50, 2)]\n# and some arbitrary y data\ny = [i for i in range(len(x))]\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.suptitle(\"Custom units\")\nfig.subplots_adjust(bottom=0.2)\n\n# plot specifying units\nax2.plot(x, y, 'o', xunits=2.0)\nax2.set_title(\"xunits = 2.0\")\nplt.setp(ax2.get_xticklabels(), rotation=30, ha='right')\n\n# plot without specifying units; will use the None branch for axisinfo\nax1.plot(x, y)  # uses default units\nax1.set_title('default units')\nplt.setp(ax1.get_xticklabels(), rotation=30, ha='right')\n\nplt.show()\n"
    },
    {
      "filename": "radian_demo.py",
      "title": "Radian Demo",
      "code": "\"\"\"\n============\nRadian ticks\n============\n\nPlot with radians from the basic_units mockup example package.\n\n\nThis example shows how the unit class can determine the tick locating,\nformatting and axis labeling.\n\n.. only:: builder_html\n\n   This example requires :download:`basic_units.py <basic_units.py>`\n\"\"\"\n\nfrom basic_units import cos, degrees, radians\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = [val*radians for val in np.arange(0, 15, 0.01)]\n\nfig, axs = plt.subplots(2)\n\naxs[0].plot(x, cos(x), xunits=radians)\naxs[1].plot(x, cos(x), xunits=degrees)\n\nfig.tight_layout()\nplt.show()\n"
    },
    {
      "filename": "units_sample.py",
      "title": "Units Sample",
      "code": "\"\"\"\n======================\nInches and centimeters\n======================\n\nThe example illustrates the ability to override default x and y units (ax1) to\ninches and centimeters using the *xunits* and *yunits* parameters for the\n`~.axes.Axes.plot` function. Note that conversions are applied to get numbers\nto correct units.\n\n.. only:: builder_html\n\n   This example requires :download:`basic_units.py <basic_units.py>`\n\n\"\"\"\nfrom basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncms = cm * np.arange(0, 10, 2)\n\nfig, axs = plt.subplots(2, 2, layout='constrained')\n\naxs[0, 0].plot(cms, cms)\n\naxs[0, 1].plot(cms, cms, xunits=cm, yunits=inch)\n\naxs[1, 0].plot(cms, cms, xunits=inch, yunits=cm)\naxs[1, 0].set_xlim(-1, 4)  # scalars are interpreted in current units\n\naxs[1, 1].plot(cms, cms, xunits=inch, yunits=inch)\naxs[1, 1].set_xlim(3*cm, 6*cm)  # cm are converted to inches\n\nplt.show()\n"
    },
    {
      "filename": "units_scatter.py",
      "title": "Units Scatter",
      "code": "\"\"\"\n=============\nUnit handling\n=============\n\nThe example below shows support for unit conversions over masked\narrays.\n\n.. only:: builder_html\n\n   This example requires :download:`basic_units.py <basic_units.py>`\n\"\"\"\nfrom basic_units import hertz, minutes, secs\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# create masked array\ndata = (1, 2, 3, 4, 5, 6, 7, 8)\nmask = (1, 0, 1, 0, 0, 0, 1, 0)\nxsecs = secs * np.ma.MaskedArray(data, mask, float)\n\nfig, (ax1, ax2, ax3) = plt.subplots(nrows=3, sharex=True)\n\nax1.scatter(xsecs, xsecs)\nax1.yaxis.set_units(secs)\nax2.scatter(xsecs, xsecs, yunits=hertz)\nax3.scatter(xsecs, xsecs, yunits=minutes)\n\nfig.tight_layout()\nplt.show()\n"
    }
  ],
  "user_interfaces": [
    {
      "filename": "canvasagg.py",
      "title": "Canvasagg",
      "code": "\"\"\"\n==============\nCanvasAgg demo\n==============\n\nThis example shows how to use the agg backend directly to create images, which\nmay be of use to web application developers who want full control over their\ncode without using the pyplot interface to manage figures, figure closing etc.\n\n.. note::\n\n    It is not necessary to avoid using the pyplot interface in order to\n    create figures without a graphical front-end - simply setting\n    the backend to \"Agg\" would be sufficient.\n\nIn this example, we show how to save the contents of the agg canvas to a file,\nand how to extract them to a numpy array, which can in turn be passed off\nto Pillow_.  The latter functionality allows e.g. to use Matplotlib inside a\ncgi-script *without* needing to write a figure to disk, and to write images in\nany format supported by Pillow.\n\n.. _Pillow: https://pillow.readthedocs.io/\n.. redirect-from:: /gallery/misc/agg_buffer\n.. redirect-from:: /gallery/misc/agg_buffer_to_array\n\"\"\"\n\nfrom PIL import Image\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg\nfrom matplotlib.figure import Figure\n\nfig = Figure(figsize=(5, 4), dpi=100)\n# A canvas must be manually attached to the figure (pyplot would automatically\n# do it).  This is done by instantiating the canvas with the figure as\n# argument.\ncanvas = FigureCanvasAgg(fig)\n\n# Do some plotting.\nax = fig.add_subplot()\nax.plot([1, 2, 3])\n\n# Option 1: Save the figure to a file; can also be a file-like object (BytesIO,\n# etc.).\nfig.savefig(\"test.png\")\n\n# Option 2: Retrieve a memoryview on the renderer buffer, and convert it to a\n# numpy array.\ncanvas.draw()\nrgba = np.asarray(canvas.buffer_rgba())\n# ... and pass it to PIL.\nim = Image.fromarray(rgba)\n# This image can then be saved to any format supported by Pillow, e.g.:\nim.save(\"test.bmp\")\n\n# Uncomment this line to display the image using ImageMagick's `display` tool.\n# im.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.backends.backend_agg.FigureCanvasAgg`\n#    - `matplotlib.figure.Figure`\n#    - `matplotlib.figure.Figure.add_subplot`\n#    - `matplotlib.figure.Figure.savefig` / `matplotlib.pyplot.savefig`\n#    - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`\n"
    },
    {
      "filename": "embedding_in_gtk3_panzoom_sgskip.py",
      "title": "Embedding In Gtk3 Panzoom Sgskip",
      "code": "\"\"\"\n=======================================\nEmbed in GTK3 with a navigation toolbar\n=======================================\n\nDemonstrate NavigationToolbar with GTK3 accessed via pygobject.\n\"\"\"\n\nimport gi\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3 import \\\n    NavigationToolbar2GTK3 as NavigationToolbar\nfrom matplotlib.backends.backend_gtk3agg import \\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nwin = Gtk.Window()\nwin.connect(\"delete-event\", Gtk.main_quit)\nwin.set_default_size(400, 300)\nwin.set_title(\"Embedded in GTK3\")\n\nfig = Figure(figsize=(5, 4), dpi=100)\nax = fig.add_subplot(1, 1, 1)\nt = np.arange(0.0, 3.0, 0.01)\ns = np.sin(2*np.pi*t)\nax.plot(t, s)\n\nvbox = Gtk.VBox()\nwin.add(vbox)\n\n# Add canvas to vbox\ncanvas = FigureCanvas(fig)  # a Gtk.DrawingArea\nvbox.pack_start(canvas, True, True, 0)\n\n# Create toolbar\ntoolbar = NavigationToolbar(canvas)\nvbox.pack_start(toolbar, False, False, 0)\n\nwin.show_all()\nGtk.main()\n"
    },
    {
      "filename": "embedding_in_gtk3_sgskip.py",
      "title": "Embedding In Gtk3 Sgskip",
      "code": "\"\"\"\n=============\nEmbed in GTK3\n=============\n\nDemonstrate adding a FigureCanvasGTK3Agg widget to a Gtk.ScrolledWindow using\nGTK3 accessed via pygobject.\n\"\"\"\n\nimport gi\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3agg import \\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nwin = Gtk.Window()\nwin.connect(\"delete-event\", Gtk.main_quit)\nwin.set_default_size(400, 300)\nwin.set_title(\"Embedded in GTK3\")\n\nfig = Figure(figsize=(5, 4), dpi=100)\nax = fig.add_subplot()\nt = np.arange(0.0, 3.0, 0.01)\ns = np.sin(2*np.pi*t)\nax.plot(t, s)\n\nsw = Gtk.ScrolledWindow()\nwin.add(sw)\n# A scrolled window border goes outside the scrollbars and viewport\nsw.set_border_width(10)\n\ncanvas = FigureCanvas(fig)  # a Gtk.DrawingArea\ncanvas.set_size_request(800, 600)\nsw.add(canvas)\n\nwin.show_all()\nGtk.main()\n"
    },
    {
      "filename": "embedding_in_gtk4_panzoom_sgskip.py",
      "title": "Embedding In Gtk4 Panzoom Sgskip",
      "code": "\"\"\"\n=======================================\nEmbed in GTK4 with a navigation toolbar\n=======================================\n\nDemonstrate NavigationToolbar with GTK4 accessed via pygobject.\n\"\"\"\n\nimport gi\n\ngi.require_version('Gtk', '4.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk4 import \\\n    NavigationToolbar2GTK4 as NavigationToolbar\nfrom matplotlib.backends.backend_gtk4agg import \\\n    FigureCanvasGTK4Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\ndef on_activate(app):\n    win = Gtk.ApplicationWindow(application=app)\n    win.set_default_size(400, 300)\n    win.set_title(\"Embedded in GTK4\")\n\n    fig = Figure(figsize=(5, 4), dpi=100)\n    ax = fig.add_subplot(1, 1, 1)\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    ax.plot(t, s)\n\n    vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)\n    win.set_child(vbox)\n\n    # Add canvas to vbox\n    canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n    canvas.set_hexpand(True)\n    canvas.set_vexpand(True)\n    vbox.append(canvas)\n\n    # Create toolbar\n    toolbar = NavigationToolbar(canvas)\n    vbox.append(toolbar)\n\n    win.present()\n\n\napp = Gtk.Application(application_id='org.matplotlib.examples.EmbeddingInGTK4PanZoom')\napp.connect('activate', on_activate)\napp.run(None)\n"
    },
    {
      "filename": "embedding_in_gtk4_sgskip.py",
      "title": "Embedding In Gtk4 Sgskip",
      "code": "\"\"\"\n=============\nEmbed in GTK4\n=============\n\nDemonstrate adding a FigureCanvasGTK4Agg widget to a Gtk.ScrolledWindow using\nGTK4 accessed via pygobject.\n\"\"\"\n\nimport gi\n\ngi.require_version('Gtk', '4.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk4agg import \\\n    FigureCanvasGTK4Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\ndef on_activate(app):\n    win = Gtk.ApplicationWindow(application=app)\n    win.set_default_size(400, 300)\n    win.set_title(\"Embedded in GTK4\")\n\n    fig = Figure(figsize=(5, 4), dpi=100)\n    ax = fig.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    ax.plot(t, s)\n\n    # A scrolled margin goes outside the scrollbars and viewport.\n    sw = Gtk.ScrolledWindow(margin_top=10, margin_bottom=10,\n                            margin_start=10, margin_end=10)\n    win.set_child(sw)\n\n    canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n    canvas.set_size_request(800, 600)\n    sw.set_child(canvas)\n\n    win.present()\n\n\napp = Gtk.Application(application_id='org.matplotlib.examples.EmbeddingInGTK4')\napp.connect('activate', on_activate)\napp.run(None)\n"
    },
    {
      "filename": "embedding_in_qt_sgskip.py",
      "title": "Embedding In Qt Sgskip",
      "code": "\"\"\"\n===========\nEmbed in Qt\n===========\n\nSimple Qt application embedding Matplotlib canvases.  This program will work\nequally well using any Qt binding (PyQt6, PySide6, PyQt5, PySide2).  The\nbinding can be selected by setting the :envvar:`QT_API` environment variable to\nthe binding name, or by first importing it.\n\"\"\"\n\nimport sys\nimport time\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_qtagg import FigureCanvas\nfrom matplotlib.backends.backend_qtagg import \\\n    NavigationToolbar2QT as NavigationToolbar\nfrom matplotlib.backends.qt_compat import QtWidgets\nfrom matplotlib.figure import Figure\n\n\nclass ApplicationWindow(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self._main = QtWidgets.QWidget()\n        self.setCentralWidget(self._main)\n        layout = QtWidgets.QVBoxLayout(self._main)\n\n        static_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        # Ideally one would use self.addToolBar here, but it is slightly\n        # incompatible between PyQt6 and other bindings, so we just add the\n        # toolbar as a plain widget instead.\n        layout.addWidget(NavigationToolbar(static_canvas, self))\n        layout.addWidget(static_canvas)\n\n        dynamic_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        layout.addWidget(dynamic_canvas)\n        layout.addWidget(NavigationToolbar(dynamic_canvas, self))\n\n        self._static_ax = static_canvas.figure.subplots()\n        t = np.linspace(0, 10, 501)\n        self._static_ax.plot(t, np.tan(t), \".\")\n\n        self._dynamic_ax = dynamic_canvas.figure.subplots()\n        # Set up a Line2D.\n        self.xdata = np.linspace(0, 10, 101)\n        self._update_ydata()\n        self._line, = self._dynamic_ax.plot(self.xdata, self.ydata)\n        # The below two timers must be attributes of self, so that the garbage\n        # collector won't clean them after we finish with __init__...\n\n        # The data retrieval may be fast as possible (Using QRunnable could be\n        # even faster).\n        self.data_timer = dynamic_canvas.new_timer(1)\n        self.data_timer.add_callback(self._update_ydata)\n        self.data_timer.start()\n        # Drawing at 50Hz should be fast enough for the GUI to feel smooth, and\n        # not too fast for the GUI to be overloaded with events that need to be\n        # processed while the GUI element is changed.\n        self.drawing_timer = dynamic_canvas.new_timer(20)\n        self.drawing_timer.add_callback(self._update_canvas)\n        self.drawing_timer.start()\n\n    def _update_ydata(self):\n        # Shift the sinusoid as a function of time.\n        self.ydata = np.sin(self.xdata + time.time())\n\n    def _update_canvas(self):\n        self._line.set_data(self.xdata, self.ydata)\n        # It should be safe to use the synchronous draw() method for most drawing\n        # frequencies, but it is safer to use draw_idle().\n        self._line.figure.canvas.draw_idle()\n\n\nif __name__ == \"__main__\":\n    # Check whether there is already a running QApplication (e.g., if running\n    # from an IDE).\n    qapp = QtWidgets.QApplication.instance()\n    if not qapp:\n        qapp = QtWidgets.QApplication(sys.argv)\n\n    app = ApplicationWindow()\n    app.show()\n    app.activateWindow()\n    app.raise_()\n    qapp.exec()\n"
    },
    {
      "filename": "embedding_in_tk_sgskip.py",
      "title": "Embedding In Tk Sgskip",
      "code": "\"\"\"\n===========\nEmbed in Tk\n===========\n\n\"\"\"\n\nimport tkinter\n\nimport numpy as np\n\n# Implement the default Matplotlib key bindings.\nfrom matplotlib.backend_bases import key_press_handler\nfrom matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg,\n                                               NavigationToolbar2Tk)\nfrom matplotlib.figure import Figure\n\nroot = tkinter.Tk()\nroot.wm_title(\"Embedded in Tk\")\n\nfig = Figure(figsize=(5, 4), dpi=100)\nt = np.arange(0, 3, .01)\nax = fig.add_subplot()\nline, = ax.plot(t, 2 * np.sin(2 * np.pi * t))\nax.set_xlabel(\"time [s]\")\nax.set_ylabel(\"f(t)\")\n\ncanvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.\ncanvas.draw()\n\n# pack_toolbar=False will make it easier to use a layout manager later on.\ntoolbar = NavigationToolbar2Tk(canvas, root, pack_toolbar=False)\ntoolbar.update()\n\ncanvas.mpl_connect(\n    \"key_press_event\", lambda event: print(f\"you pressed {event.key}\"))\ncanvas.mpl_connect(\"key_press_event\", key_press_handler)\n\nbutton_quit = tkinter.Button(master=root, text=\"Quit\", command=root.destroy)\n\n\ndef update_frequency(new_val):\n    # retrieve frequency\n    f = float(new_val)\n\n    # update data\n    y = 2 * np.sin(2 * np.pi * f * t)\n    line.set_data(t, y)\n\n    # required to update canvas and attached toolbar!\n    canvas.draw()\n\n\nslider_update = tkinter.Scale(root, from_=1, to=5, orient=tkinter.HORIZONTAL,\n                              command=update_frequency, label=\"Frequency [Hz]\")\n\n# Packing order is important. Widgets are processed sequentially and if there\n# is no space left, because the window is too small, they are not displayed.\n# The canvas is rather flexible in its size, so we pack it last which makes\n# sure the UI controls are displayed as long as possible.\nbutton_quit.pack(side=tkinter.BOTTOM)\nslider_update.pack(side=tkinter.BOTTOM)\ntoolbar.pack(side=tkinter.BOTTOM, fill=tkinter.X)\ncanvas.get_tk_widget().pack(side=tkinter.TOP, fill=tkinter.BOTH, expand=True)\n\ntkinter.mainloop()\n"
    },
    {
      "filename": "embedding_in_wx2_sgskip.py",
      "title": "Embedding In Wx2 Sgskip",
      "code": "\"\"\"\n==============\nEmbed in wx #2\n==============\n\nAn example of how to use wxagg in an application with the new\ntoolbar - comment out the add_toolbar line for no toolbar.\n\"\"\"\n\nimport wx\nimport wx.lib.mixins.inspection as WIT\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\n    NavigationToolbar2WxAgg as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2 * np.pi * t)\n\n        self.axes.plot(t, s)\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.add_toolbar()  # comment this out for no toolbar\n\n    def add_toolbar(self):\n        self.toolbar = NavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n\n\n# Alternatively you could use:\n# class App(wx.App):\nclass App(WIT.InspectableApp):\n    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        self.Init()\n        frame = CanvasFrame()\n        frame.Show(True)\n\n        return True\n\n\nif __name__ == \"__main__\":\n    app = App()\n    app.MainLoop()\n"
    },
    {
      "filename": "embedding_in_wx3_sgskip.py",
      "title": "Embedding In Wx3 Sgskip",
      "code": "\"\"\"\n==============\nEmbed in wx #3\n==============\n\nCopyright (C) 2003-2004 Andrew Straw, Jeremy O'Donoghue and others\n\nLicense: This work is licensed under the PSF. A copy should be included\nwith this source code, and is also available at\nhttps://docs.python.org/3/license.html\n\nThis is yet another example of using matplotlib with wx.  Hopefully\nthis is pretty full-featured:\n\n- both matplotlib toolbar and WX buttons manipulate plot\n- full wxApp framework, including widget interaction\n- XRC (XML wxWidgets resource) file to create GUI (made with XRCed)\n\nThis was derived from embedding_in_wx and dynamic_image_wxagg.\n\nThanks to matplotlib and wx teams for creating such great software!\n\"\"\"\n\nimport wx\nimport wx.xrc as xrc\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\n    NavigationToolbar2WxAgg as NavigationToolbar\nimport matplotlib.cbook as cbook\nimport matplotlib.cm as cm\nfrom matplotlib.figure import Figure\n\nERR_TOL = 1e-5  # floating point slop for peak-detection\n\n\nclass PlotPanel(wx.Panel):\n    def __init__(self, parent):\n        super().__init__(parent, -1)\n\n        self.fig = Figure((5, 4), 75)\n        self.canvas = FigureCanvas(self, -1, self.fig)\n        self.toolbar = NavigationToolbar(self.canvas)  # matplotlib toolbar\n        self.toolbar.Realize()\n\n        # Now put all into a sizer\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        # This way of adding to sizer allows resizing\n        sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        # Best to allow the toolbar to resize!\n        sizer.Add(self.toolbar, 0, wx.GROW)\n        self.SetSizer(sizer)\n        self.Fit()\n\n    def init_plot_data(self):\n        ax = self.fig.add_subplot()\n\n        x = np.arange(120.0) * 2 * np.pi / 60.0\n        y = np.arange(100.0) * 2 * np.pi / 50.0\n        self.x, self.y = np.meshgrid(x, y)\n        z = np.sin(self.x) + np.cos(self.y)\n        self.im = ax.imshow(z, cmap=cm.RdBu, origin='lower')\n\n        zmax = np.max(z) - ERR_TOL\n        ymax_i, xmax_i = np.nonzero(z >= zmax)\n        if self.im.origin == 'upper':\n            ymax_i = z.shape[0] - ymax_i\n        self.lines = ax.plot(xmax_i, ymax_i, 'ko')\n\n        self.toolbar.update()  # Not sure why this is needed - ADS\n\n    def GetToolBar(self):\n        # You will need to override GetToolBar if you are using an\n        # unmanaged toolbar in your frame\n        return self.toolbar\n\n    def OnWhiz(self, event):\n        self.x += np.pi / 15\n        self.y += np.pi / 20\n        z = np.sin(self.x) + np.cos(self.y)\n        self.im.set_array(z)\n\n        zmax = np.max(z) - ERR_TOL\n        ymax_i, xmax_i = np.nonzero(z >= zmax)\n        if self.im.origin == 'upper':\n            ymax_i = z.shape[0] - ymax_i\n        self.lines[0].set_data(xmax_i, ymax_i)\n\n        self.canvas.draw()\n\n\nclass MyApp(wx.App):\n    def OnInit(self):\n        xrcfile = cbook.get_sample_data('embedding_in_wx3.xrc',\n                                        asfileobj=False)\n        print('loading', xrcfile)\n\n        self.res = xrc.XmlResource(xrcfile)\n\n        # main frame and panel ---------\n\n        self.frame = self.res.LoadFrame(None, \"MainFrame\")\n        self.panel = xrc.XRCCTRL(self.frame, \"MainPanel\")\n\n        # matplotlib panel -------------\n\n        # container for matplotlib panel (I like to make a container\n        # panel for our panel so I know where it'll go when in XRCed.)\n        plot_container = xrc.XRCCTRL(self.frame, \"plot_container_panel\")\n        sizer = wx.BoxSizer(wx.VERTICAL)\n\n        # matplotlib panel itself\n        self.plotpanel = PlotPanel(plot_container)\n        self.plotpanel.init_plot_data()\n\n        # wx boilerplate\n        sizer.Add(self.plotpanel, 1, wx.EXPAND)\n        plot_container.SetSizer(sizer)\n\n        # whiz button ------------------\n        whiz_button = xrc.XRCCTRL(self.frame, \"whiz_button\")\n        whiz_button.Bind(wx.EVT_BUTTON, self.plotpanel.OnWhiz)\n\n        # bang button ------------------\n        bang_button = xrc.XRCCTRL(self.frame, \"bang_button\")\n        bang_button.Bind(wx.EVT_BUTTON, self.OnBang)\n\n        # final setup ------------------\n        self.frame.Show()\n\n        self.SetTopWindow(self.frame)\n\n        return True\n\n    def OnBang(self, event):\n        bang_count = xrc.XRCCTRL(self.frame, \"bang_count\")\n        bangs = bang_count.GetValue()\n        bangs = int(bangs) + 1\n        bang_count.SetValue(str(bangs))\n\n\nif __name__ == '__main__':\n    app = MyApp()\n    app.MainLoop()\n"
    },
    {
      "filename": "embedding_in_wx4_sgskip.py",
      "title": "Embedding In Wx4 Sgskip",
      "code": "\"\"\"\n==============\nEmbed in wx #4\n==============\n\nAn example of how to use wxagg in a wx application with a custom toolbar.\n\"\"\"\n\nimport wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\n    NavigationToolbar2WxAgg as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n\nclass MyNavigationToolbar(NavigationToolbar):\n    \"\"\"Extend the default wx toolbar with your own event handlers.\"\"\"\n\n    def __init__(self, canvas):\n        super().__init__(canvas)\n        # We use a stock wx bitmap, but you could also use your own image file.\n        bmp = wx.ArtProvider.GetBitmap(wx.ART_CROSS_MARK, wx.ART_TOOLBAR)\n        tool = self.AddTool(wx.ID_ANY, 'Click me', bmp,\n                            'Activate custom control')\n        self.Bind(wx.EVT_TOOL, self._on_custom, id=tool.GetId())\n\n    def _on_custom(self, event):\n        # add some text to the Axes in a random location in axes coords with a\n        # random color\n        ax = self.canvas.figure.axes[0]\n        x, y = np.random.rand(2)  # generate a random location\n        rgb = np.random.rand(3)  # generate a random color\n        ax.text(x, y, 'You clicked me', transform=ax.transAxes, color=rgb)\n        self.canvas.draw()\n        event.Skip()\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure(figsize=(5, 4), dpi=100)\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2 * np.pi * t)\n\n        self.axes.plot(t, s)\n\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)\n\n        self.toolbar = MyNavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n\nclass App(wx.App):\n    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        frame = CanvasFrame()\n        frame.Show(True)\n        return True\n\n\nif __name__ == \"__main__\":\n    app = App()\n    app.MainLoop()\n"
    },
    {
      "filename": "embedding_in_wx5_sgskip.py",
      "title": "Embedding In Wx5 Sgskip",
      "code": "\"\"\"\n==============\nEmbed in wx #5\n==============\n\n\"\"\"\n\nimport wx\nimport wx.lib.agw.aui as aui\nimport wx.lib.mixins.inspection as wit\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\n    NavigationToolbar2WxAgg as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n\nclass Plot(wx.Panel):\n    def __init__(self, parent, id=-1, dpi=None, **kwargs):\n        super().__init__(parent, id=id, **kwargs)\n        self.figure = Figure(dpi=dpi, figsize=(2, 2))\n        self.canvas = FigureCanvas(self, -1, self.figure)\n        self.toolbar = NavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.canvas, 1, wx.EXPAND)\n        sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.SetSizer(sizer)\n\n\nclass PlotNotebook(wx.Panel):\n    def __init__(self, parent, id=-1):\n        super().__init__(parent, id=id)\n        self.nb = aui.AuiNotebook(self)\n        sizer = wx.BoxSizer()\n        sizer.Add(self.nb, 1, wx.EXPAND)\n        self.SetSizer(sizer)\n\n    def add(self, name=\"plot\"):\n        page = Plot(self.nb)\n        self.nb.AddPage(page, name)\n        return page.figure\n\n\ndef demo():\n    # Alternatively you could use:\n    # app = wx.App()\n    # InspectableApp is a great debug tool, see:\n    # http://wiki.wxpython.org/Widget%20Inspection%20Tool\n    app = wit.InspectableApp()\n    frame = wx.Frame(None, -1, 'Plotter')\n    plotter = PlotNotebook(frame)\n    axes1 = plotter.add('figure 1').add_subplot()\n    axes1.plot([1, 2, 3], [2, 1, 4])\n    axes2 = plotter.add('figure 2').add_subplot()\n    axes2.plot([1, 2, 3, 4, 5], [2, 1, 4, 2, 3])\n    frame.Show()\n    app.MainLoop()\n\nif __name__ == \"__main__\":\n    demo()\n"
    },
    {
      "filename": "embedding_webagg_sgskip.py",
      "title": "Embedding Webagg Sgskip",
      "code": "\"\"\"\n================\nEmbedding WebAgg\n================\n\nThis example demonstrates how to embed Matplotlib WebAgg interactive plotting\nin your own web application and framework.  It is not necessary to do all this\nif you merely want to display a plot in a browser or use Matplotlib's built-in\nTornado-based server \"on the side\".\n\nThe framework being used must support web sockets.\n\"\"\"\n\nimport argparse\nimport io\nimport json\nimport mimetypes\nfrom pathlib import Path\nimport signal\nimport socket\n\ntry:\n    import tornado\nexcept ImportError as err:\n    raise RuntimeError(\"This example requires tornado.\") from err\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.web\nimport tornado.websocket\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib.backends.backend_webagg import (\n    FigureManagerWebAgg, new_figure_manager_given_figure)\nfrom matplotlib.figure import Figure\n\n\ndef create_figure():\n    \"\"\"\n    Creates a simple example figure.\n    \"\"\"\n    fig = Figure()\n    ax = fig.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2 * np.pi * t)\n    ax.plot(t, s)\n    return fig\n\n\n# The following is the content of the web page.  You would normally\n# generate this using some sort of template facility in your web\n# framework, but here we just use Python string formatting.\nhtml_content = \"\"\"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <!-- TODO: There should be a way to include all of the required javascript\n               and CSS so matplotlib can add to the set in the future if it\n               needs to. -->\n    <link rel=\"stylesheet\" href=\"_static/css/page.css\" type=\"text/css\">\n    <link rel=\"stylesheet\" href=\"_static/css/boilerplate.css\" type=\"text/css\">\n    <link rel=\"stylesheet\" href=\"_static/css/fbm.css\" type=\"text/css\">\n    <link rel=\"stylesheet\" href=\"_static/css/mpl.css\" type=\"text/css\">\n    <script src=\"mpl.js\"></script>\n\n    <script>\n      /* This is a callback that is called when the user saves\n         (downloads) a file.  Its purpose is really to map from a\n         figure and file format to a url in the application. */\n      function ondownload(figure, format) {\n        window.open('download.' + format, '_blank');\n      };\n\n      function ready(fn) {\n        if (document.readyState != \"loading\") {\n          fn();\n        } else {\n          document.addEventListener(\"DOMContentLoaded\", fn);\n        }\n      }\n\n      ready(\n        function() {\n          /* It is up to the application to provide a websocket that the figure\n             will use to communicate to the server.  This websocket object can\n             also be a \"fake\" websocket that underneath multiplexes messages\n             from multiple figures, if necessary. */\n          var websocket_type = mpl.get_websocket_type();\n          var websocket = new websocket_type(\"%(ws_uri)sws\");\n\n          // mpl.figure creates a new figure on the webpage.\n          var fig = new mpl.figure(\n              // A unique numeric identifier for the figure\n              %(fig_id)s,\n              // A websocket object (or something that behaves like one)\n              websocket,\n              // A function called when a file type is selected for download\n              ondownload,\n              // The HTML element in which to place the figure\n              document.getElementById(\"figure\"));\n        }\n      );\n    </script>\n\n    <title>matplotlib</title>\n  </head>\n\n  <body>\n    <div id=\"figure\">\n    </div>\n  </body>\n</html>\n\"\"\"\n\n\nclass MyApplication(tornado.web.Application):\n    class MainPage(tornado.web.RequestHandler):\n        \"\"\"\n        Serves the main HTML page.\n        \"\"\"\n\n        def get(self):\n            manager = self.application.manager\n            ws_uri = f\"ws://{self.request.host}/\"\n            content = html_content % {\n                \"ws_uri\": ws_uri, \"fig_id\": manager.num}\n            self.write(content)\n\n    class MplJs(tornado.web.RequestHandler):\n        \"\"\"\n        Serves the generated matplotlib javascript file.  The content\n        is dynamically generated based on which toolbar functions the\n        user has defined.  Call `FigureManagerWebAgg` to get its\n        content.\n        \"\"\"\n\n        def get(self):\n            self.set_header('Content-Type', 'application/javascript')\n            js_content = FigureManagerWebAgg.get_javascript()\n\n            self.write(js_content)\n\n    class Download(tornado.web.RequestHandler):\n        \"\"\"\n        Handles downloading of the figure in various file formats.\n        \"\"\"\n\n        def get(self, fmt):\n            manager = self.application.manager\n            self.set_header(\n                'Content-Type', mimetypes.types_map.get(fmt, 'binary'))\n            buff = io.BytesIO()\n            manager.canvas.figure.savefig(buff, format=fmt)\n            self.write(buff.getvalue())\n\n    class WebSocket(tornado.websocket.WebSocketHandler):\n        \"\"\"\n        A websocket for interactive communication between the plot in\n        the browser and the server.\n\n        In addition to the methods required by tornado, it is required to\n        have two callback methods:\n\n            - ``send_json(json_content)`` is called by matplotlib when\n              it needs to send json to the browser.  `json_content` is\n              a JSON tree (Python dictionary), and it is the responsibility\n              of this implementation to encode it as a string to send over\n              the socket.\n\n            - ``send_binary(blob)`` is called to send binary image data\n              to the browser.\n        \"\"\"\n        supports_binary = True\n\n        def open(self):\n            # Register the websocket with the FigureManager.\n            manager = self.application.manager\n            manager.add_web_socket(self)\n            if hasattr(self, 'set_nodelay'):\n                self.set_nodelay(True)\n\n        def on_close(self):\n            # When the socket is closed, deregister the websocket with\n            # the FigureManager.\n            manager = self.application.manager\n            manager.remove_web_socket(self)\n\n        def on_message(self, message):\n            # The 'supports_binary' message is relevant to the\n            # websocket itself.  The other messages get passed along\n            # to matplotlib as-is.\n\n            # Every message has a \"type\" and a \"figure_id\".\n            message = json.loads(message)\n            if message['type'] == 'supports_binary':\n                self.supports_binary = message['value']\n            else:\n                manager = self.application.manager\n                manager.handle_json(message)\n\n        def send_json(self, content):\n            self.write_message(json.dumps(content))\n\n        def send_binary(self, blob):\n            if self.supports_binary:\n                self.write_message(blob, binary=True)\n            else:\n                data_uri = (\"data:image/png;base64,\" +\n                            blob.encode('base64').replace('\\n', ''))\n                self.write_message(data_uri)\n\n    def __init__(self, figure):\n        self.figure = figure\n        self.manager = new_figure_manager_given_figure(id(figure), figure)\n\n        super().__init__([\n            # Static files for the CSS and JS\n            (r'/_static/(.*)',\n             tornado.web.StaticFileHandler,\n             {'path': FigureManagerWebAgg.get_static_file_path()}),\n\n            # Static images for the toolbar\n            (r'/_images/(.*)',\n             tornado.web.StaticFileHandler,\n             {'path': Path(mpl.get_data_path(), 'images')}),\n\n            # The page that contains all of the pieces\n            ('/', self.MainPage),\n\n            ('/mpl.js', self.MplJs),\n\n            # Sends images and events to the browser, and receives\n            # events from the browser\n            ('/ws', self.WebSocket),\n\n            # Handles the downloading (i.e., saving) of static images\n            (r'/download.([a-z0-9.]+)', self.Download),\n        ])\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-p', '--port', type=int, default=8080,\n                        help='Port to listen on (0 for a random port).')\n    args = parser.parse_args()\n\n    figure = create_figure()\n    application = MyApplication(figure)\n\n    http_server = tornado.httpserver.HTTPServer(application)\n    sockets = tornado.netutil.bind_sockets(args.port, '')\n    http_server.add_sockets(sockets)\n\n    for s in sockets:\n        addr, port = s.getsockname()[:2]\n        if s.family is socket.AF_INET6:\n            addr = f'[{addr}]'\n        print(f\"Listening on http://{addr}:{port}/\")\n    print(\"Press Ctrl+C to quit\")\n\n    ioloop = tornado.ioloop.IOLoop.instance()\n\n    def shutdown():\n        ioloop.stop()\n        print(\"Server stopped\")\n\n    old_handler = signal.signal(\n        signal.SIGINT,\n        lambda sig, frame: ioloop.add_callback_from_signal(shutdown))\n\n    try:\n        ioloop.start()\n    finally:\n        signal.signal(signal.SIGINT, old_handler)\n"
    },
    {
      "filename": "fourier_demo_wx_sgskip.py",
      "title": "Fourier Demo Wx Sgskip",
      "code": "\"\"\"\n===============\nFourier Demo WX\n===============\n\n\"\"\"\n\nimport wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass Knob:\n    \"\"\"\n    Knob - simple class with a \"setKnob\" method.\n    A Knob instance is attached to a Param instance, e.g., param.attach(knob)\n    Base class is for documentation purposes.\n    \"\"\"\n\n    def setKnob(self, value):\n        pass\n\n\nclass Param:\n    \"\"\"\n    The idea of the \"Param\" class is that some parameter in the GUI may have\n    several knobs that both control it and reflect the parameter's state, e.g.\n    a slider, text, and dragging can all change the value of the frequency in\n    the waveform of this example.\n    The class allows a cleaner way to update/\"feedback\" to the other knobs when\n    one is being changed.  Also, this class handles min/max constraints for all\n    the knobs.\n    Idea - knob list - in \"set\" method, knob object is passed as well\n      - the other knobs in the knob list have a \"set\" method which gets\n        called for the others.\n    \"\"\"\n\n    def __init__(self, initialValue=None, minimum=0., maximum=1.):\n        self.minimum = minimum\n        self.maximum = maximum\n        if initialValue != self.constrain(initialValue):\n            raise ValueError('illegal initial value')\n        self.value = initialValue\n        self.knobs = []\n\n    def attach(self, knob):\n        self.knobs += [knob]\n\n    def set(self, value, knob=None):\n        self.value = value\n        self.value = self.constrain(value)\n        for feedbackKnob in self.knobs:\n            if feedbackKnob != knob:\n                feedbackKnob.setKnob(self.value)\n        return self.value\n\n    def constrain(self, value):\n        if value <= self.minimum:\n            value = self.minimum\n        if value >= self.maximum:\n            value = self.maximum\n        return value\n\n\nclass SliderGroup(Knob):\n    def __init__(self, parent, label, param):\n        self.sliderLabel = wx.StaticText(parent, label=label)\n        self.sliderText = wx.TextCtrl(parent, -1, style=wx.TE_PROCESS_ENTER)\n        self.slider = wx.Slider(parent, -1)\n        # self.slider.SetMax(param.maximum*1000)\n        self.slider.SetRange(0, int(param.maximum * 1000))\n        self.setKnob(param.value)\n\n        sizer = wx.BoxSizer(wx.HORIZONTAL)\n        sizer.Add(self.sliderLabel, 0,\n                  wx.EXPAND | wx.ALL,\n                  border=2)\n        sizer.Add(self.sliderText, 0,\n                  wx.EXPAND | wx.ALL,\n                  border=2)\n        sizer.Add(self.slider, 1, wx.EXPAND)\n        self.sizer = sizer\n\n        self.slider.Bind(wx.EVT_SLIDER, self.sliderHandler)\n        self.sliderText.Bind(wx.EVT_TEXT_ENTER, self.sliderTextHandler)\n\n        self.param = param\n        self.param.attach(self)\n\n    def sliderHandler(self, event):\n        value = event.GetInt() / 1000.\n        self.param.set(value)\n\n    def sliderTextHandler(self, event):\n        value = float(self.sliderText.GetValue())\n        self.param.set(value)\n\n    def setKnob(self, value):\n        self.sliderText.SetValue(f'{value:g}')\n        self.slider.SetValue(int(value * 1000))\n\n\nclass FourierDemoFrame(wx.Frame):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        panel = wx.Panel(self)\n\n        # create the GUI elements\n        self.createCanvas(panel)\n        self.createSliders(panel)\n\n        # place them in a sizer for the Layout\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.canvas, 1, wx.EXPAND)\n        sizer.Add(self.frequencySliderGroup.sizer, 0,\n                  wx.EXPAND | wx.ALL, border=5)\n        sizer.Add(self.amplitudeSliderGroup.sizer, 0,\n                  wx.EXPAND | wx.ALL, border=5)\n        panel.SetSizer(sizer)\n\n    def createCanvas(self, parent):\n        self.lines = []\n        self.figure = Figure()\n        self.canvas = FigureCanvas(parent, -1, self.figure)\n        self.canvas.callbacks.connect('button_press_event', self.mouseDown)\n        self.canvas.callbacks.connect('motion_notify_event', self.mouseMotion)\n        self.canvas.callbacks.connect('button_release_event', self.mouseUp)\n        self.state = ''\n        self.mouseInfo = (None, None, None, None)\n        self.f0 = Param(2., minimum=0., maximum=6.)\n        self.A = Param(1., minimum=0.01, maximum=2.)\n        self.createPlots()\n\n        # Not sure I like having two params attached to the same Knob,\n        # but that is what we have here... it works but feels kludgy -\n        # although maybe it's not too bad since the knob changes both params\n        # at the same time (both f0 and A are affected during a drag)\n        self.f0.attach(self)\n        self.A.attach(self)\n\n    def createSliders(self, panel):\n        self.frequencySliderGroup = SliderGroup(\n            panel,\n            label='Frequency f0:',\n            param=self.f0)\n        self.amplitudeSliderGroup = SliderGroup(panel, label=' Amplitude a:',\n                                                param=self.A)\n\n    def mouseDown(self, event):\n        if self.lines[0].contains(event)[0]:\n            self.state = 'frequency'\n        elif self.lines[1].contains(event)[0]:\n            self.state = 'time'\n        else:\n            self.state = ''\n        self.mouseInfo = (event.xdata, event.ydata,\n                          max(self.f0.value, .1),\n                          self.A.value)\n\n    def mouseMotion(self, event):\n        if self.state == '':\n            return\n        x, y = event.xdata, event.ydata\n        if x is None:  # outside the Axes\n            return\n        x0, y0, f0Init, AInit = self.mouseInfo\n        self.A.set(AInit + (AInit * (y - y0) / y0), self)\n        if self.state == 'frequency':\n            self.f0.set(f0Init + (f0Init * (x - x0) / x0))\n        elif self.state == 'time':\n            if (x - x0) / x0 != -1.:\n                self.f0.set(1. / (1. / f0Init + (1. / f0Init * (x - x0) / x0)))\n\n    def mouseUp(self, event):\n        self.state = ''\n\n    def createPlots(self):\n        # This method creates the subplots, waveforms and labels.\n        # Later, when the waveforms or sliders are dragged, only the\n        # waveform data will be updated (not here, but below in setKnob).\n        self.subplot1, self.subplot2 = self.figure.subplots(2)\n        x1, y1, x2, y2 = self.compute(self.f0.value, self.A.value)\n        color = (1., 0., 0.)\n        self.lines += self.subplot1.plot(x1, y1, color=color, linewidth=2)\n        self.lines += self.subplot2.plot(x2, y2, color=color, linewidth=2)\n        # Set some plot attributes\n        self.subplot1.set_title(\n            \"Click and drag waveforms to change frequency and amplitude\",\n            fontsize=12)\n        self.subplot1.set_ylabel(\"Frequency Domain Waveform X(f)\", fontsize=8)\n        self.subplot1.set_xlabel(\"frequency f\", fontsize=8)\n        self.subplot2.set_ylabel(\"Time Domain Waveform x(t)\", fontsize=8)\n        self.subplot2.set_xlabel(\"time t\", fontsize=8)\n        self.subplot1.set_xlim([-6, 6])\n        self.subplot1.set_ylim([0, 1])\n        self.subplot2.set_xlim([-2, 2])\n        self.subplot2.set_ylim([-2, 2])\n        self.subplot1.text(0.05, .95,\n                           r'$X(f) = \\mathcal{F}\\{x(t)\\}$',\n                           verticalalignment='top',\n                           transform=self.subplot1.transAxes)\n        self.subplot2.text(0.05, .95,\n                           r'$x(t) = a \\cdot \\cos(2\\pi f_0 t) e^{-\\pi t^2}$',\n                           verticalalignment='top',\n                           transform=self.subplot2.transAxes)\n\n    def compute(self, f0, A):\n        f = np.arange(-6., 6., 0.02)\n        t = np.arange(-2., 2., 0.01)\n        x = A * np.cos(2 * np.pi * f0 * t) * np.exp(-np.pi * t ** 2)\n        X = A / 2 * \\\n            (np.exp(-np.pi * (f - f0) ** 2) + np.exp(-np.pi * (f + f0) ** 2))\n        return f, X, t, x\n\n    def setKnob(self, value):\n        # Note, we ignore value arg here and just go by state of the params\n        x1, y1, x2, y2 = self.compute(self.f0.value, self.A.value)\n        # update the data of the two waveforms\n        self.lines[0].set(xdata=x1, ydata=y1)\n        self.lines[1].set(xdata=x2, ydata=y2)\n        # make the canvas draw its contents again with the new data\n        self.canvas.draw()\n\n\nclass App(wx.App):\n    def OnInit(self):\n        self.frame1 = FourierDemoFrame(parent=None, title=\"Fourier Demo\",\n                                       size=(640, 480))\n        self.frame1.Show()\n        return True\n\n\nif __name__ == \"__main__\":\n    app = App()\n    app.MainLoop()\n"
    },
    {
      "filename": "gtk3_spreadsheet_sgskip.py",
      "title": "Gtk3 Spreadsheet Sgskip",
      "code": "\"\"\"\n================\nGTK3 spreadsheet\n================\n\nExample of embedding Matplotlib in an application and interacting with a\ntreeview to store data.  Double-click on an entry to update plot data.\n\"\"\"\n\nimport gi\n\ngi.require_version('Gtk', '3.0')\ngi.require_version('Gdk', '3.0')\nfrom gi.repository import Gdk, Gtk\n\nfrom numpy.random import random\n\nfrom matplotlib.backends.backend_gtk3agg import FigureCanvas  # or gtk3cairo.\nfrom matplotlib.figure import Figure\n\n\nclass DataManager(Gtk.Window):\n    num_rows, num_cols = 20, 10\n\n    data = random((num_rows, num_cols))\n\n    def __init__(self):\n        super().__init__()\n        self.set_default_size(600, 600)\n        self.connect('destroy', lambda win: Gtk.main_quit())\n\n        self.set_title('GtkListStore demo')\n        self.set_border_width(8)\n\n        vbox = Gtk.VBox(homogeneous=False, spacing=8)\n        self.add(vbox)\n\n        label = Gtk.Label(label='Double click a row to plot the data')\n\n        vbox.pack_start(label, False, False, 0)\n\n        sw = Gtk.ScrolledWindow()\n        sw.set_shadow_type(Gtk.ShadowType.ETCHED_IN)\n        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)\n        vbox.pack_start(sw, True, True, 0)\n\n        model = self.create_model()\n\n        self.treeview = Gtk.TreeView(model=model)\n\n        # Matplotlib stuff\n        fig = Figure(figsize=(6, 4))\n\n        self.canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n        vbox.pack_start(self.canvas, True, True, 0)\n        ax = fig.add_subplot()\n        self.line, = ax.plot(self.data[0, :], 'go')  # plot the first row\n\n        self.treeview.connect('row-activated', self.plot_row)\n        sw.add(self.treeview)\n\n        self.add_columns()\n\n        self.add_events(Gdk.EventMask.BUTTON_PRESS_MASK |\n                        Gdk.EventMask.KEY_PRESS_MASK |\n                        Gdk.EventMask.KEY_RELEASE_MASK)\n\n    def plot_row(self, treeview, path, view_column):\n        ind, = path  # get the index into data\n        points = self.data[ind, :]\n        self.line.set_ydata(points)\n        self.canvas.draw()\n\n    def add_columns(self):\n        for i in range(self.num_cols):\n            column = Gtk.TreeViewColumn(str(i), Gtk.CellRendererText(), text=i)\n            self.treeview.append_column(column)\n\n    def create_model(self):\n        types = [float] * self.num_cols\n        store = Gtk.ListStore(*types)\n        for row in self.data:\n            store.append(tuple(row))\n        return store\n\n\nmanager = DataManager()\nmanager.show_all()\nGtk.main()\n"
    },
    {
      "filename": "gtk4_spreadsheet_sgskip.py",
      "title": "Gtk4 Spreadsheet Sgskip",
      "code": "\"\"\"\n================\nGTK4 spreadsheet\n================\n\nExample of embedding Matplotlib in an application and interacting with a\ntreeview to store data.  Double-click on an entry to update plot data.\n\"\"\"\n\nimport gi\n\ngi.require_version('Gtk', '4.0')\ngi.require_version('Gdk', '4.0')\nfrom gi.repository import Gtk\n\nfrom numpy.random import random\n\nfrom matplotlib.backends.backend_gtk4agg import FigureCanvas  # or gtk4cairo.\nfrom matplotlib.figure import Figure\n\n\nclass DataManager(Gtk.ApplicationWindow):\n    num_rows, num_cols = 20, 10\n\n    data = random((num_rows, num_cols))\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_default_size(600, 600)\n\n        self.set_title('GtkListStore demo')\n\n        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, homogeneous=False,\n                       spacing=8)\n        self.set_child(vbox)\n\n        label = Gtk.Label(label='Double click a row to plot the data')\n        vbox.append(label)\n\n        sw = Gtk.ScrolledWindow()\n        sw.set_has_frame(True)\n        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)\n        sw.set_hexpand(True)\n        sw.set_vexpand(True)\n        vbox.append(sw)\n\n        model = self.create_model()\n        self.treeview = Gtk.TreeView(model=model)\n        self.treeview.connect('row-activated', self.plot_row)\n        sw.set_child(self.treeview)\n\n        # Matplotlib stuff\n        fig = Figure(figsize=(6, 4), layout='constrained')\n\n        self.canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n        self.canvas.set_hexpand(True)\n        self.canvas.set_vexpand(True)\n        vbox.append(self.canvas)\n        ax = fig.add_subplot()\n        self.line, = ax.plot(self.data[0, :], 'go')  # plot the first row\n\n        self.add_columns()\n\n    def plot_row(self, treeview, path, view_column):\n        ind, = path  # get the index into data\n        points = self.data[ind, :]\n        self.line.set_ydata(points)\n        self.canvas.draw()\n\n    def add_columns(self):\n        for i in range(self.num_cols):\n            column = Gtk.TreeViewColumn(str(i), Gtk.CellRendererText(), text=i)\n            self.treeview.append_column(column)\n\n    def create_model(self):\n        types = [float] * self.num_cols\n        store = Gtk.ListStore(*types)\n        for row in self.data:\n            # Gtk.ListStore.append is broken in PyGObject, so insert manually.\n            it = store.insert(-1)\n            store.set(it, {i: val for i, val in enumerate(row)})\n        return store\n\n\ndef on_activate(app):\n    manager = DataManager(application=app)\n    manager.show()\n\n\napp = Gtk.Application(application_id='org.matplotlib.examples.GTK4Spreadsheet')\napp.connect('activate', on_activate)\napp.run()\n"
    },
    {
      "filename": "mathtext_wx_sgskip.py",
      "title": "Mathtext Wx Sgskip",
      "code": "\"\"\"\n======================\nDisplay mathtext in WX\n======================\n\nDemonstrates how to convert (math)text to a wx.Bitmap for display in various\ncontrols on wxPython.\n\"\"\"\n\nfrom io import BytesIO\n\nimport wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wx import NavigationToolbar2Wx\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nIS_WIN = 'wxMSW' in wx.PlatformInfo\n\n\ndef mathtext_to_wxbitmap(s):\n    # We draw the text at position (0, 0) but then rely on\n    # ``facecolor=\"none\"`` and ``bbox_inches=\"tight\", pad_inches=0`` to get a\n    # transparent mask that is then loaded into a wx.Bitmap.\n    fig = Figure(facecolor=\"none\")\n    text_color = (\n        np.array(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)) / 255)\n    fig.text(0, 0, s, fontsize=10, color=text_color)\n    buf = BytesIO()\n    fig.savefig(buf, format=\"png\", dpi=150, bbox_inches=\"tight\", pad_inches=0)\n    s = buf.getvalue()\n    return wx.Bitmap.NewFromPNGData(s, len(s))\n\n\nfunctions = [\n    (r'$\\sin(2 \\pi x)$', lambda x: np.sin(2*np.pi*x)),\n    (r'$\\frac{4}{3}\\pi x^3$', lambda x: (4/3)*np.pi*x**3),\n    (r'$\\cos(2 \\pi x)$', lambda x: np.cos(2*np.pi*x)),\n    (r'$\\log(x)$', lambda x: np.log(x))\n]\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self, parent, title):\n        super().__init__(parent, -1, title, size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.change_plot(0)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.add_buttonbar()\n        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        self.add_toolbar()  # comment this out for no toolbar\n\n        menuBar = wx.MenuBar()\n\n        # File Menu\n        menu = wx.Menu()\n        m_exit = menu.Append(\n            wx.ID_EXIT, \"E&xit\\tAlt-X\", \"Exit this simple sample\")\n        menuBar.Append(menu, \"&File\")\n        self.Bind(wx.EVT_MENU, self.OnClose, m_exit)\n\n        if IS_WIN:\n            # Equation Menu\n            menu = wx.Menu()\n            for i, (mt, func) in enumerate(functions):\n                bm = mathtext_to_wxbitmap(mt)\n                item = wx.MenuItem(menu, 1000 + i, \" \")\n                item.SetBitmap(bm)\n                menu.Append(item)\n                self.Bind(wx.EVT_MENU, self.OnChangePlot, item)\n            menuBar.Append(menu, \"&Functions\")\n\n        self.SetMenuBar(menuBar)\n\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n    def add_buttonbar(self):\n        self.button_bar = wx.Panel(self)\n        self.button_bar_sizer = wx.BoxSizer(wx.HORIZONTAL)\n        self.sizer.Add(self.button_bar, 0, wx.LEFT | wx.TOP | wx.GROW)\n\n        for i, (mt, func) in enumerate(functions):\n            bm = mathtext_to_wxbitmap(mt)\n            button = wx.BitmapButton(self.button_bar, 1000 + i, bm)\n            self.button_bar_sizer.Add(button, 1, wx.GROW)\n            self.Bind(wx.EVT_BUTTON, self.OnChangePlot, button)\n\n        self.button_bar.SetSizer(self.button_bar_sizer)\n\n    def add_toolbar(self):\n        \"\"\"Copied verbatim from embedding_wx2.py\"\"\"\n        self.toolbar = NavigationToolbar2Wx(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n\n    def OnChangePlot(self, event):\n        self.change_plot(event.GetId() - 1000)\n\n    def change_plot(self, plot_number):\n        t = np.arange(1.0, 3.0, 0.01)\n        s = functions[plot_number][1](t)\n        self.axes.clear()\n        self.axes.plot(t, s)\n        self.canvas.draw()\n\n    def OnClose(self, event):\n        self.Destroy()\n\n\nclass MyApp(wx.App):\n    def OnInit(self):\n        frame = CanvasFrame(None, \"wxPython mathtext demo app\")\n        self.SetTopWindow(frame)\n        frame.Show(True)\n        return True\n\n\nif __name__ == \"__main__\":\n    app = MyApp()\n    app.MainLoop()\n"
    },
    {
      "filename": "mpl_with_glade3_sgskip.py",
      "title": "Mpl With Glade3 Sgskip",
      "code": "\"\"\"\n=======================\nMatplotlib with Glade 3\n=======================\n\"\"\"\n\nfrom pathlib import Path\n\nimport gi\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3agg import \\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass Window1Signals:\n    def on_window1_destroy(self, widget):\n        Gtk.main_quit()\n\n\ndef main():\n    builder = Gtk.Builder()\n    builder.add_objects_from_file(\n        str(Path(__file__).parent / \"mpl_with_glade3.glade\"),\n        (\"window1\", \"\"))\n    builder.connect_signals(Window1Signals())\n    window = builder.get_object(\"window1\")\n    sw = builder.get_object(\"scrolledwindow1\")\n\n    # Start of Matplotlib specific code\n    figure = Figure(figsize=(8, 6), dpi=71)\n    axis = figure.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    axis.plot(t, s)\n\n    axis.set_xlabel('time [s]')\n    axis.set_ylabel('voltage [V]')\n\n    canvas = FigureCanvas(figure)  # a Gtk.DrawingArea\n    canvas.set_size_request(800, 600)\n    sw.add(canvas)\n    # End of Matplotlib specific code\n\n    window.show_all()\n    Gtk.main()\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "filename": "mplcvd.py",
      "title": "Mplcvd",
      "code": "\"\"\"\nmplcvd -- an example of figure hook\n===================================\n\nTo use this hook, ensure that this module is in your ``PYTHONPATH``, and set\n``rcParams[\"figure.hooks\"] = [\"mplcvd:setup\"]``.  This hook depends on\nthe ``colorspacious`` third-party module.\n\"\"\"\n\nimport functools\nfrom pathlib import Path\n\nimport colorspacious\n\nimport numpy as np\n\n_BUTTON_NAME = \"Filter\"\n_BUTTON_HELP = \"Simulate color vision deficiencies\"\n_MENU_ENTRIES = {\n    \"None\": None,\n    \"Greyscale\": \"greyscale\",\n    \"Deuteranopia\": \"deuteranomaly\",\n    \"Protanopia\": \"protanomaly\",\n    \"Tritanopia\": \"tritanomaly\",\n}\n\n\ndef _get_color_filter(name):\n    \"\"\"\n    Given a color filter name, create a color filter function.\n\n    Parameters\n    ----------\n    name : str\n        The color filter name, one of the following:\n\n        - ``\"none\"``: ...\n        - ``\"greyscale\"``: Convert the input to luminosity.\n        - ``\"deuteranopia\"``: Simulate the most common form of red-green\n          colorblindness.\n        - ``\"protanopia\"``: Simulate a rarer form of red-green colorblindness.\n        - ``\"tritanopia\"``: Simulate the rare form of blue-yellow\n          colorblindness.\n\n        Color conversions use `colorspacious`_.\n\n    Returns\n    -------\n    callable\n        A color filter function that has the form:\n\n        def filter(input: np.ndarray[M, N, D])-> np.ndarray[M, N, D]\n\n        where (M, N) are the image dimensions, and D is the color depth (3 for\n        RGB, 4 for RGBA). Alpha is passed through unchanged and otherwise\n        ignored.\n    \"\"\"\n    if name not in _MENU_ENTRIES:\n        raise ValueError(f\"Unsupported filter name: {name!r}\")\n    name = _MENU_ENTRIES[name]\n\n    if name is None:\n        return None\n\n    elif name == \"greyscale\":\n        rgb_to_jch = colorspacious.cspace_converter(\"sRGB1\", \"JCh\")\n        jch_to_rgb = colorspacious.cspace_converter(\"JCh\", \"sRGB1\")\n\n        def convert(im):\n            greyscale_JCh = rgb_to_jch(im)\n            greyscale_JCh[..., 1] = 0\n            im = jch_to_rgb(greyscale_JCh)\n            return im\n\n    else:\n        cvd_space = {\"name\": \"sRGB1+CVD\", \"cvd_type\": name, \"severity\": 100}\n        convert = colorspacious.cspace_converter(cvd_space, \"sRGB1\")\n\n    def filter_func(im, dpi):\n        alpha = None\n        if im.shape[-1] == 4:\n            im, alpha = im[..., :3], im[..., 3]\n        im = convert(im)\n        if alpha is not None:\n            im = np.dstack((im, alpha))\n        return np.clip(im, 0, 1), 0, 0\n\n    return filter_func\n\n\ndef _set_menu_entry(tb, name):\n    tb.canvas.figure.set_agg_filter(_get_color_filter(name))\n    tb.canvas.draw_idle()\n\n\ndef setup(figure):\n    tb = figure.canvas.toolbar\n    if tb is None:\n        return\n    for cls in type(tb).__mro__:\n        pkg = cls.__module__.split(\".\")[0]\n        if pkg != \"matplotlib\":\n            break\n    if pkg == \"gi\":\n        _setup_gtk(tb)\n    elif pkg in (\"PyQt5\", \"PySide2\", \"PyQt6\", \"PySide6\"):\n        _setup_qt(tb)\n    elif pkg == \"tkinter\":\n        _setup_tk(tb)\n    elif pkg == \"wx\":\n        _setup_wx(tb)\n    else:\n        raise NotImplementedError(\"The current backend is not supported\")\n\n\ndef _setup_gtk(tb):\n    from gi.repository import Gio, GLib, Gtk\n\n    for idx in range(tb.get_n_items()):\n        children = tb.get_nth_item(idx).get_children()\n        if children and isinstance(children[0], Gtk.Label):\n            break\n\n    toolitem = Gtk.SeparatorToolItem()\n    tb.insert(toolitem, idx)\n\n    image = Gtk.Image.new_from_gicon(\n        Gio.Icon.new_for_string(\n            str(Path(__file__).parent / \"images/eye-symbolic.svg\")),\n        Gtk.IconSize.LARGE_TOOLBAR)\n\n    # The type of menu is progressively downgraded depending on GTK version.\n    if Gtk.check_version(3, 6, 0) is None:\n\n        group = Gio.SimpleActionGroup.new()\n        action = Gio.SimpleAction.new_stateful(\"cvdsim\",\n                                               GLib.VariantType(\"s\"),\n                                               GLib.Variant(\"s\", \"none\"))\n        group.add_action(action)\n\n        @functools.partial(action.connect, \"activate\")\n        def set_filter(action, parameter):\n            _set_menu_entry(tb, parameter.get_string())\n            action.set_state(parameter)\n\n        menu = Gio.Menu()\n        for name in _MENU_ENTRIES:\n            menu.append(name, f\"local.cvdsim::{name}\")\n\n        button = Gtk.MenuButton.new()\n        button.remove(button.get_children()[0])\n        button.add(image)\n        button.insert_action_group(\"local\", group)\n        button.set_menu_model(menu)\n        button.get_style_context().add_class(\"flat\")\n\n        item = Gtk.ToolItem()\n        item.add(button)\n        tb.insert(item, idx + 1)\n\n    else:\n\n        menu = Gtk.Menu()\n        group = []\n        for name in _MENU_ENTRIES:\n            item = Gtk.RadioMenuItem.new_with_label(group, name)\n            item.set_active(name == \"None\")\n            item.connect(\n                \"activate\", lambda item: _set_menu_entry(tb, item.get_label()))\n            group.append(item)\n            menu.append(item)\n        menu.show_all()\n\n        tbutton = Gtk.MenuToolButton.new(image, _BUTTON_NAME)\n        tbutton.set_menu(menu)\n        tb.insert(tbutton, idx + 1)\n\n    tb.show_all()\n\n\ndef _setup_qt(tb):\n    from matplotlib.backends.qt_compat import QtGui, QtWidgets\n\n    menu = QtWidgets.QMenu()\n    try:\n        QActionGroup = QtGui.QActionGroup  # Qt6\n    except AttributeError:\n        QActionGroup = QtWidgets.QActionGroup  # Qt5\n    group = QActionGroup(menu)\n    group.triggered.connect(lambda action: _set_menu_entry(tb, action.text()))\n\n    for name in _MENU_ENTRIES:\n        action = menu.addAction(name)\n        action.setCheckable(True)\n        action.setActionGroup(group)\n        action.setChecked(name == \"None\")\n\n    actions = tb.actions()\n    before = next(\n        (action for action in actions\n         if isinstance(tb.widgetForAction(action), QtWidgets.QLabel)), None)\n\n    tb.insertSeparator(before)\n    button = QtWidgets.QToolButton()\n    # FIXME: _icon needs public API.\n    button.setIcon(tb._icon(str(Path(__file__).parent / \"images/eye.png\")))\n    button.setText(_BUTTON_NAME)\n    button.setToolTip(_BUTTON_HELP)\n    button.setPopupMode(QtWidgets.QToolButton.ToolButtonPopupMode.InstantPopup)\n    button.setMenu(menu)\n    tb.insertWidget(before, button)\n\n\ndef _setup_tk(tb):\n    import tkinter as tk\n\n    tb._Spacer()  # FIXME: _Spacer needs public API.\n\n    button = tk.Menubutton(master=tb, relief=\"raised\")\n    button._image_file = str(Path(__file__).parent / \"images/eye.png\")\n    # FIXME: _set_image_for_button needs public API (perhaps like _icon).\n    tb._set_image_for_button(button)\n    button.pack(side=tk.LEFT)\n\n    menu = tk.Menu(master=button, tearoff=False)\n    for name in _MENU_ENTRIES:\n        menu.add(\"radiobutton\", label=name,\n                 command=lambda _name=name: _set_menu_entry(tb, _name))\n    menu.invoke(0)\n    button.config(menu=menu)\n\n\ndef _setup_wx(tb):\n    import wx\n\n    idx = next(idx for idx in range(tb.ToolsCount)\n               if tb.GetToolByPos(idx).IsStretchableSpace())\n    tb.InsertSeparator(idx)\n    tool = tb.InsertTool(\n        idx + 1, -1, _BUTTON_NAME,\n        # FIXME: _icon needs public API.\n        tb._icon(str(Path(__file__).parent / \"images/eye.png\")),\n        # FIXME: ITEM_DROPDOWN is not supported on macOS.\n        kind=wx.ITEM_DROPDOWN, shortHelp=_BUTTON_HELP)\n\n    menu = wx.Menu()\n    for name in _MENU_ENTRIES:\n        item = menu.AppendRadioItem(-1, name)\n        menu.Bind(\n            wx.EVT_MENU,\n            lambda event, _name=name: _set_menu_entry(tb, _name),\n            id=item.Id,\n        )\n    tb.SetDropdownMenu(tool.Id, menu)\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    from matplotlib import cbook\n\n    plt.rcParams['figure.hooks'].append('mplcvd:setup')\n\n    fig, axd = plt.subplot_mosaic(\n        [\n            ['viridis', 'turbo'],\n            ['photo', 'lines']\n        ]\n    )\n\n    delta = 0.025\n    x = y = np.arange(-3.0, 3.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2) * 2\n\n    imv = axd['viridis'].imshow(\n        Z, interpolation='bilinear',\n        origin='lower', extent=[-3, 3, -3, 3],\n        vmax=abs(Z).max(), vmin=-abs(Z).max()\n    )\n    fig.colorbar(imv)\n    imt = axd['turbo'].imshow(\n        Z, interpolation='bilinear', cmap='turbo',\n        origin='lower', extent=[-3, 3, -3, 3],\n        vmax=abs(Z).max(), vmin=-abs(Z).max()\n    )\n    fig.colorbar(imt)\n\n    # A sample image\n    with cbook.get_sample_data('grace_hopper.jpg') as image_file:\n        photo = plt.imread(image_file)\n    axd['photo'].imshow(photo)\n\n    th = np.linspace(0, 2*np.pi, 1024)\n    for j in [1, 2, 4, 6]:\n        axd['lines'].plot(th, np.sin(th * j), label=f'$\\\\omega={j}$')\n    axd['lines'].legend(ncols=2, loc='upper right')\n    plt.show()\n"
    },
    {
      "filename": "pylab_with_gtk3_sgskip.py",
      "title": "Pylab With Gtk3 Sgskip",
      "code": "\"\"\"\n================\npyplot with GTK3\n================\n\nAn example of how to use pyplot to manage your figure windows, but modify the\nGUI by accessing the underlying GTK widgets.\n\"\"\"\n\nimport matplotlib\n\nmatplotlib.use('GTK3Agg')  # or 'GTK3Cairo'\nimport gi\n\nimport matplotlib.pyplot as plt\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nfig, ax = plt.subplots()\nax.plot([1, 2, 3], 'ro-', label='easy as 1 2 3')\nax.plot([1, 4, 9], 'gs--', label='easy as 1 2 3 squared')\nax.legend()\n\nmanager = fig.canvas.manager\n# you can access the window or vbox attributes this way\ntoolbar = manager.toolbar\nvbox = manager.vbox\n\n# now let's add a button to the toolbar\nbutton = Gtk.Button(label='Click me')\nbutton.show()\nbutton.connect('clicked', lambda button: print('hi mom'))\n\ntoolitem = Gtk.ToolItem()\ntoolitem.show()\ntoolitem.set_tooltip_text('Click me for fun and profit')\ntoolitem.add(button)\n\npos = 8  # where to insert this in the toolbar\ntoolbar.insert(toolitem, pos)\n\n# now let's add a widget to the vbox\nlabel = Gtk.Label()\nlabel.set_markup('Drag mouse over axes for position')\nlabel.show()\nvbox.pack_start(label, False, False, 0)\nvbox.reorder_child(toolbar, -1)\n\n\ndef update(event):\n    if event.xdata is None:\n        label.set_markup('Drag mouse over axes for position')\n    else:\n        label.set_markup(\n            f'<span color=\"#ef0000\">x,y=({event.xdata}, {event.ydata})</span>')\n\n\nfig.canvas.mpl_connect('motion_notify_event', update)\n\nplt.show()\n"
    },
    {
      "filename": "pylab_with_gtk4_sgskip.py",
      "title": "Pylab With Gtk4 Sgskip",
      "code": "\"\"\"\n================\npyplot with GTK4\n================\n\nAn example of how to use pyplot to manage your figure windows, but modify the\nGUI by accessing the underlying GTK widgets.\n\"\"\"\n\nimport matplotlib\n\nmatplotlib.use('GTK4Agg')  # or 'GTK4Cairo'\nimport gi\n\nimport matplotlib.pyplot as plt\n\ngi.require_version('Gtk', '4.0')\nfrom gi.repository import Gtk\n\nfig, ax = plt.subplots()\nax.plot([1, 2, 3], 'ro-', label='easy as 1 2 3')\nax.plot([1, 4, 9], 'gs--', label='easy as 1 2 3 squared')\nax.legend()\n\nmanager = fig.canvas.manager\n# you can access the window or vbox attributes this way\ntoolbar = manager.toolbar\nvbox = manager.vbox\n\n# now let's add a button to the toolbar\nbutton = Gtk.Button(label='Click me')\nbutton.connect('clicked', lambda button: print('hi mom'))\nbutton.set_tooltip_text('Click me for fun and profit')\ntoolbar.append(button)\n\n# now let's add a widget to the vbox\nlabel = Gtk.Label()\nlabel.set_markup('Drag mouse over axes for position')\nvbox.insert_child_after(label, fig.canvas)\n\n\ndef update(event):\n    if event.xdata is None:\n        label.set_markup('Drag mouse over axes for position')\n    else:\n        label.set_markup(\n            f'<span color=\"#ef0000\">x,y=({event.xdata}, {event.ydata})</span>')\n\n\nfig.canvas.mpl_connect('motion_notify_event', update)\n\nplt.show()\n"
    },
    {
      "filename": "svg_histogram_sgskip.py",
      "title": "Svg Histogram Sgskip",
      "code": "\"\"\"\n=============\nSVG Histogram\n=============\n\nDemonstrate how to create an interactive histogram, in which bars\nare hidden or shown by clicking on legend markers.\n\nThe interactivity is encoded in ecmascript (javascript) and inserted in\nthe SVG code in a post-processing step. To render the image, open it in\na web browser. SVG is supported in most web browsers used by Linux and\nmacOS users. Windows IE9 supports SVG, but earlier versions do not.\n\nNotes\n-----\nThe matplotlib backend lets us assign ids to each object. This is the\nmechanism used here to relate matplotlib objects created in python and\nthe corresponding SVG constructs that are parsed in the second step.\nWhile flexible, ids are cumbersome to use for large collection of\nobjects. Two mechanisms could be used to simplify things:\n\n* systematic grouping of objects into SVG <g> tags,\n* assigning classes to each SVG object according to its origin.\n\nFor example, instead of modifying the properties of each individual bar,\nthe bars from the `~.pyplot.hist` function could either be grouped in\na PatchCollection, or be assigned a class=\"hist_##\" attribute.\n\nCSS could also be used more extensively to replace repetitive markup\nthroughout the generated SVG.\n\nAuthor: david.huard@gmail.com\n\n\"\"\"\n\n\nfrom io import BytesIO\nimport json\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParams['svg.fonttype'] = 'none'\n\n# Apparently, this `register_namespace` method is necessary to avoid garbling\n# the XML namespace with ns0.\nET.register_namespace(\"\", \"http://www.w3.org/2000/svg\")\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# --- Create histogram, legend and title ---\nplt.figure()\nr = np.random.randn(100)\nr1 = r + 1\nlabels = ['Rabbits', 'Frogs']\nH = plt.hist([r, r1], label=labels)\ncontainers = H[-1]\nleg = plt.legend(frameon=False)\nplt.title(\"From a web browser, click on the legend\\n\"\n          \"marker to toggle the corresponding histogram.\")\n\n\n# --- Add ids to the svg objects we'll modify\n\nhist_patches = {}\nfor ic, c in enumerate(containers):\n    hist_patches[f'hist_{ic}'] = []\n    for il, element in enumerate(c):\n        element.set_gid(f'hist_{ic}_patch_{il}')\n        hist_patches[f'hist_{ic}'].append(f'hist_{ic}_patch_{il}')\n\n# Set ids for the legend patches\nfor i, t in enumerate(leg.get_patches()):\n    t.set_gid(f'leg_patch_{i}')\n\n# Set ids for the text patches\nfor i, t in enumerate(leg.get_texts()):\n    t.set_gid(f'leg_text_{i}')\n\n# Save SVG in a fake file object.\nf = BytesIO()\nplt.savefig(f, format=\"svg\")\n\n# Create XML tree from the SVG file.\ntree, xmlid = ET.XMLID(f.getvalue())\n\n\n# --- Add interactivity ---\n\n# Add attributes to the patch objects.\nfor i, t in enumerate(leg.get_patches()):\n    el = xmlid[f'leg_patch_{i}']\n    el.set('cursor', 'pointer')\n    el.set('onclick', \"toggle_hist(this)\")\n\n# Add attributes to the text objects.\nfor i, t in enumerate(leg.get_texts()):\n    el = xmlid[f'leg_text_{i}']\n    el.set('cursor', 'pointer')\n    el.set('onclick', \"toggle_hist(this)\")\n\n# Create script defining the function `toggle_hist`.\n# We create a global variable `container` that stores the patches id\n# belonging to each histogram. Then a function \"toggle_element\" sets the\n# visibility attribute of all patches of each histogram and the opacity\n# of the marker itself.\n\nscript = \"\"\"\n<script type=\"text/ecmascript\">\n<![CDATA[\nvar container = %s\n\nfunction toggle(oid, attribute, values) {\n    /* Toggle the style attribute of an object between two values.\n\n    Parameters\n    ----------\n    oid : str\n      Object identifier.\n    attribute : str\n      Name of style attribute.\n    values : [on state, off state]\n      The two values that are switched between.\n    */\n    var obj = document.getElementById(oid);\n    var a = obj.style[attribute];\n\n    a = (a == values[0] || a == \"\") ? values[1] : values[0];\n    obj.style[attribute] = a;\n    }\n\nfunction toggle_hist(obj) {\n\n    var num = obj.id.slice(-1);\n\n    toggle('leg_patch_' + num, 'opacity', [1, 0.3]);\n    toggle('leg_text_' + num, 'opacity', [1, 0.5]);\n\n    var names = container['hist_'+num]\n\n    for (var i=0; i < names.length; i++) {\n        toggle(names[i], 'opacity', [1, 0])\n    };\n    }\n]]>\n</script>\n\"\"\" % json.dumps(hist_patches)\n\n# Add a transition effect\ncss = tree.find('.//{http://www.w3.org/2000/svg}style')\ncss.text = css.text + \"g {-webkit-transition:opacity 0.4s ease-out;\" + \\\n    \"-moz-transition:opacity 0.4s ease-out;}\"\n\n# Insert the script and save to file.\ntree.insert(0, ET.XML(script))\n\nET.ElementTree(tree).write(\"svg_histogram.svg\")\n"
    },
    {
      "filename": "svg_tooltip_sgskip.py",
      "title": "Svg Tooltip Sgskip",
      "code": "\"\"\"\n===========\nSVG Tooltip\n===========\n\nThis example shows how to create a tooltip that will show up when\nhovering over a matplotlib patch.\n\nAlthough it is possible to create the tooltip from CSS or javascript,\nhere we create it in matplotlib and simply toggle its visibility on\nwhen hovering over the patch. This approach provides total control over\nthe tooltip placement and appearance, at the expense of more code up\nfront.\n\nThe alternative approach would be to put the tooltip content in ``title``\nattributes of SVG objects. Then, using an existing js/CSS library, it\nwould be relatively straightforward to create the tooltip in the\nbrowser. The content would be dictated by the ``title`` attribute, and\nthe appearance by the CSS.\n\n\n:author: David Huard\n\"\"\"\n\n\nfrom io import BytesIO\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\n\nET.register_namespace(\"\", \"http://www.w3.org/2000/svg\")\n\nfig, ax = plt.subplots()\n\n# Create patches to which tooltips will be assigned.\nrect1 = plt.Rectangle((10, -20), 10, 5, fc='blue')\nrect2 = plt.Rectangle((-20, 15), 10, 5, fc='green')\n\nshapes = [rect1, rect2]\nlabels = ['This is a blue rectangle.', 'This is a green rectangle']\n\nfor i, (item, label) in enumerate(zip(shapes, labels)):\n    patch = ax.add_patch(item)\n    annotate = ax.annotate(labels[i], xy=item.get_xy(), xytext=(0, 0),\n                           textcoords='offset points', color='w', ha='center',\n                           fontsize=8, bbox=dict(boxstyle='round, pad=.5',\n                                                 fc=(.1, .1, .1, .92),\n                                                 ec=(1., 1., 1.), lw=1,\n                                                 zorder=1))\n\n    ax.add_patch(patch)\n    patch.set_gid(f'mypatch_{i:03d}')\n    annotate.set_gid(f'mytooltip_{i:03d}')\n\n# Save the figure in a fake file object\nax.set_xlim(-30, 30)\nax.set_ylim(-30, 30)\nax.set_aspect('equal')\n\nf = BytesIO()\nplt.savefig(f, format=\"svg\")\n\n# --- Add interactivity ---\n\n# Create XML tree from the SVG file.\ntree, xmlid = ET.XMLID(f.getvalue())\ntree.set('onload', 'init(event)')\n\nfor i in shapes:\n    # Get the index of the shape\n    index = shapes.index(i)\n    # Hide the tooltips\n    tooltip = xmlid[f'mytooltip_{index:03d}']\n    tooltip.set('visibility', 'hidden')\n    # Assign onmouseover and onmouseout callbacks to patches.\n    mypatch = xmlid[f'mypatch_{index:03d}']\n    mypatch.set('onmouseover', \"ShowTooltip(this)\")\n    mypatch.set('onmouseout', \"HideTooltip(this)\")\n\n# This is the script defining the ShowTooltip and HideTooltip functions.\nscript = \"\"\"\n    <script type=\"text/ecmascript\">\n    <![CDATA[\n\n    function init(event) {\n        if ( window.svgDocument == null ) {\n            svgDocument = event.target.ownerDocument;\n            }\n        }\n\n    function ShowTooltip(obj) {\n        var cur = obj.id.split(\"_\")[1];\n        var tip = svgDocument.getElementById('mytooltip_' + cur);\n        tip.setAttribute('visibility', \"visible\")\n        }\n\n    function HideTooltip(obj) {\n        var cur = obj.id.split(\"_\")[1];\n        var tip = svgDocument.getElementById('mytooltip_' + cur);\n        tip.setAttribute('visibility', \"hidden\")\n        }\n\n    ]]>\n    </script>\n    \"\"\"\n\n# Insert the script at the top of the file and save it.\ntree.insert(0, ET.XML(script))\nET.ElementTree(tree).write('svg_tooltip.svg')\n"
    },
    {
      "filename": "toolmanager_sgskip.py",
      "title": "Toolmanager Sgskip",
      "code": "\"\"\"\n============\nTool Manager\n============\n\nThis example demonstrates how to\n\n* modify the Toolbar\n* create tools\n* add tools\n* remove tools\n\nusing `matplotlib.backend_managers.ToolManager`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.backend_tools import ToolBase, ToolToggleBase\n\nplt.rcParams['toolbar'] = 'toolmanager'\n\n\nclass ListTools(ToolBase):\n    \"\"\"List all the tools controlled by the `ToolManager`.\"\"\"\n    default_keymap = 'm'  # keyboard shortcut\n    description = 'List Tools'\n\n    def trigger(self, *args, **kwargs):\n        print('_' * 80)\n        fmt_tool = \"{:12} {:45} {}\".format\n        print(fmt_tool('Name (id)', 'Tool description', 'Keymap'))\n        print('-' * 80)\n        tools = self.toolmanager.tools\n        for name in sorted(tools):\n            if not tools[name].description:\n                continue\n            keys = ', '.join(sorted(self.toolmanager.get_tool_keymap(name)))\n            print(fmt_tool(name, tools[name].description, keys))\n        print('_' * 80)\n        fmt_active_toggle = \"{!s:12} {!s:45}\".format\n        print(\"Active Toggle tools\")\n        print(fmt_active_toggle(\"Group\", \"Active\"))\n        print('-' * 80)\n        for group, active in self.toolmanager.active_toggle.items():\n            print(fmt_active_toggle(group, active))\n\n\nclass GroupHideTool(ToolToggleBase):\n    \"\"\"Show lines with a given gid.\"\"\"\n    default_keymap = 'S'\n    description = 'Show by gid'\n    default_toggled = True\n\n    def __init__(self, *args, gid, **kwargs):\n        self.gid = gid\n        super().__init__(*args, **kwargs)\n\n    def enable(self, *args):\n        self.set_lines_visibility(True)\n\n    def disable(self, *args):\n        self.set_lines_visibility(False)\n\n    def set_lines_visibility(self, state):\n        for ax in self.figure.get_axes():\n            for line in ax.get_lines():\n                if line.get_gid() == self.gid:\n                    line.set_visible(state)\n        self.figure.canvas.draw()\n\n\nfig = plt.figure()\nplt.plot([1, 2, 3], gid='mygroup')\nplt.plot([2, 3, 4], gid='unknown')\nplt.plot([3, 2, 1], gid='mygroup')\n\n# Add the custom tools that we created\nfig.canvas.manager.toolmanager.add_tool('List', ListTools)\nfig.canvas.manager.toolmanager.add_tool('Show', GroupHideTool, gid='mygroup')\n\n# Add an existing tool to new group `foo`.\n# It can be added as many times as we want\nfig.canvas.manager.toolbar.add_tool('zoom', 'foo')\n\n# Remove the forward button\nfig.canvas.manager.toolmanager.remove_tool('forward')\n\n# To add a custom tool to the toolbar at specific location inside\n# the navigation group\nfig.canvas.manager.toolbar.add_tool('Show', 'navigation', 1)\n\nplt.show()\n"
    },
    {
      "filename": "web_application_server_sgskip.py",
      "title": "Web Application Server Sgskip",
      "code": "\"\"\"\n=========================================\nEmbed in a web application server (Flask)\n=========================================\n\nWhen using Matplotlib in a web server it is strongly recommended to not use\npyplot (pyplot maintains references to the opened figures to make\n`~.matplotlib.pyplot.show` work, but this will cause memory leaks unless the\nfigures are properly closed).\n\nSince Matplotlib 3.1, one can directly create figures using the `.Figure`\nconstructor and save them to in-memory buffers.  In older versions, it was\nnecessary to explicitly instantiate an Agg canvas (see e.g.\n:doc:`/gallery/user_interfaces/canvasagg`).\n\nThe following example uses Flask_, but other frameworks work similarly:\n\n.. _Flask: https://flask.palletsprojects.com\n\n\"\"\"\n\nimport base64\nfrom io import BytesIO\n\nfrom flask import Flask\n\nfrom matplotlib.figure import Figure\n\napp = Flask(__name__)\n\n\n@app.route(\"/\")\ndef hello():\n    # Generate the figure **without using pyplot**.\n    fig = Figure()\n    ax = fig.subplots()\n    ax.plot([1, 2])\n    # Save it to a temporary buffer.\n    buf = BytesIO()\n    fig.savefig(buf, format=\"png\")\n    # Embed the result in the html output.\n    data = base64.b64encode(buf.getbuffer()).decode(\"ascii\")\n    return f\"<img src='data:image/png;base64,{data}'/>\"\n\n# %%\n#\n# Since the above code is a Flask application, it should be run using the\n# `flask command-line tool <https://flask.palletsprojects.com/en/latest/cli/>`_\n# Assuming that the working directory contains this script:\n#\n# Unix-like systems\n#\n# .. code-block:: console\n#\n#  FLASK_APP=web_application_server_sgskip flask run\n#\n# Windows\n#\n# .. code-block:: console\n#\n#  set FLASK_APP=web_application_server_sgskip\n#  flask run\n#\n#\n# Clickable images for HTML\n# -------------------------\n#\n# Andrew Dalke of `Dalke Scientific <http://www.dalkescientific.com>`_\n# has written a nice `article\n# <http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html>`_\n# on how to make html click maps with Matplotlib agg PNGs.  We would\n# also like to add this functionality to SVG.  If you are interested in\n# contributing to these efforts that would be great.\n"
    },
    {
      "filename": "wxcursor_demo_sgskip.py",
      "title": "Wxcursor Demo Sgskip",
      "code": "\"\"\"\n==================\nAdd a cursor in WX\n==================\n\nExample to draw a cursor and report the data coords in wx.\n\"\"\"\n\nimport wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wx import NavigationToolbar2Wx\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self, ):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2*np.pi*t)\n\n        self.axes.plot(t, s)\n        self.axes.set_xlabel('t')\n        self.axes.set_ylabel('sin(t)')\n        self.figure_canvas = FigureCanvas(self, -1, self.figure)\n\n        # Note that event is a MplEvent\n        self.figure_canvas.mpl_connect(\n            'motion_notify_event', self.UpdateStatusBar)\n        self.figure_canvas.Bind(wx.EVT_ENTER_WINDOW, self.ChangeCursor)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.figure_canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.statusBar = wx.StatusBar(self, -1)\n        self.SetStatusBar(self.statusBar)\n\n        self.toolbar = NavigationToolbar2Wx(self.figure_canvas)\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.toolbar.Show()\n\n    def ChangeCursor(self, event):\n        self.figure_canvas.SetCursor(wx.Cursor(wx.CURSOR_BULLSEYE))\n\n    def UpdateStatusBar(self, event):\n        if event.inaxes:\n            self.statusBar.SetStatusText(f\"x={event.xdata}  y={event.ydata}\")\n\n\nclass App(wx.App):\n    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        frame = CanvasFrame()\n        self.SetTopWindow(frame)\n        frame.Show(True)\n        return True\n\n\nif __name__ == '__main__':\n    app = App()\n    app.MainLoop()\n"
    }
  ],
  "userdemo": [
    {
      "filename": "demo_gridspec06.py",
      "title": "Demo Gridspec06",
      "code": "r\"\"\"\n================\nNested GridSpecs\n================\n\nThis example demonstrates the use of nested `.GridSpec`\\s.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef squiggle_xy(a, b, c, d):\n    i = np.arange(0.0, 2*np.pi, 0.05)\n    return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d)\n\n\nfig = plt.figure(figsize=(8, 8))\nouter_grid = fig.add_gridspec(4, 4, wspace=0, hspace=0)\n\nfor a in range(4):\n    for b in range(4):\n        # gridspec inside gridspec\n        inner_grid = outer_grid[a, b].subgridspec(3, 3, wspace=0, hspace=0)\n        axs = inner_grid.subplots()  # Create all subplots for the inner grid.\n        for (c, d), ax in np.ndenumerate(axs):\n            ax.plot(*squiggle_xy(a + 1, b + 1, c + 1, d + 1))\n            ax.set(xticks=[], yticks=[])\n\n# show only the outside spines\nfor ax in fig.get_axes():\n    ss = ax.get_subplotspec()\n    ax.spines.top.set_visible(ss.is_first_row())\n    ax.spines.bottom.set_visible(ss.is_last_row())\n    ax.spines.left.set_visible(ss.is_first_col())\n    ax.spines.right.set_visible(ss.is_last_col())\n\nplt.show()\n"
    },
    {
      "filename": "simple_legend01.py",
      "title": "Simple Legend01",
      "code": "\"\"\"\n===============\nSimple Legend01\n===============\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfig = plt.figure()\n\nax = fig.add_subplot(211)\nax.plot([1, 2, 3], label=\"test1\")\nax.plot([3, 2, 1], label=\"test2\")\n# Place a legend above this subplot, expanding itself to\n# fully use the given bounding box.\nax.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc='lower left',\n           ncols=2, mode=\"expand\", borderaxespad=0.)\n\nax = fig.add_subplot(223)\nax.plot([1, 2, 3], label=\"test1\")\nax.plot([3, 2, 1], label=\"test2\")\n# Place a legend to the right of this smaller subplot.\nax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)\n\nplt.show()\n"
    },
    {
      "filename": "simple_legend02.py",
      "title": "Simple Legend02",
      "code": "\"\"\"\n===============\nSimple Legend02\n===============\n\n\"\"\"\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nline1, = ax.plot([1, 2, 3], label=\"Line 1\", linestyle='--')\nline2, = ax.plot([3, 2, 1], label=\"Line 2\", linewidth=4)\n\n# Create a legend for the first line.\nfirst_legend = ax.legend(handles=[line1], loc='upper right')\n\n# Add the legend manually to the current Axes.\nax.add_artist(first_legend)\n\n# Create another legend for the second line.\nax.legend(handles=[line2], loc='lower right')\n\nplt.show()\n"
    }
  ],
  "widgets": [
    {
      "filename": "annotated_cursor.py",
      "title": "Annotated Cursor",
      "code": "\"\"\"\n================\nAnnotated cursor\n================\n\nDisplay a data cursor including a text box, which shows the plot point close\nto the mouse pointer.\n\nThe new cursor inherits from `~matplotlib.widgets.Cursor` and demonstrates the\ncreation of new widgets and their event callbacks.\n\nSee also the :doc:`cross hair cursor\n</gallery/event_handling/cursor_demo>`, which implements a cursor tracking the\nplotted data, but without using inheritance and without displaying the\ncurrently tracked coordinates.\n\n.. note::\n    The figure related to this example does not show the cursor, because that\n    figure is automatically created in a build queue, where the first mouse\n    movement, which triggers the cursor creation, is missing.\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseEvent\nfrom matplotlib.widgets import Cursor\n\n\nclass AnnotatedCursor(Cursor):\n    \"\"\"\n    A crosshair cursor like `~matplotlib.widgets.Cursor` with a text showing \\\n    the current coordinates.\n\n    For the cursor to remain responsive you must keep a reference to it.\n    The data of the axis specified as *dataaxis* must be in ascending\n    order. Otherwise, the `numpy.searchsorted` call might fail and the text\n    disappears. You can satisfy the requirement by sorting the data you plot.\n    Usually the data is already sorted (if it was created e.g. using\n    `numpy.linspace`), but e.g. scatter plots might cause this problem.\n    The cursor sticks to the plotted line.\n\n    Parameters\n    ----------\n    line : `matplotlib.lines.Line2D`\n        The plot line from which the data coordinates are displayed.\n\n    numberformat : `python format string <https://docs.python.org/3/\\\n    library/string.html#formatstrings>`_, optional, default: \"{0:.4g};{1:.4g}\"\n        The displayed text is created by calling *format()* on this string\n        with the two coordinates.\n\n    offset : (float, float) default: (5, 5)\n        The offset in display (pixel) coordinates of the text position\n        relative to the cross-hair.\n\n    dataaxis : {\"x\", \"y\"}, optional, default: \"x\"\n        If \"x\" is specified, the vertical cursor line sticks to the mouse\n        pointer. The horizontal cursor line sticks to *line*\n        at that x value. The text shows the data coordinates of *line*\n        at the pointed x value. If you specify \"y\", it works in the opposite\n        manner. But: For the \"y\" value, where the mouse points to, there might\n        be multiple matching x values, if the plotted function is not biunique.\n        Cursor and text coordinate will always refer to only one x value.\n        So if you use the parameter value \"y\", ensure that your function is\n        biunique.\n\n    Other Parameters\n    ----------------\n    textprops : `matplotlib.text` properties as dictionary\n        Specifies the appearance of the rendered text object.\n\n    **cursorargs : `matplotlib.widgets.Cursor` properties\n        Arguments passed to the internal `~matplotlib.widgets.Cursor` instance.\n        The `matplotlib.axes.Axes` argument is mandatory! The parameter\n        *useblit* can be set to *True* in order to achieve faster rendering.\n\n    \"\"\"\n\n    def __init__(self, line, numberformat=\"{0:.4g};{1:.4g}\", offset=(5, 5),\n                 dataaxis='x', textprops=None, **cursorargs):\n        if textprops is None:\n            textprops = {}\n        # The line object, for which the coordinates are displayed\n        self.line = line\n        # The format string, on which .format() is called for creating the text\n        self.numberformat = numberformat\n        # Text position offset\n        self.offset = np.array(offset)\n        # The axis in which the cursor position is looked up\n        self.dataaxis = dataaxis\n\n        # First call baseclass constructor.\n        # Draws cursor and remembers background for blitting.\n        # Saves ax as class attribute.\n        super().__init__(**cursorargs)\n\n        # Default value for position of text.\n        self.set_position(self.line.get_xdata()[0], self.line.get_ydata()[0])\n        # Create invisible animated text\n        self.text = self.ax.text(\n            self.ax.get_xbound()[0],\n            self.ax.get_ybound()[0],\n            \"0, 0\",\n            animated=bool(self.useblit),\n            visible=False, **textprops)\n        # The position at which the cursor was last drawn\n        self.lastdrawnplotpoint = None\n\n    def onmove(self, event):\n        \"\"\"\n        Overridden draw callback for cursor. Called when moving the mouse.\n        \"\"\"\n\n        # Leave method under the same conditions as in overridden method\n        if self.ignore(event):\n            self.lastdrawnplotpoint = None\n            return\n        if not self.canvas.widgetlock.available(self):\n            self.lastdrawnplotpoint = None\n            return\n\n        # If the mouse left drawable area, we now make the text invisible.\n        # Baseclass will redraw complete canvas after, which makes both text\n        # and cursor disappear.\n        if event.inaxes != self.ax:\n            self.lastdrawnplotpoint = None\n            self.text.set_visible(False)\n            super().onmove(event)\n            return\n\n        # Get the coordinates, which should be displayed as text,\n        # if the event coordinates are valid.\n        plotpoint = None\n        if event.xdata is not None and event.ydata is not None:\n            # Get plot point related to current x position.\n            # These coordinates are displayed in text.\n            plotpoint = self.set_position(event.xdata, event.ydata)\n            # Modify event, such that the cursor is displayed on the\n            # plotted line, not at the mouse pointer,\n            # if the returned plot point is valid\n            if plotpoint is not None:\n                event.xdata = plotpoint[0]\n                event.ydata = plotpoint[1]\n\n        # If the plotpoint is given, compare to last drawn plotpoint and\n        # return if they are the same.\n        # Skip even the call of the base class, because this would restore the\n        # background, draw the cursor lines and would leave us the job to\n        # re-draw the text.\n        if plotpoint is not None and plotpoint == self.lastdrawnplotpoint:\n            return\n\n        # Baseclass redraws canvas and cursor. Due to blitting,\n        # the added text is removed in this call, because the\n        # background is redrawn.\n        super().onmove(event)\n\n        # Check if the display of text is still necessary.\n        # If not, just return.\n        # This behaviour is also cloned from the base class.\n        if not self.get_active() or not self.visible:\n            return\n\n        # Draw the widget, if event coordinates are valid.\n        if plotpoint is not None:\n            # Update position and displayed text.\n            # Position: Where the event occurred.\n            # Text: Determined by set_position() method earlier\n            # Position is transformed to pixel coordinates,\n            # an offset is added there and this is transformed back.\n            temp = [event.xdata, event.ydata]\n            temp = self.ax.transData.transform(temp)\n            temp = temp + self.offset\n            temp = self.ax.transData.inverted().transform(temp)\n            self.text.set_position(temp)\n            self.text.set_text(self.numberformat.format(*plotpoint))\n            self.text.set_visible(self.visible)\n\n            # Tell base class, that we have drawn something.\n            # Baseclass needs to know, that it needs to restore a clean\n            # background, if the cursor leaves our figure context.\n            self.needclear = True\n\n            # Remember the recently drawn cursor position, so events for the\n            # same position (mouse moves slightly between two plot points)\n            # can be skipped\n            self.lastdrawnplotpoint = plotpoint\n        # otherwise, make text invisible\n        else:\n            self.text.set_visible(False)\n\n        # Draw changes. Cannot use _update method of baseclass,\n        # because it would first restore the background, which\n        # is done already and is not necessary.\n        if self.useblit:\n            self.ax.draw_artist(self.text)\n            self.canvas.blit(self.ax.bbox)\n        else:\n            # If blitting is deactivated, the overridden _update call made\n            # by the base class immediately returned.\n            # We still have to draw the changes.\n            self.canvas.draw_idle()\n\n    def set_position(self, xpos, ypos):\n        \"\"\"\n        Finds the coordinates, which have to be shown in text.\n\n        The behaviour depends on the *dataaxis* attribute. Function looks\n        up the matching plot coordinate for the given mouse position.\n\n        Parameters\n        ----------\n        xpos : float\n            The current x position of the cursor in data coordinates.\n            Important if *dataaxis* is set to 'x'.\n        ypos : float\n            The current y position of the cursor in data coordinates.\n            Important if *dataaxis* is set to 'y'.\n\n        Returns\n        -------\n        ret : {2D array-like, None}\n            The coordinates which should be displayed.\n            *None* is the fallback value.\n        \"\"\"\n\n        # Get plot line data\n        xdata = self.line.get_xdata()\n        ydata = self.line.get_ydata()\n\n        # The dataaxis attribute decides, in which axis we look up which cursor\n        # coordinate.\n        if self.dataaxis == 'x':\n            pos = xpos\n            data = xdata\n            lim = self.ax.get_xlim()\n        elif self.dataaxis == 'y':\n            pos = ypos\n            data = ydata\n            lim = self.ax.get_ylim()\n        else:\n            raise ValueError(f\"The data axis specifier {self.dataaxis} should \"\n                             f\"be 'x' or 'y'\")\n\n        # If position is valid and in valid plot data range.\n        if pos is not None and lim[0] <= pos <= lim[-1]:\n            # Find closest x value in sorted x vector.\n            # This requires the plotted data to be sorted.\n            index = np.searchsorted(data, pos)\n            # Return none, if this index is out of range.\n            if index < 0 or index >= len(data):\n                return None\n            # Return plot point as tuple.\n            return (xdata[index], ydata[index])\n\n        # Return none if there is no good related point for this x position.\n        return None\n\n    def clear(self, event):\n        \"\"\"\n        Overridden clear callback for cursor, called before drawing the figure.\n        \"\"\"\n\n        # The base class saves the clean background for blitting.\n        # Text and cursor are invisible,\n        # until the first mouse move event occurs.\n        super().clear(event)\n        if self.ignore(event):\n            return\n        self.text.set_visible(False)\n\n    def _update(self):\n        \"\"\"\n        Overridden method for either blitting or drawing the widget canvas.\n\n        Passes call to base class if blitting is activated, only.\n        In other cases, one draw_idle call is enough, which is placed\n        explicitly in this class (see *onmove()*).\n        In that case, `~matplotlib.widgets.Cursor` is not supposed to draw\n        something using this method.\n        \"\"\"\n\n        if self.useblit:\n            super()._update()\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.set_title(\"Cursor Tracking x Position\")\n\nx = np.linspace(-5, 5, 1000)\ny = x**2\n\nline, = ax.plot(x, y)\nax.set_xlim(-5, 5)\nax.set_ylim(0, 25)\n\n# A minimum call\n# Set useblit=True on most backends for enhanced performance\n# and pass the ax parameter to the Cursor base class.\n# cursor = AnnotatedCursor(line=lin[0], ax=ax, useblit=True)\n\n# A more advanced call. Properties for text and lines are passed.\n# Watch the passed color names and the color of cursor line and text, to\n# relate the passed options to graphical elements.\n# The dataaxis parameter is still the default.\ncursor = AnnotatedCursor(\n    line=line,\n    numberformat=\"{0:.2f}\\n{1:.2f}\",\n    dataaxis='x', offset=[10, 10],\n    textprops={'color': 'blue', 'fontweight': 'bold'},\n    ax=ax,\n    useblit=True,\n    color='red',\n    linewidth=2)\n\n# Simulate a mouse move to (-2, 10), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((-2, 10))\n)._process()\n\nplt.show()\n\n# %%\n# Trouble with non-biunique functions\n# -----------------------------------\n# A call demonstrating problems with the *dataaxis=y* parameter.\n# The text now looks up the matching x value for the current cursor y position\n# instead of vice versa. Hover your cursor to y=4. There are two x values\n# producing this y value: -2 and 2. The function is only unique,\n# but not biunique. Only one value is shown in the text.\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.set_title(\"Cursor Tracking y Position\")\n\nline, = ax.plot(x, y)\nax.set_xlim(-5, 5)\nax.set_ylim(0, 25)\n\ncursor = AnnotatedCursor(\n    line=line,\n    numberformat=\"{0:.2f}\\n{1:.2f}\",\n    dataaxis='y', offset=[10, 10],\n    textprops={'color': 'blue', 'fontweight': 'bold'},\n    ax=ax,\n    useblit=True,\n    color='red', linewidth=2)\n\n# Simulate a mouse move to (-2, 10), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((-2, 10))\n)._process()\n\nplt.show()\n"
    },
    {
      "filename": "buttons.py",
      "title": "Buttons",
      "code": "\"\"\"\n=======\nButtons\n=======\n\nConstructing a simple button GUI to modify a sine wave.\n\nThe ``next`` and ``previous`` button widget helps visualize the wave with\nnew frequencies.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Button\n\nfreqs = np.arange(2, 20, 3)\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(bottom=0.2)\nt = np.arange(0.0, 1.0, 0.001)\ns = np.sin(2*np.pi*freqs[0]*t)\nl, = ax.plot(t, s, lw=2)\n\n\nclass Index:\n    ind = 0\n\n    def next(self, event):\n        self.ind += 1\n        i = self.ind % len(freqs)\n        ydata = np.sin(2*np.pi*freqs[i]*t)\n        l.set_ydata(ydata)\n        plt.draw()\n\n    def prev(self, event):\n        self.ind -= 1\n        i = self.ind % len(freqs)\n        ydata = np.sin(2*np.pi*freqs[i]*t)\n        l.set_ydata(ydata)\n        plt.draw()\n\ncallback = Index()\naxprev = fig.add_axes([0.7, 0.05, 0.1, 0.075])\naxnext = fig.add_axes([0.81, 0.05, 0.1, 0.075])\nbnext = Button(axnext, 'Next')\nbnext.on_clicked(callback.next)\nbprev = Button(axprev, 'Previous')\nbprev.on_clicked(callback.prev)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.Button`\n"
    },
    {
      "filename": "check_buttons.py",
      "title": "Check Buttons",
      "code": "\"\"\"\n=============\nCheck buttons\n=============\n\nTurning visual elements on and off with check buttons.\n\nThis program shows the use of `.CheckButtons` which is similar to\ncheck boxes. There are 3 different sine waves shown, and we can choose which\nwaves are displayed with the check buttons.\n\nCheck buttons may be styled using the *check_props*, *frame_props*, and *label_props*\nparameters. The parameters each take a dictionary with keys of artist property names and\nvalues of lists of settings with length matching the number of buttons.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import CheckButtons\n\nt = np.arange(0.0, 2.0, 0.01)\ns0 = np.sin(2*np.pi*t)\ns1 = np.sin(4*np.pi*t)\ns2 = np.sin(6*np.pi*t)\n\nfig, ax = plt.subplots()\nl0, = ax.plot(t, s0, visible=False, lw=2, color='black', label='1 Hz')\nl1, = ax.plot(t, s1, lw=2, color='red', label='2 Hz')\nl2, = ax.plot(t, s2, lw=2, color='green', label='3 Hz')\n\nlines_by_label = {l.get_label(): l for l in [l0, l1, l2]}\nline_colors = [l.get_color() for l in lines_by_label.values()]\n\n# Make checkbuttons with all plotted lines with correct visibility\nrax = ax.inset_axes([0.0, 0.0, 0.12, 0.2])\ncheck = CheckButtons(\n    ax=rax,\n    labels=lines_by_label.keys(),\n    actives=[l.get_visible() for l in lines_by_label.values()],\n    label_props={'color': line_colors},\n    frame_props={'edgecolor': line_colors},\n    check_props={'facecolor': line_colors},\n)\n\n\ndef callback(label):\n    ln = lines_by_label[label]\n    ln.set_visible(not ln.get_visible())\n    ln.figure.canvas.draw_idle()\n\ncheck.on_clicked(callback)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.CheckButtons`\n"
    },
    {
      "filename": "cursor.py",
      "title": "Cursor",
      "code": "\"\"\"\n======\nCursor\n======\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Cursor\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots(figsize=(8, 6))\n\nx, y = 4*(np.random.rand(2, 100) - .5)\nax.plot(x, y, 'o')\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\n\n# Set useblit=True on most backends for enhanced performance.\ncursor = Cursor(ax, useblit=True, color='red', linewidth=2)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.Cursor`\n"
    },
    {
      "filename": "lasso_selector_demo_sgskip.py",
      "title": "Lasso Selector Demo Sgskip",
      "code": "\"\"\"\n==============\nLasso Selector\n==============\n\nInteractively selecting data points with the lasso tool.\n\nThis examples plots a scatter plot. You can then select a few points by drawing\na lasso loop around the points on the graph. To draw, just click\non the graph, hold, and drag it around the points you need to select.\n\"\"\"\n\n\nimport numpy as np\n\nfrom matplotlib.path import Path\nfrom matplotlib.widgets import LassoSelector\n\n\nclass SelectFromCollection:\n    \"\"\"\n    Select indices from a matplotlib collection using `LassoSelector`.\n\n    Selected indices are saved in the `ind` attribute. This tool fades out the\n    points that are not part of the selection (i.e., reduces their alpha\n    values). If your collection has alpha < 1, this tool will permanently\n    alter the alpha values.\n\n    Note that this tool selects collection objects based on their *origins*\n    (i.e., `offsets`).\n\n    Parameters\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        Axes to interact with.\n    collection : `matplotlib.collections.Collection` subclass\n        Collection you want to select from.\n    alpha_other : 0 <= float <= 1\n        To highlight a selection, this tool sets all selected points to an\n        alpha value of 1 and non-selected points to *alpha_other*.\n    \"\"\"\n\n    def __init__(self, ax, collection, alpha_other=0.3):\n        self.canvas = ax.figure.canvas\n        self.collection = collection\n        self.alpha_other = alpha_other\n\n        self.xys = collection.get_offsets()\n        self.Npts = len(self.xys)\n\n        # Ensure that we have separate colors for each object\n        self.fc = collection.get_facecolors()\n        if len(self.fc) == 0:\n            raise ValueError('Collection must have a facecolor')\n        elif len(self.fc) == 1:\n            self.fc = np.tile(self.fc, (self.Npts, 1))\n\n        self.lasso = LassoSelector(ax, onselect=self.onselect)\n        self.ind = []\n\n    def onselect(self, verts):\n        path = Path(verts)\n        self.ind = np.nonzero(path.contains_points(self.xys))[0]\n        self.fc[:, -1] = self.alpha_other\n        self.fc[self.ind, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n    def disconnect(self):\n        self.lasso.disconnect_events()\n        self.fc[:, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    data = np.random.rand(100, 2)\n\n    subplot_kw = dict(xlim=(0, 1), ylim=(0, 1), autoscale_on=False)\n    fig, ax = plt.subplots(subplot_kw=subplot_kw)\n\n    pts = ax.scatter(data[:, 0], data[:, 1], s=80)\n    selector = SelectFromCollection(ax, pts)\n\n    def accept(event):\n        if event.key == \"enter\":\n            print(\"Selected points:\")\n            print(selector.xys[selector.ind])\n            selector.disconnect()\n            ax.set_title(\"\")\n            fig.canvas.draw()\n\n    fig.canvas.mpl_connect(\"key_press_event\", accept)\n    ax.set_title(\"Press enter to accept selected points.\")\n\n    plt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.LassoSelector`\n#    - `matplotlib.path.Path`\n"
    },
    {
      "filename": "menu.py",
      "title": "Menu",
      "code": "\"\"\"\n====\nMenu\n====\n\nUsing texts to construct a simple menu.\n\"\"\"\n\nfrom dataclasses import dataclass\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.artist as artist\nimport matplotlib.patches as patches\nfrom matplotlib.typing import ColorType\n\n\n@dataclass\nclass ItemProperties:\n    fontsize: float = 14\n    labelcolor: ColorType = 'black'\n    bgcolor: ColorType = 'yellow'\n    alpha: float = 1.0\n\n\nclass MenuItem(artist.Artist):\n    padx = 0.05  # inches\n    pady = 0.05\n\n    def __init__(self, fig, labelstr, props=None, hoverprops=None,\n                 on_select=None):\n        super().__init__()\n\n        self.set_figure(fig)\n        self.labelstr = labelstr\n\n        self.props = props if props is not None else ItemProperties()\n        self.hoverprops = (\n            hoverprops if hoverprops is not None else ItemProperties())\n        if self.props.fontsize != self.hoverprops.fontsize:\n            raise NotImplementedError(\n                'support for different font sizes not implemented')\n\n        self.on_select = on_select\n\n        # specify coordinates in inches.\n        self.label = fig.text(0, 0, labelstr, transform=fig.dpi_scale_trans,\n                              size=props.fontsize)\n        self.text_bbox = self.label.get_window_extent(\n            fig.canvas.get_renderer())\n        self.text_bbox = fig.dpi_scale_trans.inverted().transform_bbox(self.text_bbox)\n\n        self.rect = patches.Rectangle(\n            (0, 0), 1, 1, transform=fig.dpi_scale_trans\n        )  # Will be updated later.\n\n        self.set_hover_props(False)\n\n        fig.canvas.mpl_connect('button_release_event', self.check_select)\n\n    def check_select(self, event):\n        over, _ = self.rect.contains(event)\n        if not over:\n            return\n        if self.on_select is not None:\n            self.on_select(self)\n\n    def set_extent(self, x, y, w, h, depth):\n        self.rect.set(x=x, y=y, width=w, height=h)\n        self.label.set(position=(x + self.padx, y + depth + self.pady / 2))\n        self.hover = False\n\n    def draw(self, renderer):\n        self.rect.draw(renderer)\n        self.label.draw(renderer)\n\n    def set_hover_props(self, b):\n        props = self.hoverprops if b else self.props\n        self.label.set(color=props.labelcolor)\n        self.rect.set(facecolor=props.bgcolor, alpha=props.alpha)\n\n    def set_hover(self, event):\n        \"\"\"\n        Update the hover status of event and return whether it was changed.\n        \"\"\"\n        b, _ = self.rect.contains(event)\n        changed = (b != self.hover)\n        if changed:\n            self.set_hover_props(b)\n        self.hover = b\n        return changed\n\n\nclass Menu:\n    def __init__(self, fig, menuitems):\n        self.figure = fig\n\n        self.menuitems = menuitems\n\n        maxw = max(item.text_bbox.width for item in menuitems)\n        maxh = max(item.text_bbox.height for item in menuitems)\n        depth = max(-item.text_bbox.y0 for item in menuitems)\n\n        x0 = 1\n        y0 = 4\n\n        width = maxw + 2 * MenuItem.padx\n        height = maxh + MenuItem.pady\n\n        for item in menuitems:\n            left = x0\n            bottom = y0 - maxh - MenuItem.pady\n\n            item.set_extent(left, bottom, width, height, depth)\n\n            fig.artists.append(item)\n            y0 -= maxh + MenuItem.pady\n\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n\n    def on_move(self, event):\n        if any(item.set_hover(event) for item in self.menuitems):\n            self.figure.canvas.draw()\n\n\nfig = plt.figure()\nfig.subplots_adjust(left=0.3)\nprops = ItemProperties(labelcolor='black', bgcolor='yellow',\n                       fontsize=15, alpha=0.2)\nhoverprops = ItemProperties(labelcolor='white', bgcolor='blue',\n                            fontsize=15, alpha=0.2)\n\nmenuitems = []\nfor label in ('open', 'close', 'save', 'save as', 'quit'):\n    def on_select(item):\n        print(f'you selected {item.labelstr}')\n    item = MenuItem(fig, label, props=props, hoverprops=hoverprops,\n                    on_select=on_select)\n    menuitems.append(item)\n\nmenu = Menu(fig, menuitems)\nplt.show()\n"
    },
    {
      "filename": "mouse_cursor.py",
      "title": "Mouse Cursor",
      "code": "\"\"\"\n============\nMouse Cursor\n============\n\nThis example sets an alternative cursor on a figure canvas.\n\nNote, this is an interactive example, and must be run to see the effect.\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.backend_tools import Cursors\n\nfig, axs = plt.subplots(len(Cursors), figsize=(6, len(Cursors) + 0.5),\n                        gridspec_kw={'hspace': 0})\nfig.suptitle('Hover over an Axes to see alternate Cursors')\n\nfor cursor, ax in zip(Cursors, axs):\n    ax.cursor_to_use = cursor\n    ax.text(0.5, 0.5, cursor.name,\n            horizontalalignment='center', verticalalignment='center')\n    ax.set(xticks=[], yticks=[])\n\n\ndef hover(event):\n    if fig.canvas.widgetlock.locked():\n        # Don't do anything if the zoom/pan tools have been enabled.\n        return\n\n    fig.canvas.set_cursor(\n        event.inaxes.cursor_to_use if event.inaxes else Cursors.POINTER)\n\n\nfig.canvas.mpl_connect('motion_notify_event', hover)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.backend_bases.FigureCanvasBase.set_cursor`\n"
    },
    {
      "filename": "multicursor.py",
      "title": "Multicursor",
      "code": "\"\"\"\n===========\nMulticursor\n===========\n\nShowing a cursor on multiple plots simultaneously.\n\nThis example generates three Axes split over two different figures.  On\nhovering the cursor over data in one subplot, the values of that datapoint are\nshown in all Axes.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import MultiCursor\n\nt = np.arange(0.0, 2.0, 0.01)\ns1 = np.sin(2*np.pi*t)\ns2 = np.sin(3*np.pi*t)\ns3 = np.sin(4*np.pi*t)\n\nfig, (ax1, ax2) = plt.subplots(2, sharex=True)\nax1.plot(t, s1)\nax2.plot(t, s2)\nfig, ax3 = plt.subplots()\nax3.plot(t, s3)\n\nmulti = MultiCursor(None, (ax1, ax2, ax3), color='r', lw=1)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.MultiCursor`\n"
    },
    {
      "filename": "polygon_selector_demo.py",
      "title": "Polygon Selector Demo",
      "code": "\"\"\"\n=======================================================\nSelect indices from a collection using polygon selector\n=======================================================\n\nShows how one can select indices of a polygon interactively.\n\"\"\"\n\nimport numpy as np\n\nfrom matplotlib.path import Path\nfrom matplotlib.widgets import PolygonSelector\n\n\nclass SelectFromCollection:\n    \"\"\"\n    Select indices from a matplotlib collection using `PolygonSelector`.\n\n    Selected indices are saved in the `ind` attribute. This tool fades out the\n    points that are not part of the selection (i.e., reduces their alpha\n    values). If your collection has alpha < 1, this tool will permanently\n    alter the alpha values.\n\n    Note that this tool selects collection objects based on their *origins*\n    (i.e., `offsets`).\n\n    Parameters\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        Axes to interact with.\n    collection : `matplotlib.collections.Collection` subclass\n        Collection you want to select from.\n    alpha_other : 0 <= float <= 1\n        To highlight a selection, this tool sets all selected points to an\n        alpha value of 1 and non-selected points to *alpha_other*.\n    \"\"\"\n\n    def __init__(self, ax, collection, alpha_other=0.3):\n        self.canvas = ax.figure.canvas\n        self.collection = collection\n        self.alpha_other = alpha_other\n\n        self.xys = collection.get_offsets()\n        self.Npts = len(self.xys)\n\n        # Ensure that we have separate colors for each object\n        self.fc = collection.get_facecolors()\n        if len(self.fc) == 0:\n            raise ValueError('Collection must have a facecolor')\n        elif len(self.fc) == 1:\n            self.fc = np.tile(self.fc, (self.Npts, 1))\n\n        self.poly = PolygonSelector(ax, self.onselect, draw_bounding_box=True)\n        self.ind = []\n\n    def onselect(self, verts):\n        path = Path(verts)\n        self.ind = np.nonzero(path.contains_points(self.xys))[0]\n        self.fc[:, -1] = self.alpha_other\n        self.fc[self.ind, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n    def disconnect(self):\n        self.poly.disconnect_events()\n        self.fc[:, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    fig, ax = plt.subplots()\n    grid_size = 5\n    grid_x = np.tile(np.arange(grid_size), grid_size)\n    grid_y = np.repeat(np.arange(grid_size), grid_size)\n    pts = ax.scatter(grid_x, grid_y)\n\n    selector = SelectFromCollection(ax, pts)\n\n    print(\"Select points in the figure by enclosing them within a polygon.\")\n    print(\"Press the 'esc' key to start a new polygon.\")\n    print(\"Try holding the 'shift' key to move all of the vertices.\")\n    print(\"Try holding the 'ctrl' key to move a single vertex.\")\n\n    plt.show()\n\n    selector.disconnect()\n\n    # After figure is closed print the coordinates of the selected points\n    print('\\nSelected points:')\n    print(selector.xys[selector.ind])\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.PolygonSelector`\n#    - `matplotlib.path.Path`\n"
    },
    {
      "filename": "polygon_selector_simple.py",
      "title": "Polygon Selector Simple",
      "code": "\"\"\"\n================\nPolygon Selector\n================\n\nShows how to create a polygon programmatically or interactively\n\"\"\"\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.widgets import PolygonSelector\n\n# %%\n#\n# To create the polygon programmatically\nfig, ax = plt.subplots()\nfig.show()\n\nselector = PolygonSelector(ax, lambda *args: None)\n\n# Add three vertices\nselector.verts = [(0.1, 0.4), (0.5, 0.9), (0.3, 0.2)]\n\n\n# %%\n#\n# To create the polygon interactively\n\nfig2, ax2 = plt.subplots()\nfig2.show()\n\nselector2 = PolygonSelector(ax2, lambda *args: None)\n\nprint(\"Click on the figure to create a polygon.\")\nprint(\"Press the 'esc' key to start a new polygon.\")\nprint(\"Try holding the 'shift' key to move all of the vertices.\")\nprint(\"Try holding the 'ctrl' key to move a single vertex.\")\n\n\n# %%\n# .. tags::\n#\n#    component: axes,\n#    styling: position,\n#    plot-type: line,\n#    level: intermediate,\n#    domain: cartography,\n#    domain: geometry,\n#    domain: statistics,\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.PolygonSelector`\n"
    },
    {
      "filename": "radio_buttons.py",
      "title": "Radio Buttons",
      "code": "\"\"\"\n=============\nRadio Buttons\n=============\n\nUsing radio buttons to choose properties of your plot.\n\nRadio buttons let you choose between multiple options in a visualization.\nIn this case, the buttons let the user choose one of the three different sine\nwaves to be shown in the plot.\n\nRadio buttons may be styled using the *label_props* and *radio_props* parameters, which\neach take a dictionary with keys of artist property names and values of lists of\nsettings with length matching the number of buttons.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import RadioButtons\n\nt = np.arange(0.0, 2.0, 0.01)\ns0 = np.sin(2*np.pi*t)\ns1 = np.sin(4*np.pi*t)\ns2 = np.sin(8*np.pi*t)\n\nfig, ax = plt.subplot_mosaic(\n    [\n        ['main', 'freq'],\n        ['main', 'color'],\n        ['main', 'linestyle'],\n    ],\n    width_ratios=[5, 1],\n    layout='constrained',\n)\nl, = ax['main'].plot(t, s0, lw=2, color='red')\n\nradio_background = 'lightgoldenrodyellow'\n\nax['freq'].set_facecolor(radio_background)\nradio = RadioButtons(ax['freq'], ('1 Hz', '2 Hz', '4 Hz'),\n                     label_props={'color': 'cmy', 'fontsize': [12, 14, 16]},\n                     radio_props={'s': [16, 32, 64]})\n\n\ndef hzfunc(label):\n    hzdict = {'1 Hz': s0, '2 Hz': s1, '4 Hz': s2}\n    ydata = hzdict[label]\n    l.set_ydata(ydata)\n    fig.canvas.draw()\nradio.on_clicked(hzfunc)\n\nax['color'].set_facecolor(radio_background)\nradio2 = RadioButtons(\n    ax['color'], ('red', 'blue', 'green'),\n    label_props={'color': ['red', 'blue', 'green']},\n    radio_props={\n        'facecolor': ['red', 'blue', 'green'],\n        'edgecolor': ['darkred', 'darkblue', 'darkgreen'],\n    })\n\n\ndef colorfunc(label):\n    l.set_color(label)\n    fig.canvas.draw()\nradio2.on_clicked(colorfunc)\n\nax['linestyle'].set_facecolor(radio_background)\nradio3 = RadioButtons(ax['linestyle'], ('-', '--', '-.', ':'))\n\n\ndef stylefunc(label):\n    l.set_linestyle(label)\n    fig.canvas.draw()\nradio3.on_clicked(stylefunc)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.RadioButtons`\n"
    },
    {
      "filename": "range_slider.py",
      "title": "Range Slider",
      "code": "\"\"\"\n=================================\nImage scaling using a RangeSlider\n=================================\n\nUsing the RangeSlider widget to control the thresholding of an image.\n\nThe RangeSlider widget can be used similarly to the `.widgets.Slider`\nwidget. The major difference is that RangeSlider's ``val`` attribute\nis a tuple of floats ``(lower val, upper val)`` rather than a single float.\n\nSee :doc:`/gallery/widgets/slider_demo` for an example of using\na ``Slider`` to control a single float.\n\nSee :doc:`/gallery/widgets/slider_snap_demo` for an example of having\nthe ``Slider`` snap to discrete values.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import RangeSlider\n\n# generate a fake image\nnp.random.seed(19680801)\nN = 128\nimg = np.random.randn(N, N)\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nfig.subplots_adjust(bottom=0.25)\n\nim = axs[0].imshow(img)\naxs[1].hist(img.flatten(), bins='auto')\naxs[1].set_title('Histogram of pixel intensities')\n\n# Create the RangeSlider\nslider_ax = fig.add_axes([0.20, 0.1, 0.60, 0.03])\nslider = RangeSlider(slider_ax, \"Threshold\", img.min(), img.max())\n\n# Create the Vertical lines on the histogram\nlower_limit_line = axs[1].axvline(slider.val[0], color='k')\nupper_limit_line = axs[1].axvline(slider.val[1], color='k')\n\n\ndef update(val):\n    # The val passed to a callback by the RangeSlider will\n    # be a tuple of (min, max)\n\n    # Update the image's colormap\n    im.norm.vmin = val[0]\n    im.norm.vmax = val[1]\n\n    # Update the position of the vertical lines\n    lower_limit_line.set_xdata([val[0], val[0]])\n    upper_limit_line.set_xdata([val[1], val[1]])\n\n    # Redraw the figure to ensure it updates\n    fig.canvas.draw_idle()\n\n\nslider.on_changed(update)\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.RangeSlider`\n"
    },
    {
      "filename": "rectangle_selector.py",
      "title": "Rectangle Selector",
      "code": "\"\"\"\n===============================\nRectangle and ellipse selectors\n===============================\n\nClick somewhere, move the mouse, and release the mouse button.\n`.RectangleSelector` and `.EllipseSelector` draw a rectangle or an ellipse\nfrom the initial click position to the current mouse position (within the same\naxes) until the button is released.  A connected callback receives the click-\nand release-events.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import EllipseSelector, RectangleSelector\n\n\ndef select_callback(eclick, erelease):\n    \"\"\"\n    Callback for line selection.\n\n    *eclick* and *erelease* are the press and release events.\n    \"\"\"\n    x1, y1 = eclick.xdata, eclick.ydata\n    x2, y2 = erelease.xdata, erelease.ydata\n    print(f\"({x1:3.2f}, {y1:3.2f}) --> ({x2:3.2f}, {y2:3.2f})\")\n    print(f\"The buttons you used were: {eclick.button} {erelease.button}\")\n\n\ndef toggle_selector(event):\n    print('Key pressed.')\n    if event.key == 't':\n        for selector in selectors:\n            name = type(selector).__name__\n            if selector.active:\n                print(f'{name} deactivated.')\n                selector.set_active(False)\n            else:\n                print(f'{name} activated.')\n                selector.set_active(True)\n\n\nfig = plt.figure(layout='constrained')\naxs = fig.subplots(2)\n\nN = 100000  # If N is large one can see improvement by using blitting.\nx = np.linspace(0, 10, N)\n\nselectors = []\nfor ax, selector_class in zip(axs, [RectangleSelector, EllipseSelector]):\n    ax.plot(x, np.sin(2*np.pi*x))  # plot something\n    ax.set_title(f\"Click and drag to draw a {selector_class.__name__}.\")\n    selectors.append(selector_class(\n        ax, select_callback,\n        useblit=True,\n        button=[1, 3],  # disable middle button\n        minspanx=5, minspany=5,\n        spancoords='pixels',\n        interactive=True))\n    fig.canvas.mpl_connect('key_press_event', toggle_selector)\naxs[0].set_title(\"Press 't' to toggle the selectors on and off.\\n\"\n                 + axs[0].get_title())\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.RectangleSelector`\n#    - `matplotlib.widgets.EllipseSelector`\n"
    },
    {
      "filename": "slider_demo.py",
      "title": "Slider Demo",
      "code": "\"\"\"\n======\nSlider\n======\n\nIn this example, sliders are used to control the frequency and amplitude of\na sine wave.\n\nSee :doc:`/gallery/widgets/slider_snap_demo` for an example of having\nthe ``Slider`` snap to discrete values.\n\nSee :doc:`/gallery/widgets/range_slider` for an example of using\na ``RangeSlider`` to define a range of values.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Button, Slider\n\n\n# The parametrized function to be plotted\ndef f(t, amplitude, frequency):\n    return amplitude * np.sin(2 * np.pi * frequency * t)\n\nt = np.linspace(0, 1, 1000)\n\n# Define initial parameters\ninit_amplitude = 5\ninit_frequency = 3\n\n# Create the figure and the line that we will manipulate\nfig, ax = plt.subplots()\nline, = ax.plot(t, f(t, init_amplitude, init_frequency), lw=2)\nax.set_xlabel('Time [s]')\n\n# adjust the main plot to make room for the sliders\nfig.subplots_adjust(left=0.25, bottom=0.25)\n\n# Make a horizontal slider to control the frequency.\naxfreq = fig.add_axes([0.25, 0.1, 0.65, 0.03])\nfreq_slider = Slider(\n    ax=axfreq,\n    label='Frequency [Hz]',\n    valmin=0.1,\n    valmax=30,\n    valinit=init_frequency,\n)\n\n# Make a vertically oriented slider to control the amplitude\naxamp = fig.add_axes([0.1, 0.25, 0.0225, 0.63])\namp_slider = Slider(\n    ax=axamp,\n    label=\"Amplitude\",\n    valmin=0,\n    valmax=10,\n    valinit=init_amplitude,\n    orientation=\"vertical\"\n)\n\n\n# The function to be called anytime a slider's value changes\ndef update(val):\n    line.set_ydata(f(t, amp_slider.val, freq_slider.val))\n    fig.canvas.draw_idle()\n\n\n# register the update function with each slider\nfreq_slider.on_changed(update)\namp_slider.on_changed(update)\n\n# Create a `matplotlib.widgets.Button` to reset the sliders to initial values.\nresetax = fig.add_axes([0.8, 0.025, 0.1, 0.04])\nbutton = Button(resetax, 'Reset', hovercolor='0.975')\n\n\ndef reset(event):\n    freq_slider.reset()\n    amp_slider.reset()\nbutton.on_clicked(reset)\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.Button`\n#    - `matplotlib.widgets.Slider`\n"
    },
    {
      "filename": "slider_snap_demo.py",
      "title": "Slider Snap Demo",
      "code": "\"\"\"\n===============================\nSnap sliders to discrete values\n===============================\n\nYou can snap slider values to discrete values using the ``valstep`` argument.\n\nIn this example the Freq slider is constrained to be multiples of pi, and the\nAmp slider uses an array as the ``valstep`` argument to more densely sample\nthe first part of its range.\n\nSee :doc:`/gallery/widgets/slider_demo` for an example of using\na ``Slider`` to control a single float.\n\nSee :doc:`/gallery/widgets/range_slider` for an example of using\na ``RangeSlider`` to define a range of values.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Button, Slider\n\nt = np.arange(0.0, 1.0, 0.001)\na0 = 5\nf0 = 3\ns = a0 * np.sin(2 * np.pi * f0 * t)\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(bottom=0.25)\nl, = ax.plot(t, s, lw=2)\n\nax_freq = fig.add_axes([0.25, 0.1, 0.65, 0.03])\nax_amp = fig.add_axes([0.25, 0.15, 0.65, 0.03])\n\n# define the values to use for snapping\nallowed_amplitudes = np.concatenate([np.linspace(.1, 5, 100), [6, 7, 8, 9]])\n\n# create the sliders\nsamp = Slider(\n    ax_amp, \"Amp\", 0.1, 9.0,\n    valinit=a0, valstep=allowed_amplitudes,\n    color=\"green\"\n)\n\nsfreq = Slider(\n    ax_freq, \"Freq\", 0, 10*np.pi,\n    valinit=2*np.pi, valstep=np.pi,\n    initcolor='none'  # Remove the line marking the valinit position.\n)\n\n\ndef update(val):\n    amp = samp.val\n    freq = sfreq.val\n    l.set_ydata(amp*np.sin(2*np.pi*freq*t))\n    fig.canvas.draw_idle()\n\n\nsfreq.on_changed(update)\nsamp.on_changed(update)\n\nax_reset = fig.add_axes([0.8, 0.025, 0.1, 0.04])\nbutton = Button(ax_reset, 'Reset', hovercolor='0.975')\n\n\ndef reset(event):\n    sfreq.reset()\n    samp.reset()\nbutton.on_clicked(reset)\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.Slider`\n#    - `matplotlib.widgets.Button`\n"
    },
    {
      "filename": "span_selector.py",
      "title": "Span Selector",
      "code": "\"\"\"\n=============\nSpan Selector\n=============\n\nThe `.SpanSelector` is a mouse widget that enables selecting a range on an\naxis.\n\nHere, an x-range can be selected on the upper axis; a detailed view of the\nselected range is then plotted on the lower axis.\n\n.. note::\n\n    If the SpanSelector object is garbage collected you will lose the\n    interactivity.  You must keep a hard reference to it to prevent this.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import SpanSelector\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, (ax1, ax2) = plt.subplots(2, figsize=(8, 6))\n\nx = np.arange(0.0, 5.0, 0.01)\ny = np.sin(2 * np.pi * x) + 0.5 * np.random.randn(len(x))\n\nax1.plot(x, y)\nax1.set_ylim(-2, 2)\nax1.set_title('Press left mouse button and drag '\n              'to select a region in the top graph')\n\nline2, = ax2.plot([], [])\n\n\ndef onselect(xmin, xmax):\n    indmin, indmax = np.searchsorted(x, (xmin, xmax))\n    indmax = min(len(x) - 1, indmax)\n\n    region_x = x[indmin:indmax]\n    region_y = y[indmin:indmax]\n\n    if len(region_x) >= 2:\n        line2.set_data(region_x, region_y)\n        ax2.set_xlim(region_x[0], region_x[-1])\n        ax2.set_ylim(region_y.min(), region_y.max())\n        fig.canvas.draw_idle()\n\n\nspan = SpanSelector(\n    ax1,\n    onselect,\n    \"horizontal\",\n    useblit=True,\n    props=dict(alpha=0.5, facecolor=\"tab:blue\"),\n    interactive=True,\n    drag_from_anywhere=True\n)\n# Set useblit=True on most backends for enhanced performance.\n\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.SpanSelector`\n"
    },
    {
      "filename": "textbox.py",
      "title": "Textbox",
      "code": "\"\"\"\n=======\nTextbox\n=======\n\nThe Textbox widget lets users interactively provide text input, including\nformulas. In this example, the plot is updated using the `.on_submit` method.\nThis method triggers the execution of the *submit* function when the\nuser presses enter in the textbox or leaves the textbox.\n\nNote:  The `matplotlib.widgets.TextBox` widget is different from the following\nstatic elements: :ref:`annotations` and\n:doc:`/gallery/text_labels_and_annotations/placing_text_boxes`.\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import TextBox\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(bottom=0.2)\n\nt = np.arange(-2.0, 2.0, 0.001)\nl, = ax.plot(t, np.zeros_like(t), lw=2)\n\n\ndef submit(expression):\n    \"\"\"\n    Update the plotted function to the new math *expression*.\n\n    *expression* is a string using \"t\" as its independent variable, e.g.\n    \"t ** 3\".\n    \"\"\"\n    ydata = eval(expression, {'np': np}, {'t': t})\n    l.set_ydata(ydata)\n    ax.relim()\n    ax.autoscale_view()\n    plt.draw()\n\n\naxbox = fig.add_axes([0.1, 0.05, 0.8, 0.075])\ntext_box = TextBox(axbox, \"Evaluate\", textalignment=\"center\")\ntext_box.on_submit(submit)\ntext_box.set_val(\"t ** 2\")  # Trigger `submit` with the initial string.\n\nplt.show()\n\n# %%\n#\n# .. admonition:: References\n#\n#    The use of the following functions, methods, classes and modules is shown\n#    in this example:\n#\n#    - `matplotlib.widgets.TextBox`\n"
    }
  ]
}